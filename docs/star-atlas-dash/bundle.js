
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function not_equal(a, b) {
        return a != a ? b == b : a !== b;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash$2(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash$2(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { stylesheet } = info;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                info.rules = {};
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    function getAllContexts() {
        return get_current_component().$$.context;
    }
    function hasContext(key) {
        return get_current_component().$$.context.has(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.46.3' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }
    /**
     * Base class to create strongly typed Svelte components.
     * This only exists for typing purposes and should be used in `.d.ts` files.
     *
     * ### Example:
     *
     * You have component library on npm called `component-library`, from which
     * you export a component called `MyComponent`. For Svelte+TypeScript users,
     * you want to provide typings. Therefore you create a `index.d.ts`:
     * ```ts
     * import { SvelteComponentTyped } from "svelte";
     * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
     * ```
     * Typing this makes it possible for IDEs like VS Code with the Svelte extension
     * to provide intellisense and to use the component like this in a Svelte file
     * with TypeScript:
     * ```svelte
     * <script lang="ts">
     * 	import { MyComponent } from "component-library";
     * </script>
     * <MyComponent foo={'bar'} />
     * ```
     *
     * #### Why not make this part of `SvelteComponent(Dev)`?
     * Because
     * ```ts
     * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
     * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
     * ```
     * will throw a type error, so we need to separate the more strictly typed class.
     */
    class SvelteComponentTyped extends SvelteComponentDev {
        constructor(options) {
            super(options);
        }
    }

    var svelte = /*#__PURE__*/Object.freeze({
        __proto__: null,
        SvelteComponent: SvelteComponentDev,
        SvelteComponentTyped: SvelteComponentTyped,
        afterUpdate: afterUpdate,
        beforeUpdate: beforeUpdate,
        createEventDispatcher: createEventDispatcher,
        getAllContexts: getAllContexts,
        getContext: getContext,
        hasContext: hasContext,
        onDestroy: onDestroy,
        onMount: onMount,
        setContext: setContext,
        tick: tick
    });

    function sineOut(t) {
        return Math.sin((t * Math.PI) / 2);
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }

    /* node_modules\svelte-simple-modal\src\Modal.svelte generated by Svelte v3.46.3 */

    const { Object: Object_1$2, window: window_1$1 } = globals;
    const file$I = "node_modules\\svelte-simple-modal\\src\\Modal.svelte";

    // (396:0) {#if Component}
    function create_if_block$m(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let t;
    	let div0;
    	let switch_instance;
    	let div0_class_value;
    	let div1_class_value;
    	let div1_aria_label_value;
    	let div1_aria_labelledby_value;
    	let div1_transition;
    	let div2_class_value;
    	let div3_class_value;
    	let div3_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*state*/ ctx[1].closeButton && create_if_block_1$c(ctx);
    	var switch_value = /*Component*/ ctx[2];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div0, "class", div0_class_value = "" + (null_to_empty(/*state*/ ctx[1].classContent) + " svelte-g4wg3a"));
    			attr_dev(div0, "style", /*cssContent*/ ctx[9]);
    			toggle_class(div0, "content", !/*unstyled*/ ctx[0]);
    			add_location(div0, file$I, 439, 8, 10998);
    			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*state*/ ctx[1].classWindow) + " svelte-g4wg3a"));
    			attr_dev(div1, "role", "dialog");
    			attr_dev(div1, "aria-modal", "true");

    			attr_dev(div1, "aria-label", div1_aria_label_value = /*state*/ ctx[1].ariaLabelledBy
    			? null
    			: /*state*/ ctx[1].ariaLabel || null);

    			attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value = /*state*/ ctx[1].ariaLabelledBy || null);
    			attr_dev(div1, "style", /*cssWindow*/ ctx[8]);
    			toggle_class(div1, "window", !/*unstyled*/ ctx[0]);
    			add_location(div1, file$I, 411, 6, 10051);
    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(/*state*/ ctx[1].classWindowWrap) + " svelte-g4wg3a"));
    			attr_dev(div2, "style", /*cssWindowWrap*/ ctx[7]);
    			toggle_class(div2, "wrap", !/*unstyled*/ ctx[0]);
    			add_location(div2, file$I, 405, 4, 9918);
    			attr_dev(div3, "class", div3_class_value = "" + (null_to_empty(/*state*/ ctx[1].classBg) + " svelte-g4wg3a"));
    			attr_dev(div3, "style", /*cssBg*/ ctx[6]);
    			toggle_class(div3, "bg", !/*unstyled*/ ctx[0]);
    			add_location(div3, file$I, 396, 2, 9672);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			/*div1_binding*/ ctx[48](div1);
    			/*div2_binding*/ ctx[49](div2);
    			/*div3_binding*/ ctx[50](div3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						div1,
    						"introstart",
    						function () {
    							if (is_function(/*onOpen*/ ctx[13])) /*onOpen*/ ctx[13].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"outrostart",
    						function () {
    							if (is_function(/*onClose*/ ctx[14])) /*onClose*/ ctx[14].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"introend",
    						function () {
    							if (is_function(/*onOpened*/ ctx[15])) /*onOpened*/ ctx[15].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"outroend",
    						function () {
    							if (is_function(/*onClosed*/ ctx[16])) /*onClosed*/ ctx[16].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(div3, "mousedown", /*handleOuterMousedown*/ ctx[20], false, false, false),
    					listen_dev(div3, "mouseup", /*handleOuterMouseup*/ ctx[21], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*state*/ ctx[1].closeButton) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*state*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (switch_value !== (switch_value = /*Component*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*state*/ ctx[1].classContent) + " svelte-g4wg3a"))) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (!current || dirty[0] & /*cssContent*/ 512) {
    				attr_dev(div0, "style", /*cssContent*/ ctx[9]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(div0, "content", !/*unstyled*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*state*/ ctx[1].classWindow) + " svelte-g4wg3a"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div1_aria_label_value !== (div1_aria_label_value = /*state*/ ctx[1].ariaLabelledBy
    			? null
    			: /*state*/ ctx[1].ariaLabel || null)) {
    				attr_dev(div1, "aria-label", div1_aria_label_value);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = /*state*/ ctx[1].ariaLabelledBy || null)) {
    				attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value);
    			}

    			if (!current || dirty[0] & /*cssWindow*/ 256) {
    				attr_dev(div1, "style", /*cssWindow*/ ctx[8]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(div1, "window", !/*unstyled*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*state*/ ctx[1].classWindowWrap) + " svelte-g4wg3a"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}

    			if (!current || dirty[0] & /*cssWindowWrap*/ 128) {
    				attr_dev(div2, "style", /*cssWindowWrap*/ ctx[7]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(div2, "wrap", !/*unstyled*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*state*/ 2 && div3_class_value !== (div3_class_value = "" + (null_to_empty(/*state*/ ctx[1].classBg) + " svelte-g4wg3a"))) {
    				attr_dev(div3, "class", div3_class_value);
    			}

    			if (!current || dirty[0] & /*cssBg*/ 64) {
    				attr_dev(div3, "style", /*cssBg*/ ctx[6]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(div3, "bg", !/*unstyled*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[12], /*state*/ ctx[1].transitionWindowProps, true);
    				div1_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[11], /*state*/ ctx[1].transitionBgProps, true);
    				div3_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, /*currentTransitionWindow*/ ctx[12], /*state*/ ctx[1].transitionWindowProps, false);
    			div1_transition.run(0);
    			if (!div3_transition) div3_transition = create_bidirectional_transition(div3, /*currentTransitionBg*/ ctx[11], /*state*/ ctx[1].transitionBgProps, false);
    			div3_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			if (switch_instance) destroy_component(switch_instance);
    			/*div1_binding*/ ctx[48](null);
    			if (detaching && div1_transition) div1_transition.end();
    			/*div2_binding*/ ctx[49](null);
    			/*div3_binding*/ ctx[50](null);
    			if (detaching && div3_transition) div3_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(396:0) {#if Component}",
    		ctx
    	});

    	return block;
    }

    // (427:8) {#if state.closeButton}
    function create_if_block_1$c(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$4, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*state*/ 2) show_if = null;
    		if (show_if == null) show_if = !!/*isFunction*/ ctx[17](/*state*/ ctx[1].closeButton);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(427:8) {#if state.closeButton}",
    		ctx
    	});

    	return block;
    }

    // (430:10) {:else}
    function create_else_block$9(ctx) {
    	let button;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*state*/ ctx[1].classCloseButton) + " svelte-g4wg3a"));
    			attr_dev(button, "aria-label", "Close modal");
    			attr_dev(button, "style", /*cssCloseButton*/ ctx[10]);
    			toggle_class(button, "close", !/*unstyled*/ ctx[0]);
    			add_location(button, file$I, 430, 12, 10747);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*close*/ ctx[18], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*state*/ 2 && button_class_value !== (button_class_value = "" + (null_to_empty(/*state*/ ctx[1].classCloseButton) + " svelte-g4wg3a"))) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty[0] & /*cssCloseButton*/ 1024) {
    				attr_dev(button, "style", /*cssCloseButton*/ ctx[10]);
    			}

    			if (dirty[0] & /*state, unstyled*/ 3) {
    				toggle_class(button, "close", !/*unstyled*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(430:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (428:10) {#if isFunction(state.closeButton)}
    function create_if_block_2$4(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*state*/ ctx[1].closeButton;

    	function switch_props(ctx) {
    		return {
    			props: { onClose: /*close*/ ctx[18] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*state*/ ctx[1].closeButton)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(428:10) {#if isFunction(state.closeButton)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*Component*/ ctx[2] && create_if_block$m(ctx);
    	const default_slot_template = /*#slots*/ ctx[47].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[46], null);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window_1$1, "keydown", /*handleKeydown*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*Component*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*Component*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[46],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[46], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function bind(Component, props = {}) {
    	return function ModalComponent(options) {
    		return new Component({
    				...options,
    				props: { ...props, ...options.props }
    			});
    	};
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modal', slots, ['default']);
    	const dispatch = createEventDispatcher();
    	const baseSetContext = setContext;
    	let { show = null } = $$props;
    	let { key = 'simple-modal' } = $$props;
    	let { ariaLabel = null } = $$props;
    	let { ariaLabelledBy = null } = $$props;
    	let { closeButton = true } = $$props;
    	let { closeOnEsc = true } = $$props;
    	let { closeOnOuterClick = true } = $$props;
    	let { styleBg = {} } = $$props;
    	let { styleWindowWrap = {} } = $$props;
    	let { styleWindow = {} } = $$props;
    	let { styleContent = {} } = $$props;
    	let { styleCloseButton = {} } = $$props;
    	let { classBg = null } = $$props;
    	let { classWindowWrap = null } = $$props;
    	let { classWindow = null } = $$props;
    	let { classContent = null } = $$props;
    	let { classCloseButton = null } = $$props;
    	let { unstyled = false } = $$props;
    	let { setContext: setContext$1 = baseSetContext } = $$props;
    	let { transitionBg = fade } = $$props;
    	let { transitionBgProps = { duration: 250 } } = $$props;
    	let { transitionWindow = transitionBg } = $$props;
    	let { transitionWindowProps = transitionBgProps } = $$props;
    	let { disableFocusTrap = false } = $$props;

    	const defaultState = {
    		ariaLabel,
    		ariaLabelledBy,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		classBg,
    		classWindowWrap,
    		classWindow,
    		classContent,
    		classCloseButton,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		disableFocusTrap,
    		unstyled
    	};

    	let state = { ...defaultState };
    	let Component = null;
    	let background;
    	let wrap;
    	let modalWindow;
    	let scrollY;
    	let cssBg;
    	let cssWindowWrap;
    	let cssWindow;
    	let cssContent;
    	let cssCloseButton;
    	let currentTransitionBg;
    	let currentTransitionWindow;
    	let prevBodyPosition;
    	let prevBodyOverflow;
    	let prevBodyWidth;
    	let outerClickTarget;
    	const camelCaseToDash = str => str.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();

    	const toCssString = props => props
    	? Object.keys(props).reduce((str, key) => `${str}; ${camelCaseToDash(key)}: ${props[key]}`, '')
    	: '';

    	const isFunction = f => !!(f && f.constructor && f.call && f.apply);

    	const updateStyleTransition = () => {
    		$$invalidate(6, cssBg = toCssString(Object.assign(
    			{},
    			{
    				width: window.innerWidth,
    				height: window.innerHeight
    			},
    			state.styleBg
    		)));

    		$$invalidate(7, cssWindowWrap = toCssString(state.styleWindowWrap));
    		$$invalidate(8, cssWindow = toCssString(state.styleWindow));
    		$$invalidate(9, cssContent = toCssString(state.styleContent));
    		$$invalidate(10, cssCloseButton = toCssString(state.styleCloseButton));
    		$$invalidate(11, currentTransitionBg = state.transitionBg);
    		$$invalidate(12, currentTransitionWindow = state.transitionWindow);
    	};

    	const toVoid = () => {
    		
    	};

    	let onOpen = toVoid;
    	let onClose = toVoid;
    	let onOpened = toVoid;
    	let onClosed = toVoid;

    	const open = (NewComponent, newProps = {}, options = {}, callback = {}) => {
    		$$invalidate(2, Component = bind(NewComponent, newProps));
    		$$invalidate(1, state = { ...defaultState, ...options });
    		updateStyleTransition();
    		disableScroll();

    		$$invalidate(13, onOpen = event => {
    			if (callback.onOpen) callback.onOpen(event);

    			/**
     * The open event is fired right before the modal opens
     * @event {void} open
     */
    			dispatch('open');

    			/**
     * The opening event is fired right before the modal opens
     * @event {void} opening
     * @deprecated Listen to the `open` event instead
     */
    			dispatch('opening'); // Deprecated. Do not use!
    		});

    		$$invalidate(14, onClose = event => {
    			if (callback.onClose) callback.onClose(event);

    			/**
     * The close event is fired right before the modal closes
     * @event {void} close
     */
    			dispatch('close');

    			/**
     * The closing event is fired right before the modal closes
     * @event {void} closing
     * @deprecated Listen to the `close` event instead
     */
    			dispatch('closing'); // Deprecated. Do not use!
    		});

    		$$invalidate(15, onOpened = event => {
    			if (callback.onOpened) callback.onOpened(event);

    			/**
     * The opened event is fired after the modal's opening transition
     * @event {void} opened
     */
    			dispatch('opened');
    		});

    		$$invalidate(16, onClosed = event => {
    			if (callback.onClosed) callback.onClosed(event);

    			/**
     * The closed event is fired after the modal's closing transition
     * @event {void} closed
     */
    			dispatch('closed');
    		});
    	};

    	const close = (callback = {}) => {
    		if (!Component) return;
    		$$invalidate(14, onClose = callback.onClose || onClose);
    		$$invalidate(16, onClosed = callback.onClosed || onClosed);
    		$$invalidate(2, Component = null);
    		enableScroll();
    	};

    	const handleKeydown = event => {
    		if (state.closeOnEsc && Component && event.key === 'Escape') {
    			event.preventDefault();
    			close();
    		}

    		if (Component && event.key === 'Tab' && !state.disableFocusTrap) {
    			// trap focus
    			const nodes = modalWindow.querySelectorAll('*');

    			const tabbable = Array.from(nodes).filter(node => node.tabIndex >= 0);
    			let index = tabbable.indexOf(document.activeElement);
    			if (index === -1 && event.shiftKey) index = 0;
    			index += tabbable.length + (event.shiftKey ? -1 : 1);
    			index %= tabbable.length;
    			tabbable[index].focus();
    			event.preventDefault();
    		}
    	};

    	const handleOuterMousedown = event => {
    		if (state.closeOnOuterClick && (event.target === background || event.target === wrap)) outerClickTarget = event.target;
    	};

    	const handleOuterMouseup = event => {
    		if (state.closeOnOuterClick && event.target === outerClickTarget) {
    			event.preventDefault();
    			close();
    		}
    	};

    	const disableScroll = () => {
    		scrollY = window.scrollY;
    		prevBodyPosition = document.body.style.position;
    		prevBodyOverflow = document.body.style.overflow;
    		prevBodyWidth = document.body.style.width;
    		document.body.style.position = 'fixed';
    		document.body.style.top = `-${scrollY}px`;
    		document.body.style.overflow = 'hidden';
    		document.body.style.width = '100%';
    	};

    	const enableScroll = () => {
    		document.body.style.position = prevBodyPosition || '';
    		document.body.style.top = '';
    		document.body.style.overflow = prevBodyOverflow || '';
    		document.body.style.width = prevBodyWidth || '';
    		window.scrollTo(0, scrollY);
    	};

    	setContext$1(key, { open, close });
    	let isMounted = false;

    	onDestroy(() => {
    		if (isMounted) close();
    	});

    	onMount(() => {
    		$$invalidate(45, isMounted = true);
    	});

    	const writable_props = [
    		'show',
    		'key',
    		'ariaLabel',
    		'ariaLabelledBy',
    		'closeButton',
    		'closeOnEsc',
    		'closeOnOuterClick',
    		'styleBg',
    		'styleWindowWrap',
    		'styleWindow',
    		'styleContent',
    		'styleCloseButton',
    		'classBg',
    		'classWindowWrap',
    		'classWindow',
    		'classContent',
    		'classCloseButton',
    		'unstyled',
    		'setContext',
    		'transitionBg',
    		'transitionBgProps',
    		'transitionWindow',
    		'transitionWindowProps',
    		'disableFocusTrap'
    	];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			modalWindow = $$value;
    			$$invalidate(5, modalWindow);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			wrap = $$value;
    			$$invalidate(4, wrap);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			background = $$value;
    			$$invalidate(3, background);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('show' in $$props) $$invalidate(22, show = $$props.show);
    		if ('key' in $$props) $$invalidate(23, key = $$props.key);
    		if ('ariaLabel' in $$props) $$invalidate(24, ariaLabel = $$props.ariaLabel);
    		if ('ariaLabelledBy' in $$props) $$invalidate(25, ariaLabelledBy = $$props.ariaLabelledBy);
    		if ('closeButton' in $$props) $$invalidate(26, closeButton = $$props.closeButton);
    		if ('closeOnEsc' in $$props) $$invalidate(27, closeOnEsc = $$props.closeOnEsc);
    		if ('closeOnOuterClick' in $$props) $$invalidate(28, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ('styleBg' in $$props) $$invalidate(29, styleBg = $$props.styleBg);
    		if ('styleWindowWrap' in $$props) $$invalidate(30, styleWindowWrap = $$props.styleWindowWrap);
    		if ('styleWindow' in $$props) $$invalidate(31, styleWindow = $$props.styleWindow);
    		if ('styleContent' in $$props) $$invalidate(32, styleContent = $$props.styleContent);
    		if ('styleCloseButton' in $$props) $$invalidate(33, styleCloseButton = $$props.styleCloseButton);
    		if ('classBg' in $$props) $$invalidate(34, classBg = $$props.classBg);
    		if ('classWindowWrap' in $$props) $$invalidate(35, classWindowWrap = $$props.classWindowWrap);
    		if ('classWindow' in $$props) $$invalidate(36, classWindow = $$props.classWindow);
    		if ('classContent' in $$props) $$invalidate(37, classContent = $$props.classContent);
    		if ('classCloseButton' in $$props) $$invalidate(38, classCloseButton = $$props.classCloseButton);
    		if ('unstyled' in $$props) $$invalidate(0, unstyled = $$props.unstyled);
    		if ('setContext' in $$props) $$invalidate(39, setContext$1 = $$props.setContext);
    		if ('transitionBg' in $$props) $$invalidate(40, transitionBg = $$props.transitionBg);
    		if ('transitionBgProps' in $$props) $$invalidate(41, transitionBgProps = $$props.transitionBgProps);
    		if ('transitionWindow' in $$props) $$invalidate(42, transitionWindow = $$props.transitionWindow);
    		if ('transitionWindowProps' in $$props) $$invalidate(43, transitionWindowProps = $$props.transitionWindowProps);
    		if ('disableFocusTrap' in $$props) $$invalidate(44, disableFocusTrap = $$props.disableFocusTrap);
    		if ('$$scope' in $$props) $$invalidate(46, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		bind,
    		svelte,
    		fade,
    		createEventDispatcher,
    		dispatch,
    		baseSetContext,
    		show,
    		key,
    		ariaLabel,
    		ariaLabelledBy,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		classBg,
    		classWindowWrap,
    		classWindow,
    		classContent,
    		classCloseButton,
    		unstyled,
    		setContext: setContext$1,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		disableFocusTrap,
    		defaultState,
    		state,
    		Component,
    		background,
    		wrap,
    		modalWindow,
    		scrollY,
    		cssBg,
    		cssWindowWrap,
    		cssWindow,
    		cssContent,
    		cssCloseButton,
    		currentTransitionBg,
    		currentTransitionWindow,
    		prevBodyPosition,
    		prevBodyOverflow,
    		prevBodyWidth,
    		outerClickTarget,
    		camelCaseToDash,
    		toCssString,
    		isFunction,
    		updateStyleTransition,
    		toVoid,
    		onOpen,
    		onClose,
    		onOpened,
    		onClosed,
    		open,
    		close,
    		handleKeydown,
    		handleOuterMousedown,
    		handleOuterMouseup,
    		disableScroll,
    		enableScroll,
    		isMounted
    	});

    	$$self.$inject_state = $$props => {
    		if ('show' in $$props) $$invalidate(22, show = $$props.show);
    		if ('key' in $$props) $$invalidate(23, key = $$props.key);
    		if ('ariaLabel' in $$props) $$invalidate(24, ariaLabel = $$props.ariaLabel);
    		if ('ariaLabelledBy' in $$props) $$invalidate(25, ariaLabelledBy = $$props.ariaLabelledBy);
    		if ('closeButton' in $$props) $$invalidate(26, closeButton = $$props.closeButton);
    		if ('closeOnEsc' in $$props) $$invalidate(27, closeOnEsc = $$props.closeOnEsc);
    		if ('closeOnOuterClick' in $$props) $$invalidate(28, closeOnOuterClick = $$props.closeOnOuterClick);
    		if ('styleBg' in $$props) $$invalidate(29, styleBg = $$props.styleBg);
    		if ('styleWindowWrap' in $$props) $$invalidate(30, styleWindowWrap = $$props.styleWindowWrap);
    		if ('styleWindow' in $$props) $$invalidate(31, styleWindow = $$props.styleWindow);
    		if ('styleContent' in $$props) $$invalidate(32, styleContent = $$props.styleContent);
    		if ('styleCloseButton' in $$props) $$invalidate(33, styleCloseButton = $$props.styleCloseButton);
    		if ('classBg' in $$props) $$invalidate(34, classBg = $$props.classBg);
    		if ('classWindowWrap' in $$props) $$invalidate(35, classWindowWrap = $$props.classWindowWrap);
    		if ('classWindow' in $$props) $$invalidate(36, classWindow = $$props.classWindow);
    		if ('classContent' in $$props) $$invalidate(37, classContent = $$props.classContent);
    		if ('classCloseButton' in $$props) $$invalidate(38, classCloseButton = $$props.classCloseButton);
    		if ('unstyled' in $$props) $$invalidate(0, unstyled = $$props.unstyled);
    		if ('setContext' in $$props) $$invalidate(39, setContext$1 = $$props.setContext);
    		if ('transitionBg' in $$props) $$invalidate(40, transitionBg = $$props.transitionBg);
    		if ('transitionBgProps' in $$props) $$invalidate(41, transitionBgProps = $$props.transitionBgProps);
    		if ('transitionWindow' in $$props) $$invalidate(42, transitionWindow = $$props.transitionWindow);
    		if ('transitionWindowProps' in $$props) $$invalidate(43, transitionWindowProps = $$props.transitionWindowProps);
    		if ('disableFocusTrap' in $$props) $$invalidate(44, disableFocusTrap = $$props.disableFocusTrap);
    		if ('state' in $$props) $$invalidate(1, state = $$props.state);
    		if ('Component' in $$props) $$invalidate(2, Component = $$props.Component);
    		if ('background' in $$props) $$invalidate(3, background = $$props.background);
    		if ('wrap' in $$props) $$invalidate(4, wrap = $$props.wrap);
    		if ('modalWindow' in $$props) $$invalidate(5, modalWindow = $$props.modalWindow);
    		if ('scrollY' in $$props) scrollY = $$props.scrollY;
    		if ('cssBg' in $$props) $$invalidate(6, cssBg = $$props.cssBg);
    		if ('cssWindowWrap' in $$props) $$invalidate(7, cssWindowWrap = $$props.cssWindowWrap);
    		if ('cssWindow' in $$props) $$invalidate(8, cssWindow = $$props.cssWindow);
    		if ('cssContent' in $$props) $$invalidate(9, cssContent = $$props.cssContent);
    		if ('cssCloseButton' in $$props) $$invalidate(10, cssCloseButton = $$props.cssCloseButton);
    		if ('currentTransitionBg' in $$props) $$invalidate(11, currentTransitionBg = $$props.currentTransitionBg);
    		if ('currentTransitionWindow' in $$props) $$invalidate(12, currentTransitionWindow = $$props.currentTransitionWindow);
    		if ('prevBodyPosition' in $$props) prevBodyPosition = $$props.prevBodyPosition;
    		if ('prevBodyOverflow' in $$props) prevBodyOverflow = $$props.prevBodyOverflow;
    		if ('prevBodyWidth' in $$props) prevBodyWidth = $$props.prevBodyWidth;
    		if ('outerClickTarget' in $$props) outerClickTarget = $$props.outerClickTarget;
    		if ('onOpen' in $$props) $$invalidate(13, onOpen = $$props.onOpen);
    		if ('onClose' in $$props) $$invalidate(14, onClose = $$props.onClose);
    		if ('onOpened' in $$props) $$invalidate(15, onOpened = $$props.onOpened);
    		if ('onClosed' in $$props) $$invalidate(16, onClosed = $$props.onClosed);
    		if ('isMounted' in $$props) $$invalidate(45, isMounted = $$props.isMounted);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*show*/ 4194304 | $$self.$$.dirty[1] & /*isMounted*/ 16384) {
    			{
    				if (isMounted) {
    					if (isFunction(show)) {
    						open(show);
    					} else {
    						close();
    					}
    				}
    			}
    		}
    	};

    	return [
    		unstyled,
    		state,
    		Component,
    		background,
    		wrap,
    		modalWindow,
    		cssBg,
    		cssWindowWrap,
    		cssWindow,
    		cssContent,
    		cssCloseButton,
    		currentTransitionBg,
    		currentTransitionWindow,
    		onOpen,
    		onClose,
    		onOpened,
    		onClosed,
    		isFunction,
    		close,
    		handleKeydown,
    		handleOuterMousedown,
    		handleOuterMouseup,
    		show,
    		key,
    		ariaLabel,
    		ariaLabelledBy,
    		closeButton,
    		closeOnEsc,
    		closeOnOuterClick,
    		styleBg,
    		styleWindowWrap,
    		styleWindow,
    		styleContent,
    		styleCloseButton,
    		classBg,
    		classWindowWrap,
    		classWindow,
    		classContent,
    		classCloseButton,
    		setContext$1,
    		transitionBg,
    		transitionBgProps,
    		transitionWindow,
    		transitionWindowProps,
    		disableFocusTrap,
    		isMounted,
    		$$scope,
    		slots,
    		div1_binding,
    		div2_binding,
    		div3_binding
    	];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$M,
    			create_fragment$M,
    			safe_not_equal,
    			{
    				show: 22,
    				key: 23,
    				ariaLabel: 24,
    				ariaLabelledBy: 25,
    				closeButton: 26,
    				closeOnEsc: 27,
    				closeOnOuterClick: 28,
    				styleBg: 29,
    				styleWindowWrap: 30,
    				styleWindow: 31,
    				styleContent: 32,
    				styleCloseButton: 33,
    				classBg: 34,
    				classWindowWrap: 35,
    				classWindow: 36,
    				classContent: 37,
    				classCloseButton: 38,
    				unstyled: 0,
    				setContext: 39,
    				transitionBg: 40,
    				transitionBgProps: 41,
    				transitionWindow: 42,
    				transitionWindowProps: 43,
    				disableFocusTrap: 44
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get show() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaLabel() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabel(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ariaLabelledBy() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabelledBy(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeButton() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeButton(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnEsc() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnEsc(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeOnOuterClick() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeOnOuterClick(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleWindowWrap() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleWindowWrap(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleContent() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleContent(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get styleCloseButton() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set styleCloseButton(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classWindowWrap() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classWindowWrap(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classContent() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classContent(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classCloseButton() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classCloseButton(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get unstyled() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set unstyled(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setContext() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set setContext(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionBg() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionBg(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionBgProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionBgProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionWindow() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionWindow(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionWindowProps() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionWindowProps(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disableFocusTrap() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disableFocusTrap(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Get element position (with support old browsers)
     * @param {Element} element
     * @returns {{top: number, left: number}}
     */
    function getElementPosition(element) {
        const box = element.getBoundingClientRect();

        const { body, documentElement } = document;

        const scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;
        const scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;

        const clientTop = documentElement.clientTop || body.clientTop || 0;
        const clientLeft = documentElement.clientLeft || body.clientLeft || 0;

        const top = box.top + scrollTop - clientTop;
        const left = box.left + scrollLeft - clientLeft;

        return { top, left };
    }

    /**
     * Universal alternative to Object.assign()
     * @param {Object} destination
     * @param {Object} source
     * @returns {Object}
     */
    function extendObject(destination, source) {
        if (destination && source) {
            for (let key in source) {
                if (source.hasOwnProperty(key)) {
                    destination[key] = source[key];
                }
            }
        }

        return destination;
    }

    /**
     * @param target
     * @param type
     * @param listener
     * @param options
     */
    function on$1(target, type, listener, options = false) {
        target.addEventListener(type, listener, options);
    }

    /**
     * @param target
     * @param type
     * @param listener
     * @param options
     */
    function off(target, type, listener, options = false) {
        target.removeEventListener(type, listener, options);
    }

    function isTouch() {
        return 'ontouchstart' in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    }

    function eventClientX(event) {
        return event.type === 'wheel' ||
        event.type === 'mousedown' ||
        event.type === 'mousemove' ||
        event.type === 'mouseup' ? event.clientX : event.changedTouches[0].clientX;
    }

    function eventClientY(event) {
        return event.type === 'wheel' ||
        event.type === 'mousedown' ||
        event.type === 'mousemove' ||
        event.type === 'mouseup' ? event.clientY : event.changedTouches[0].clientY;
    }

    /**
     * @class DragScrollable
     * @param {Object} windowObject
     * @param {Object} contentObject
     * @param {Object} options
     * @constructor
     */
    function DragScrollable(windowObject, contentObject, options = {}) {
        this._dropHandler = this._dropHandler.bind(this);
        this._grabHandler = this._grabHandler.bind(this);
        this._moveHandler = this._moveHandler.bind(this);

        this.options = extendObject({
            // smooth extinction moving element after set loose
            smoothExtinction: false,
            // callback triggered when grabbing an element
            onGrab: null,
            // callback triggered when moving an element
            onMove: null,
            // callback triggered when dropping an element
            onDrop: null
        }, options);

        // check if we're using a touch screen
        this.isTouch = isTouch();
        // switch to touch events if using a touch screen
        this.events = this.isTouch ?
            { grab: 'touchstart', move: 'touchmove', drop: 'touchend' } :
            { grab: 'mousedown', move: 'mousemove', drop: 'mouseup' };
        // if using touch screen tells the browser that the default action will not be undone
        this.events.options = this.isTouch ? { passive: true } : false;

        this.window = windowObject;
        this.content = contentObject;

        on$1(this.content.$element, this.events.grab, this._grabHandler, this.events.options);
    }

    DragScrollable.prototype = {
        constructor: DragScrollable,
        window: null,
        content: null,
        isTouch: false,
        isGrab: false,
        events: null,
        moveTimer: null,
        options: {},
        coordinates: null,
        speed: null,
        _grabHandler(event) {
            // if touch started (only one finger) or pressed left mouse button
            if ((this.isTouch && event.touches.length === 1) || event.buttons === 1) {
                if (!this.isTouch) event.preventDefault();

                this.isGrab = true;
                this.coordinates = { left: eventClientX(event), top: eventClientY(event) };
                this.speed = { x: 0, y: 0 };

                on$1(document, this.events.drop, this._dropHandler, this.events.options);
                on$1(document, this.events.move, this._moveHandler, this.events.options);

                if (typeof this.options.onGrab === 'function') {
                    this.options.onGrab();
                }
            }
        },
        _dropHandler(event) {
            if (!this.isTouch) event.preventDefault();

            this.isGrab = false;

            // if (this.options.smoothExtinction) {
            //     _moveExtinction.call(this, 'scrollLeft', numberExtinction(this.speed.x));
            //     _moveExtinction.call(this, 'scrollTop', numberExtinction(this.speed.y));
            // }

            off(document, this.events.drop, this._dropHandler);
            off(document, this.events.move, this._moveHandler);

            if (typeof this.options.onDrop === 'function') {
                this.options.onDrop();
            }
        },
        _moveHandler(event) {
            if (!this.isTouch) event.preventDefault();

            const { window, content, speed, coordinates, options } = this;

            // speed of change of the coordinate of the mouse cursor along the X/Y axis
            speed.x = eventClientX(event) - coordinates.left;
            speed.y = eventClientY(event) - coordinates.top;

            clearTimeout(this.moveTimer);

            // reset speed data if cursor stops
            this.moveTimer = setTimeout(() => {
                speed.x = 0;
                speed.y = 0;
            }, 50);

            const contentNewLeft = content.currentLeft + speed.x;
            const contentNewTop = content.currentTop + speed.y;

            let maxAvailableLeft = (content.currentWidth - window.originalWidth) / 2 + content.correctX;
            let maxAvailableTop = (content.currentHeight - window.originalHeight) / 2 + content.correctY;

            // if we do not go beyond the permissible boundaries of the window
            if (Math.abs(contentNewLeft) <= maxAvailableLeft) content.currentLeft = contentNewLeft;

            // if we do not go beyond the permissible boundaries of the window
            if (Math.abs(contentNewTop) <= maxAvailableTop) content.currentTop = contentNewTop;

            _transform(content.$element, {
                left: content.currentLeft,
                top: content.currentTop,
                scale: content.currentScale
            });

            coordinates.left = eventClientX(event);
            coordinates.top = eventClientY(event);

            if (typeof options.onMove === 'function') {
                options.onMove();
            }
        },
        destroy() {
            off(this.content.$element, this.events.grab, this._grabHandler, this.events.options);

            for (let key in this) {
                if (this.hasOwnProperty(key)) {
                    this[key] = null;
                }
            }
        }
    };

    function _transform($element, { left, top, scale }) {
        $element.style.transform = `translate3d(${ left }px, ${ top }px, 0px) scale(${ scale })`;
    }

    /**
     * @class WZoom
     * @param {string} selector
     * @param {Object} options
     * @constructor
     */

    function WZoom(selector, options = {}) {
        this._init = this._init.bind(this);
        this._prepare = this._prepare.bind(this);
        this._computeNewScale = this._computeNewScale.bind(this);
        this._computeNewPosition = this._computeNewPosition.bind(this);
        this._transform = this._transform.bind(this);

        this._wheelHandler = _wheelHandler.bind(this);
        this._downHandler = _downHandler.bind(this);
        this._upHandler = _upHandler.bind(this);

        const defaults = {
            // type content: `image` - only one image, `html` - any HTML content
            type: 'image',
            // for type `image` computed auto (if width set null), for type `html` need set real html content width, else computed auto
            width: null,
            // for type `image` computed auto (if height set null), for type `html` need set real html content height, else computed auto
            height: null,
            // drag scrollable content
            dragScrollable: true,
            // options for the DragScrollable module
            dragScrollableOptions: {},
            // minimum allowed proportion of scale
            minScale: null,
            // maximum allowed proportion of scale
            maxScale: 1,
            // content resizing speed
            speed: 50,
            // zoom to maximum (minimum) size on click
            zoomOnClick: true,
            // if is true, then when the source image changes, the plugin will automatically restart init function (used with type = image)
            // attention: if false, it will work correctly only if the images are of the same size
            watchImageChange: true
        };

        this.content.$element = typeof(selector) === 'string' ? document.querySelector(selector) : selector;

        // check if we're using a touch screen
        this.isTouch = isTouch();
        // switch to touch events if using a touch screen
        this.events = this.isTouch ? { down: 'touchstart', up: 'touchend' } : { down: 'mousedown', up: 'mouseup' };
        // if using touch screen tells the browser that the default action will not be undone
        this.events.options = this.isTouch ? { passive: true } : false;

        if (this.content.$element) {
            this.options = extendObject(defaults, options);

            if (this.options.minScale && this.options.minScale >= this.options.maxScale) {
                this.options.minScale = null;
            }

            // for window take just the parent
            this.window.$element = this.content.$element.parentNode;

            // console.log('this.window', this.window);

            if (this.options.type === 'image') {
                let initAlreadyDone = false;

                // if the `image` has already been loaded
                if (this.content.$element.complete) {
                    this._init();
                    initAlreadyDone = true;
                }

                if (!initAlreadyDone || this.options.watchImageChange === true) {
                    // even if the `image` has already been loaded (for "hotswap" of src support)
                    on$1(
                        this.content.$element, 'load', this._init,
                        // if watchImageChange == false listen add only until the first call
                        this.options.watchImageChange ? false : { once: true }
                    );
                }
            } else {
                this._init();
            }
        }
    }

    WZoom.prototype = {
        constructor: WZoom,
        isTouch: false,
        events: null,
        content: {},
        window: {},
        direction: 1,
        options: null,
        dragScrollable: null,
        // processing of the event "max / min zoom" begin only if there was really just a click
        // so as not to interfere with the DragScrollable module
        clickExpired: true,
        _init() {
            this._prepare();

            if (this.options.dragScrollable === true) {
                // this can happen if the src of this.content.$element (when type = image) is changed and repeat event load at image
                if (this.dragScrollable) {
                    this.dragScrollable.destroy();
                }

                this.dragScrollable = new DragScrollable(this.window, this.content, this.options.dragScrollableOptions);
            }

            on$1(this.content.$element, 'wheel', this._wheelHandler);

            if (this.options.zoomOnClick) {
                on$1(this.content.$element, this.events.down, this._downHandler, this.events.options);
                on$1(this.content.$element, this.events.up, this._upHandler, this.events.options);
            }
        },
        _prepare() {
            const windowPosition = getElementPosition(this.window.$element);

            // original window sizes and position
            this.window.originalWidth = this.window.$element.offsetWidth;
            this.window.originalHeight = this.window.$element.offsetHeight;
            this.window.positionLeft = windowPosition.left;
            this.window.positionTop = windowPosition.top;

            // original content sizes
            if (this.options.type === 'image') {
                this.content.originalWidth = this.options.width || this.content.$element.naturalWidth;
                this.content.originalHeight = this.options.height || this.content.$element.naturalHeight;
            } else {
                this.content.originalWidth = this.options.width || this.content.$element.offsetWidth;
                this.content.originalHeight = this.options.height || this.content.$element.offsetHeight;
            }

            // minScale && maxScale
            this.content.minScale = this.options.minScale || Math.min(this.window.originalWidth / this.content.originalWidth, this.window.originalHeight / this.content.originalHeight);
            this.content.maxScale = this.options.maxScale;

            // current content sizes and transform data
            this.content.currentWidth = this.content.originalWidth * this.content.minScale;
            this.content.currentHeight = this.content.originalHeight * this.content.minScale;
            this.content.currentLeft = 0;
            this.content.currentTop = 0;
            this.content.currentScale = this.content.minScale;

            // calculate indent-left and indent-top to of content from window borders
            this.content.correctX = Math.max(0, (this.window.originalWidth - this.content.currentWidth) / 2);
            this.content.correctY = Math.max(0, (this.window.originalHeight - this.content.currentHeight) / 2);

            this.content.$element.style.transform = `translate3d(0px, 0px, 0px) scale(${ this.content.minScale })`;

            if (typeof this.options.prepare === 'function') {
                this.options.prepare();
            }
        },
        _computeNewScale(delta) {
            this.direction = delta < 0 ? 1 : -1;

            const { minScale, maxScale, currentScale } = this.content;

            let contentNewScale = currentScale + (this.direction / this.options.speed);

            if (contentNewScale < minScale) {
                this.direction = 1;
            } else if (contentNewScale > maxScale) {
                this.direction = -1;
            }

            return contentNewScale < minScale ? minScale : (contentNewScale > maxScale ? maxScale : contentNewScale);
        },
        _computeNewPosition(contentNewScale, { x, y }) {
            const { window, content } = this;

            const contentNewWidth = content.originalWidth * contentNewScale;
            const contentNewHeight = content.originalHeight * contentNewScale;

            const { body, documentElement } = document;

            const scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;
            const scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;

            // calculate the parameters along the X axis
            const leftWindowShiftX = x + scrollLeft - window.positionLeft;
            const centerWindowShiftX = window.originalWidth / 2 - leftWindowShiftX;
            const centerContentShiftX = centerWindowShiftX + content.currentLeft;
            let contentNewLeft = centerContentShiftX * (contentNewWidth / content.currentWidth) - centerContentShiftX + content.currentLeft;

            // check that the content does not go beyond the X axis
            if (this.direction === -1 && (contentNewWidth - window.originalWidth) / 2 + content.correctX < Math.abs(contentNewLeft)) {
                const positive = contentNewLeft < 0 ? -1 : 1;
                contentNewLeft = ((contentNewWidth - window.originalWidth) / 2 + content.correctX) * positive;
            }

            // calculate the parameters along the Y axis
            const topWindowShiftY = y + scrollTop - window.positionTop;
            const centerWindowShiftY = window.originalHeight / 2 - topWindowShiftY;
            const centerContentShiftY = centerWindowShiftY + content.currentTop;
            let contentNewTop = centerContentShiftY * (contentNewHeight / content.currentHeight) - centerContentShiftY + content.currentTop;

            // check that the content does not go beyond the Y axis
            if (this.direction === -1 && (contentNewHeight - window.originalHeight) / 2 + content.correctY < Math.abs(contentNewTop)) {
                const positive = contentNewTop < 0 ? -1 : 1;
                contentNewTop = ((contentNewHeight - window.originalHeight) / 2 + content.correctY) * positive;
            }

            if (contentNewScale === this.content.minScale) {
                contentNewLeft = contentNewTop = 0;
            }

            const response = {
                currentLeft: content.currentLeft,
                newLeft: contentNewLeft,
                currentTop: content.currentTop,
                newTop: contentNewTop,
                currentScale: content.currentScale,
                newScale: contentNewScale
            };

            content.currentWidth = contentNewWidth;
            content.currentHeight = contentNewHeight;
            content.currentLeft = contentNewLeft;
            content.currentTop = contentNewTop;
            content.currentScale = contentNewScale;

            return response;
        },
        _transform({ currentLeft, newLeft, currentTop, newTop, currentScale, newScale }, iterations = 1) {
            this.content.$element.style.transform = `translate3d(${ newLeft }px, ${ newTop }px, 0px) scale(${ newScale })`;

            if (typeof this.options.rescale === 'function') {
                this.options.rescale();
            }
        },
        _zoom(direction) {
            const windowPosition = getElementPosition(this.window.$element);

            const { window } = this;
            const { body, documentElement } = document;

            const scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;
            const scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;

            this._transform(
                this._computeNewPosition(
                    this._computeNewScale(direction), {
                        x: windowPosition.left + (this.window.originalWidth / 2) - scrollLeft,
                        y: windowPosition.top + (this.window.originalHeight / 2) - scrollTop
                    }));
        },
        prepare() {
            this._prepare();
        },
        zoomUp() {
            this._zoom(-1);
        },
        zoomDown() {
            this._zoom(1);
        },
        destroy() {
            this.content.$element.style.transform = '';

            if (this.options.type === 'image') {
                off(this.content.$element, 'load', this._init);
            }

            off(this.window.$element, 'wheel', this._wheelHandler);
            off(this.content.$element, 'wheel', this._wheelHandler);

            if (this.options.zoomOnClick) {
                off(this.window.$element, this.events.down, this._downHandler, this.events.options);
                off(this.window.$element, this.events.up, this._upHandler, this.events.options);
            }

            if (this.dragScrollable) {
                this.dragScrollable.destroy();
            }

            for (let key in this) {
                if (this.hasOwnProperty(key)) {
                    this[key] = null;
                }
            }
        }
    };

    function _wheelHandler(event) {
        event.preventDefault();

        this._transform(
            this._computeNewPosition(
                this._computeNewScale(event.deltaY),
                { x: eventClientX(event), y: eventClientY(event) }
            )
        );
    }

    function _downHandler(event) {
        if ((this.isTouch && event.touches.length === 1) || event.buttons === 1) {
            this.clickExpired = false;
            setTimeout(() => this.clickExpired = true, 150);
        }
    }

    function _upHandler(event) {
        if (!this.clickExpired) {
            this._transform(
                this._computeNewPosition(
                    this.direction === 1 ? this.content.maxScale : this.content.minScale, {
                        x: eventClientX(event),
                        y: eventClientY(event)
                    }
                )
            );

            this.direction *= -1;
        }
    }

    /**
     * Create WZoom instance
     * @param {string} selector
     * @param {Object} [options]
     * @returns {WZoom}
     */
    WZoom.create = function (selector, options) {
        return new WZoom(selector, options);
    };

    // import Cookies from 'lib/cookies-js';

    // =========== RESIZE END EVENT ===============================
    (function() {
        var EVENT_KEY = 'resizeend',
            TIMEOUT = 200;
        var timer;

        function callResizeEnd() {
            var event = new window.CustomEvent(EVENT_KEY);
            window.dispatchEvent(event);
        }

        window.addEventListener('resize', () => {
            clearTimeout(timer);
            timer = setTimeout(callResizeEnd, TIMEOUT);
        });
    })();


    // =========== EXPOSE DOCUMENT WIDTH TO THE APP =================
    let docWidth = 0;
    const getDocWidth = () => docWidth;
    let docHeight = 0;
    const getDocHeight = () => docHeight;

    const refreshDocDimensions = () => {
        const w = window;
        const d = document;
        const e = d.documentElement;
        const g = d.getElementsByTagName('body')[0];
        docWidth = w.innerWidth || e.clientWidth || g.clientWidth;
        docHeight = w.innerHeight || e.clientHeight || g.clientHeight;
    };
    window.addEventListener('resizeend', refreshDocDimensions);
    refreshDocDimensions();

    /* src\components\icons\IconMagnify.svelte generated by Svelte v3.46.3 */

    const file$H = "src\\components\\icons\\IconMagnify.svelte";

    function create_fragment$L(ctx) {
    	let svg;
    	let circle;
    	let line0;
    	let line1;
    	let line2;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			line2 = svg_element("line");
    			attr_dev(circle, "cx", "11");
    			attr_dev(circle, "cy", "11");
    			attr_dev(circle, "r", "8");
    			add_location(circle, file$H, 2, 8, 143);
    			attr_dev(line0, "x1", "21");
    			attr_dev(line0, "y1", "21");
    			attr_dev(line0, "x2", "16.65");
    			attr_dev(line0, "y2", "16.65");
    			add_location(line0, file$H, 3, 17, 192);
    			attr_dev(line1, "x1", "11");
    			attr_dev(line1, "y1", "8");
    			attr_dev(line1, "x2", "11");
    			attr_dev(line1, "y2", "14");
    			add_location(line1, file$H, 4, 8, 253);
    			attr_dev(line2, "x1", "8");
    			attr_dev(line2, "y1", "11");
    			attr_dev(line2, "x2", "14");
    			attr_dev(line2, "y2", "11");
    			add_location(line2, file$H, 5, 8, 307);
    			attr_dev(svg, "stroke", "rgb(160,160,160)");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "stroke-width", "2");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "stroke-linecap", "round");
    			attr_dev(svg, "stroke-linejoin", "round");
    			add_location(svg, file$H, 0, 1, 1);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle);
    			append_dev(svg, line0);
    			append_dev(svg, line1);
    			append_dev(svg, line2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconMagnify', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconMagnify> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class IconMagnify extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconMagnify",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src\components\icons\IconDeMagnify.svelte generated by Svelte v3.46.3 */

    const file$G = "src\\components\\icons\\IconDeMagnify.svelte";

    function create_fragment$K(ctx) {
    	let svg;
    	let circle;
    	let line0;
    	let line1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			attr_dev(circle, "cx", "11");
    			attr_dev(circle, "cy", "11");
    			attr_dev(circle, "r", "8");
    			add_location(circle, file$G, 2, 8, 143);
    			attr_dev(line0, "x1", "21");
    			attr_dev(line0, "y1", "21");
    			attr_dev(line0, "x2", "16.65");
    			attr_dev(line0, "y2", "16.65");
    			add_location(line0, file$G, 3, 8, 192);
    			attr_dev(line1, "x1", "8");
    			attr_dev(line1, "y1", "11");
    			attr_dev(line1, "x2", "14");
    			attr_dev(line1, "y2", "11");
    			add_location(line1, file$G, 4, 8, 253);
    			attr_dev(svg, "stroke", "rgb(160,160,160)");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "stroke-width", "2");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "stroke-linecap", "round");
    			attr_dev(svg, "stroke-linejoin", "round");
    			add_location(svg, file$G, 0, 1, 1);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle);
    			append_dev(svg, line0);
    			append_dev(svg, line1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconDeMagnify', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconDeMagnify> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class IconDeMagnify extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconDeMagnify",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* src\components\icons\IconChevronLeft.svelte generated by Svelte v3.46.3 */

    const file$F = "src\\components\\icons\\IconChevronLeft.svelte";

    function create_fragment$J(ctx) {
    	let svg;
    	let polyline0;
    	let polyline1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			polyline0 = svg_element("polyline");
    			polyline1 = svg_element("polyline");
    			attr_dev(polyline0, "points", "30 10 10 30 30 50");
    			attr_dev(polyline0, "stroke", "rgba(0,0,0,0.5)");
    			attr_dev(polyline0, "stroke-width", "8");
    			attr_dev(polyline0, "stroke-linecap", "square");
    			attr_dev(polyline0, "fill", "none");
    			attr_dev(polyline0, "stroke-linejoin", "round");
    			add_location(polyline0, file$F, 1, 4, 34);
    			attr_dev(polyline1, "points", "30 10 10 30 30 50");
    			attr_dev(polyline1, "stroke", "rgba(255,255,255,0.5)");
    			attr_dev(polyline1, "stroke-width", "4");
    			attr_dev(polyline1, "stroke-linecap", "square");
    			attr_dev(polyline1, "fill", "none");
    			attr_dev(polyline1, "stroke-linejoin", "round");
    			add_location(polyline1, file$F, 3, 4, 187);
    			attr_dev(svg, "width", "44");
    			attr_dev(svg, "height", "60");
    			add_location(svg, file$F, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, polyline0);
    			append_dev(svg, polyline1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconChevronLeft', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconChevronLeft> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class IconChevronLeft extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconChevronLeft",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src\components\icons\IconChevronRight.svelte generated by Svelte v3.46.3 */

    const file$E = "src\\components\\icons\\IconChevronRight.svelte";

    function create_fragment$I(ctx) {
    	let svg;
    	let polyline0;
    	let polyline1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			polyline0 = svg_element("polyline");
    			polyline1 = svg_element("polyline");
    			attr_dev(polyline0, "points", "14 10 34 30 14 50");
    			attr_dev(polyline0, "stroke", "rgba(0,0,0,0.5)");
    			attr_dev(polyline0, "stroke-width", "8");
    			attr_dev(polyline0, "stroke-linecap", "square");
    			attr_dev(polyline0, "fill", "none");
    			attr_dev(polyline0, "stroke-linejoin", "round");
    			add_location(polyline0, file$E, 1, 4, 34);
    			attr_dev(polyline1, "points", "14 10 34 30 14 50");
    			attr_dev(polyline1, "stroke", "rgba(255,255,255,0.5)");
    			attr_dev(polyline1, "stroke-width", "4");
    			attr_dev(polyline1, "stroke-linecap", "square");
    			attr_dev(polyline1, "fill", "none");
    			attr_dev(polyline1, "stroke-linejoin", "round");
    			add_location(polyline1, file$E, 3, 4, 187);
    			attr_dev(svg, "width", "44");
    			attr_dev(svg, "height", "60");
    			add_location(svg, file$E, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, polyline0);
    			append_dev(svg, polyline1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconChevronRight', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconChevronRight> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class IconChevronRight extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconChevronRight",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* src\components\icons\IconX.svelte generated by Svelte v3.46.3 */

    const file$D = "src\\components\\icons\\IconX.svelte";

    function create_fragment$H(ctx) {
    	let svg;
    	let g;
    	let line0;
    	let line1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			attr_dev(line0, "x1", "11");
    			attr_dev(line0, "y1", "11");
    			attr_dev(line0, "x2", "31");
    			attr_dev(line0, "y2", "31");
    			add_location(line0, file$D, 2, 8, 90);
    			attr_dev(line1, "x1", "11");
    			attr_dev(line1, "y1", "31");
    			attr_dev(line1, "x2", "31");
    			attr_dev(line1, "y2", "11");
    			add_location(line1, file$D, 3, 8, 139);
    			attr_dev(g, "stroke", "rgb(160,160,160)");
    			attr_dev(g, "stroke-width", "4");
    			add_location(g, file$D, 1, 4, 34);
    			attr_dev(svg, "width", "36");
    			attr_dev(svg, "height", "36");
    			add_location(svg, file$D, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, line0);
    			append_dev(g, line1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconX', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconX> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class IconX extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconX",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* node_modules\svelte-keydown\src\Keydown.svelte generated by Svelte v3.46.3 */

    function create_fragment$G(ctx) {
    	let mounted;
    	let dispose;

    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (!mounted) {
    				dispose = [
    					listen_dev(document.body, "keyup", /*keyup_handler*/ ctx[7], false, false, false),
    					listen_dev(document.body, "keyup", /*keyup_handler_1*/ ctx[9], false, false, false),
    					listen_dev(document.body, "keydown", /*keydown_handler*/ ctx[8], false, false, false),
    					listen_dev(document.body, "keydown", /*keydown_handler_1*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let combination;
    	let comboByKey;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Keydown', slots, []);
    	let { paused = false } = $$props;
    	let { pauseOnInput = false } = $$props;
    	const dispatch = createEventDispatcher();
    	let combo = [];
    	let down = [];
    	const writable_props = ['paused', 'pauseOnInput'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Keydown> was created with unknown prop '${key}'`);
    	});

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const keyup_handler_1 = ({ key }) => {
    		$$invalidate(4, down = down.filter(_key => _key !== key));
    		if (down.length > 0) return;
    		$$invalidate(2, combo = []);
    	};

    	const keydown_handler_1 = ({ key, target }) => {
    		if (pauseOnInput && target.tagName !== "BODY") {
    			return;
    		}

    		$$invalidate(4, down = [...down, key]);

    		if (!paused) {
    			if (!(key in comboByKey)) {
    				$$invalidate(2, combo = [...combo, key]);
    			} else {
    				dispatch("combo", combination);
    			}

    			dispatch(key === " " ? "Space" : key);
    			dispatch("key", key);
    		}
    	};

    	$$self.$$set = $$props => {
    		if ('paused' in $$props) $$invalidate(0, paused = $$props.paused);
    		if ('pauseOnInput' in $$props) $$invalidate(1, pauseOnInput = $$props.pauseOnInput);
    	};

    	$$self.$capture_state = () => ({
    		paused,
    		pauseOnInput,
    		createEventDispatcher,
    		dispatch,
    		combo,
    		down,
    		combination,
    		comboByKey
    	});

    	$$self.$inject_state = $$props => {
    		if ('paused' in $$props) $$invalidate(0, paused = $$props.paused);
    		if ('pauseOnInput' in $$props) $$invalidate(1, pauseOnInput = $$props.pauseOnInput);
    		if ('combo' in $$props) $$invalidate(2, combo = $$props.combo);
    		if ('down' in $$props) $$invalidate(4, down = $$props.down);
    		if ('combination' in $$props) $$invalidate(3, combination = $$props.combination);
    		if ('comboByKey' in $$props) $$invalidate(5, comboByKey = $$props.comboByKey);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*combo*/ 4) {
    			$$invalidate(3, combination = combo.join("-"));
    		}

    		if ($$self.$$.dirty & /*combo*/ 4) {
    			$$invalidate(5, comboByKey = combo.reduce((keys, key) => ({ ...keys, [key]: true }), {}));
    		}

    		if ($$self.$$.dirty & /*combo, combination*/ 12) {
    			if (combo.length > 0) dispatch("combo", combination);
    		}
    	};

    	return [
    		paused,
    		pauseOnInput,
    		combo,
    		combination,
    		down,
    		comboByKey,
    		dispatch,
    		keyup_handler,
    		keydown_handler,
    		keyup_handler_1,
    		keydown_handler_1
    	];
    }

    class Keydown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { paused: 0, pauseOnInput: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Keydown",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get paused() {
    		throw new Error("<Keydown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set paused(value) {
    		throw new Error("<Keydown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pauseOnInput() {
    		throw new Error("<Keydown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pauseOnInput(value) {
    		throw new Error("<Keydown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Keydown$1 = Keydown;

    /* src\components\Key-capture.svelte generated by Svelte v3.46.3 */

    const { console: console_1$2 } = globals;

    // (15:19) 
    function create_if_block_1$b(ctx) {
    	let keydown;
    	let current;
    	keydown = new Keydown$1({ $$inline: true });

    	keydown.$on("Escape", function () {
    		if (is_function(/*onEscape*/ ctx[0])) /*onEscape*/ ctx[0].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(keydown.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(keydown, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(keydown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(keydown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(keydown, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(15:19) ",
    		ctx
    	});

    	return block;
    }

    // (13:0) {#if onEscape && log}
    function create_if_block$l(ctx) {
    	let keydown;
    	let current;
    	keydown = new Keydown$1({ $$inline: true });
    	keydown.$on("Escape", /*onEscapeMessage*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(keydown.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(keydown, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(keydown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(keydown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(keydown, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(13:0) {#if onEscape && log}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$l, create_if_block_1$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*onEscape*/ ctx[0] && /*log*/ ctx[1]) return 0;
    		if (/*onEscape*/ ctx[0]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Key_capture', slots, []);
    	let { onEscape } = $$props;
    	let { log } = $$props;

    	const onEscapeMessage = e => {
    		console.log('onEscape!', e);
    		onEscape(e);
    	};

    	const writable_props = ['onEscape', 'log'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Key_capture> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('onEscape' in $$props) $$invalidate(0, onEscape = $$props.onEscape);
    		if ('log' in $$props) $$invalidate(1, log = $$props.log);
    	};

    	$$self.$capture_state = () => ({ Keydown: Keydown$1, onEscape, log, onEscapeMessage });

    	$$self.$inject_state = $$props => {
    		if ('onEscape' in $$props) $$invalidate(0, onEscape = $$props.onEscape);
    		if ('log' in $$props) $$invalidate(1, log = $$props.log);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [onEscape, log, onEscapeMessage];
    }

    class Key_capture extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, { onEscape: 0, log: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Key_capture",
    			options,
    			id: create_fragment$F.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onEscape*/ ctx[0] === undefined && !('onEscape' in props)) {
    			console_1$2.warn("<Key_capture> was created without expected prop 'onEscape'");
    		}

    		if (/*log*/ ctx[1] === undefined && !('log' in props)) {
    			console_1$2.warn("<Key_capture> was created without expected prop 'log'");
    		}
    	}

    	get onEscape() {
    		throw new Error("<Key_capture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEscape(value) {
    		throw new Error("<Key_capture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get log() {
    		throw new Error("<Key_capture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set log(value) {
    		throw new Error("<Key_capture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const tokenPrices = writable({});
    const shipPrices = writable({});
    const shipTrades = writable({});
    const nfts = writable([]);
    const ships = writable([]);
    const modalStatus = writable(null);
    const gallery = writable({});

    window.appState = {};

    tokenPrices.subscribe(prices => { window.appState.tokenPrices = prices; });
    shipPrices.subscribe(prices => { window.appState.pricesPrices = prices; });
    shipTrades.subscribe(trades => { window.appState.shipTrades = trades; });
    nfts.subscribe(nftList => { window.appState.nfts = nftList; });
    ships.subscribe(shipList => { window.appState.ships = shipList; });
    modalStatus.subscribe(status => { window.appState.modalStatus = status; });
    gallery.subscribe(status => { window.appState.gallery = status; });

    /* src\lightbox\Lightbox.svelte generated by Svelte v3.46.3 */

    const { Boolean: Boolean_1 } = globals;
    const file$C = "src\\lightbox\\Lightbox.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    // (230:0) {#if active}
    function create_if_block$k(ctx) {
    	let div5;
    	let div0;
    	let iconmagnify;
    	let t0;
    	let div1;
    	let icondemagnify;
    	let t1;
    	let div2;
    	let iconx;
    	let t2;
    	let div3;
    	let iconchevronleft;
    	let t3;
    	let div4;
    	let iconchevronright;
    	let t4;
    	let t5;
    	let div5_class_value;
    	let div5_intro;
    	let div5_outro;
    	let t6;
    	let keycapture;
    	let current;
    	let mounted;
    	let dispose;
    	iconmagnify = new IconMagnify({ $$inline: true });
    	icondemagnify = new IconDeMagnify({ $$inline: true });
    	iconx = new IconX({ $$inline: true });
    	iconchevronleft = new IconChevronLeft({ $$inline: true });
    	iconchevronright = new IconChevronRight({ $$inline: true });
    	let if_block = /*arrived*/ ctx[3] && create_if_block_1$a(ctx);
    	let each_value = /*imageList*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	keycapture = new Key_capture({
    			props: { onEscape: /*closeMe*/ ctx[9] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			create_component(iconmagnify.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(icondemagnify.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(iconx.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			create_component(iconchevronleft.$$.fragment);
    			t3 = space();
    			div4 = element("div");
    			create_component(iconchevronright.$$.fragment);
    			t4 = space();
    			if (if_block) if_block.c();
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			create_component(keycapture.$$.fragment);
    			attr_dev(div0, "class", "icon-button magnify svelte-vtd641");
    			add_location(div0, file$C, 232, 4, 7104);
    			attr_dev(div1, "class", "icon-button de-magnify svelte-vtd641");
    			add_location(div1, file$C, 233, 4, 7182);
    			attr_dev(div2, "class", "icon-button close-me svelte-vtd641");
    			add_location(div2, file$C, 234, 4, 7266);
    			attr_dev(div3, "class", "prior svelte-vtd641");
    			add_location(div3, file$C, 236, 4, 7342);
    			attr_dev(div4, "class", "next svelte-vtd641");
    			add_location(div4, file$C, 237, 4, 7413);
    			attr_dev(div5, "class", div5_class_value = "" + (null_to_empty(/*lightboxClass*/ ctx[5]) + " svelte-vtd641"));
    			add_location(div5, file$C, 230, 0, 7052);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			mount_component(iconmagnify, div0, null);
    			append_dev(div5, t0);
    			append_dev(div5, div1);
    			mount_component(icondemagnify, div1, null);
    			append_dev(div5, t1);
    			append_dev(div5, div2);
    			mount_component(iconx, div2, null);
    			append_dev(div5, t2);
    			append_dev(div5, div3);
    			mount_component(iconchevronleft, div3, null);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			mount_component(iconchevronright, div4, null);
    			append_dev(div5, t4);
    			if (if_block) if_block.m(div5, null);
    			append_dev(div5, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div5, null);
    			}

    			insert_dev(target, t6, anchor);
    			mount_component(keycapture, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*zoomIn*/ ctx[11], false, false, false),
    					listen_dev(div1, "click", /*zoomOut*/ ctx[12], false, false, false),
    					listen_dev(div2, "click", /*closeMe*/ ctx[9], false, false, false),
    					listen_dev(div3, "click", /*showPrior*/ ctx[16], false, false, false),
    					listen_dev(div4, "click", /*showNext*/ ctx[15], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*arrived*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*arrived*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div5, t5);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*composeImageURL, imageList*/ 257) {
    				each_value = /*imageList*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div5, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*lightboxClass*/ 32 && div5_class_value !== (div5_class_value = "" + (null_to_empty(/*lightboxClass*/ ctx[5]) + " svelte-vtd641"))) {
    				attr_dev(div5, "class", div5_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconmagnify.$$.fragment, local);
    			transition_in(icondemagnify.$$.fragment, local);
    			transition_in(iconx.$$.fragment, local);
    			transition_in(iconchevronleft.$$.fragment, local);
    			transition_in(iconchevronright.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			add_render_callback(() => {
    				if (div5_outro) div5_outro.end(1);
    				div5_intro = create_in_transition(div5, fade, {});
    				div5_intro.start();
    			});

    			transition_in(keycapture.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconmagnify.$$.fragment, local);
    			transition_out(icondemagnify.$$.fragment, local);
    			transition_out(iconx.$$.fragment, local);
    			transition_out(iconchevronleft.$$.fragment, local);
    			transition_out(iconchevronright.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean_1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (div5_intro) div5_intro.invalidate();
    			div5_outro = create_out_transition(div5, fade, {});
    			transition_out(keycapture.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(iconmagnify);
    			destroy_component(icondemagnify);
    			destroy_component(iconx);
    			destroy_component(iconchevronleft);
    			destroy_component(iconchevronright);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    			if (detaching && div5_outro) div5_outro.end();
    			if (detaching) detach_dev(t6);
    			destroy_component(keycapture, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(230:0) {#if active}",
    		ctx
    	});

    	return block;
    }

    // (240:4) {#if arrived}
    function create_if_block_1$a(ctx) {
    	let div1;
    	let div0;
    	let img;
    	let img_src_value;
    	let div1_intro;
    	let div1_outro;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[7])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", /*alt*/ ctx[6]);
    			attr_dev(img, "class", "svelte-vtd641");
    			add_location(img, file$C, 242, 12, 7615);
    			attr_dev(div0, "class", "photo svelte-vtd641");
    			attr_dev(div0, "style", /*photoScale*/ ctx[4]);
    			add_location(div0, file$C, 241, 8, 7563);
    			attr_dev(div1, "class", "photo-frame svelte-vtd641");
    			add_location(div1, file$C, 240, 4, 7504);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, img);
    			/*img_binding*/ ctx[28](img);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(img, "load", /*onImageLoad*/ ctx[10](), false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*src*/ 128 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[7])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty[0] & /*alt*/ 64) {
    				attr_dev(img, "alt", /*alt*/ ctx[6]);
    			}

    			if (!current || dirty[0] & /*photoScale*/ 16) {
    				attr_dev(div0, "style", /*photoScale*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div1_outro) div1_outro.end(1);
    				div1_intro = create_in_transition(div1, /*slideIn*/ ctx[14], {});
    				div1_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (div1_intro) div1_intro.invalidate();
    			div1_outro = create_out_transition(div1, /*slideOut*/ ctx[13], {});
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*img_binding*/ ctx[28](null);
    			if (detaching && div1_outro) div1_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(240:4) {#if arrived}",
    		ctx
    	});

    	return block;
    }

    // (248:4) {#each imageList as imageSource }
    function create_each_block$4(ctx) {
    	let div1;
    	let div0;
    	let a;
    	let t0;
    	let iconchevronright;
    	let a_href_value;
    	let a_download_value;
    	let t1;
    	let div1_intro;
    	let div1_outro;
    	let current;
    	iconchevronright = new IconChevronRight({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			a = element("a");
    			t0 = text("Download\r\n                    ");
    			create_component(iconchevronright.$$.fragment);
    			t1 = space();
    			attr_dev(a, "class", "download-button svelte-vtd641");
    			attr_dev(a, "href", a_href_value = /*composeImageURL*/ ctx[8](/*imageSource*/ ctx[42]));
    			attr_dev(a, "download", a_download_value = /*imageSource*/ ctx[42].split('/').pop());
    			add_location(a, file$C, 250, 16, 7888);
    			attr_dev(div0, "class", "description-column svelte-vtd641");
    			add_location(div0, file$C, 249, 12, 7838);
    			attr_dev(div1, "class", "description-panel collapsed svelte-vtd641");
    			add_location(div1, file$C, 248, 8, 7766);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, a);
    			append_dev(a, t0);
    			mount_component(iconchevronright, a, null);
    			append_dev(div1, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*imageList*/ 1 && a_href_value !== (a_href_value = /*composeImageURL*/ ctx[8](/*imageSource*/ ctx[42]))) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (!current || dirty[0] & /*imageList*/ 1 && a_download_value !== (a_download_value = /*imageSource*/ ctx[42].split('/').pop())) {
    				attr_dev(a, "download", a_download_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconchevronright.$$.fragment, local);

    			add_render_callback(() => {
    				if (div1_outro) div1_outro.end(1);
    				div1_intro = create_in_transition(div1, fade, {});
    				div1_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconchevronright.$$.fragment, local);
    			if (div1_intro) div1_intro.invalidate();
    			div1_outro = create_out_transition(div1, fade, {});
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(iconchevronright);
    			if (detaching && div1_outro) div1_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(248:4) {#each imageList as imageSource }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*active*/ ctx[1] && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*active*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*active*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let ship;
    	let active;
    	let imageList;
    	let currentIndex;
    	let source;
    	let fileName;
    	let src;
    	let width;
    	let height;
    	let ratio;
    	let workingHeight;
    	let workingWidth;
    	let photoClass;
    	let alt;
    	let lightboxClass;
    	let photoSvgClass;
    	let photoScale;
    	let $gallery;
    	validate_store(gallery, 'gallery');
    	component_subscribe($$self, gallery, $$value => $$invalidate(27, $gallery = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lightbox', slots, []);
    	const dummyArray = [];
    	let loaded = false;
    	let slideDirection = '';
    	let imgEl;
    	let zoomer;
    	let arrived = true;
    	let foundWidth = 0;
    	let foundHeight = 0;

    	const composeImageURL = (() => {
    		const prefix = 'https://play.staratlas.com/_next/image?url=';
    		const suffix = '&w=1920&q=75';
    		return address => prefix + encodeURIComponent(address) + suffix;
    	})();

    	const updateGallery = (field, value) => {
    		gallery.update(gal => ({ ...gal, [field]: value }));
    	};

    	const closeLightbox = () => {
    		updateGallery('ship', null);
    	};

    	const closeMe = () => {
    		slideDirection = '';
    		$$invalidate(17, loaded = false);

    		// showFullDescription = true;
    		// scale = 1;
    		if (zoomer) {
    			zoomer.destroy();
    			zoomer = null;
    		}

    		closeLightbox();
    	};

    	const onImageLoad = () => {
    		const getZoomer = () => zoomer;

    		const setLoaded = newLoaded => {
    			$$invalidate(17, loaded = newLoaded);
    		};

    		const setZoomer = newZoomer => zoomer = newZoomer;

    		const setHeight = newHeight => {
    			$$invalidate(19, foundHeight = newHeight);
    		};

    		const setWidth = newWidth => {
    			$$invalidate(18, foundWidth = newWidth);
    		};

    		return function () {
    			const zoomer = getZoomer();
    			setHeight(this.height);
    			setWidth(this.width);
    			setLoaded(true);

    			if (!zoomer) {
    				const zoomProps = {
    					minScale: 1,
    					maxScale: 5,
    					speed: 6,
    					dragScrollableOptions: { smoothExtinction: true },
    					zoomOnClick: false
    				};

    				setZoomer(WZoom.create(imgEl, zoomProps));
    			}
    		};
    	};

    	const composeScale = (height, width) => {
    		const ratio = height / width;

    		if (ratio > 1) {
    			return 'width:' + (getDocHeight() / ratio).toFixed(1) + 'px; ' + 'height:' + getDocHeight() + 'px;';
    		}

    		return 'width:' + getDocWidth() + 'px; ' + 'height:' + (getDocWidth() * ratio).toFixed(1) + 'px;';
    	};

    	const calcHeight = (width, height) => {
    		const ratio = height / width;

    		if (ratio > 1) {
    			return getDocHeight() + 'px';
    		}

    		return (getDocWidth() * ratio).toFixed(1) + 'px';
    	};

    	const calcWidth = data => {
    		const { width, height } = data;
    		const ratio = height / width;

    		if (ratio > 1) {
    			return (getDocHeight() / ratio).toFixed(1) + 'px';
    		}

    		return getDocWidth() + 'px';
    	};

    	/*
    $: {
        console.groupCollapsed('shipId', (ship && ship.symbol), (ship && ship.id), 
            '  IMG ' + currentIndex + '   width ' + width + '   height' + height
        );
        console.log('SRC ' + src);
        console.log('lightbox', imageList);
        console.log('fileName', fileName);
        console.groupEnd();
    }
    */
    	const reset = () => {
    		$$invalidate(17, loaded = false);
    	};

    	const zoomIn = () => {
    		if (zoomer) {
    			zoomer.zoomUp();
    		}
    	};

    	const zoomOut = () => {
    		if (zoomer) {
    			zoomer.zoomDown();
    		}
    	};

    	function slideOut(node, { delay = 0, duration = 150 }) {
    		return {
    			delay,
    			duration,
    			css: t => {
    				if (!slideDirection) {
    					return '';
    				}

    				const direction = slideDirection === 'forward' ? 1 : -1;
    				const eased = sineOut(t);
    				return `transform: translate(${direction * (-105 + eased * 105)}%, 0)`;
    			}
    		};
    	}

    	function slideIn(node, { delay = 0, duration = 350 }) {
    		return {
    			delay,
    			duration,
    			css: t => {
    				if (!slideDirection) {
    					return '';
    				}

    				const direction = slideDirection === 'forward' ? 1 : -1;
    				const eased = sineOut(t);
    				return `transform: translate(${direction * (105 - eased * 105)}%, 0)`;
    			}
    		};
    	}

    	const showNext = () => {
    		slideDirection = 'forward';

    		if (zoomer) {
    			zoomer.destroy();
    			zoomer = null;
    		}

    		$$invalidate(3, arrived = false);

    		const nextIndex = currentIndex === imageList.length - 1
    		? 0
    		: currentIndex + 1;

    		setTimeout(
    			() => {
    				$$invalidate(17, loaded = false);
    				updateGallery('currentIndex', nextIndex);

    				setTimeout(
    					() => {
    						if (zoomer) {
    							zoomer.prepare();
    						}

    						$$invalidate(3, arrived = true);
    					},
    					400
    				);
    			},
    			140
    		);
    	};

    	const showPrior = () => {
    		slideDirection = 'previous';

    		if (zoomer) {
    			zoomer.destroy();
    			zoomer = null;
    		}

    		$$invalidate(3, arrived = false);

    		const priorIndex = currentIndex === 0
    		? imageList.length - 1
    		: currentIndex - 1;

    		setTimeout(
    			() => {
    				$$invalidate(17, loaded = false);
    				updateGallery('currentIndex', priorIndex);

    				setTimeout(
    					() => {
    						if (zoomer) {
    							zoomer.prepare();
    						}

    						$$invalidate(3, arrived = true);
    					},
    					400
    				);
    			},
    			140
    		);
    	};

    	onMount(reset);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lightbox> was created with unknown prop '${key}'`);
    	});

    	function img_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			imgEl = $$value;
    			$$invalidate(2, imgEl);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		fade,
    		sineOut,
    		WZoom,
    		getDocHeight,
    		getDocWidth,
    		IconMagnify,
    		IconDeMagnify,
    		IconChevronLeft,
    		IconChevronRight,
    		IconX,
    		KeyCapture: Key_capture,
    		gallery,
    		dummyArray,
    		loaded,
    		slideDirection,
    		imgEl,
    		zoomer,
    		arrived,
    		foundWidth,
    		foundHeight,
    		composeImageURL,
    		updateGallery,
    		closeLightbox,
    		closeMe,
    		onImageLoad,
    		composeScale,
    		calcHeight,
    		calcWidth,
    		reset,
    		zoomIn,
    		zoomOut,
    		slideOut,
    		slideIn,
    		showNext,
    		showPrior,
    		currentIndex,
    		imageList,
    		width,
    		height,
    		photoScale,
    		photoSvgClass,
    		active,
    		lightboxClass,
    		fileName,
    		alt,
    		ratio,
    		photoClass,
    		workingWidth,
    		workingHeight,
    		source,
    		src,
    		ship,
    		$gallery
    	});

    	$$self.$inject_state = $$props => {
    		if ('loaded' in $$props) $$invalidate(17, loaded = $$props.loaded);
    		if ('slideDirection' in $$props) slideDirection = $$props.slideDirection;
    		if ('imgEl' in $$props) $$invalidate(2, imgEl = $$props.imgEl);
    		if ('zoomer' in $$props) zoomer = $$props.zoomer;
    		if ('arrived' in $$props) $$invalidate(3, arrived = $$props.arrived);
    		if ('foundWidth' in $$props) $$invalidate(18, foundWidth = $$props.foundWidth);
    		if ('foundHeight' in $$props) $$invalidate(19, foundHeight = $$props.foundHeight);
    		if ('currentIndex' in $$props) $$invalidate(20, currentIndex = $$props.currentIndex);
    		if ('imageList' in $$props) $$invalidate(0, imageList = $$props.imageList);
    		if ('width' in $$props) $$invalidate(21, width = $$props.width);
    		if ('height' in $$props) $$invalidate(22, height = $$props.height);
    		if ('photoScale' in $$props) $$invalidate(4, photoScale = $$props.photoScale);
    		if ('photoSvgClass' in $$props) photoSvgClass = $$props.photoSvgClass;
    		if ('active' in $$props) $$invalidate(1, active = $$props.active);
    		if ('lightboxClass' in $$props) $$invalidate(5, lightboxClass = $$props.lightboxClass);
    		if ('fileName' in $$props) $$invalidate(23, fileName = $$props.fileName);
    		if ('alt' in $$props) $$invalidate(6, alt = $$props.alt);
    		if ('ratio' in $$props) $$invalidate(24, ratio = $$props.ratio);
    		if ('photoClass' in $$props) photoClass = $$props.photoClass;
    		if ('workingWidth' in $$props) workingWidth = $$props.workingWidth;
    		if ('workingHeight' in $$props) workingHeight = $$props.workingHeight;
    		if ('source' in $$props) $$invalidate(25, source = $$props.source);
    		if ('src' in $$props) $$invalidate(7, src = $$props.src);
    		if ('ship' in $$props) $$invalidate(26, ship = $$props.ship);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$gallery*/ 134217728) {
    			$$invalidate(26, ship = $gallery.ship);
    		}

    		if ($$self.$$.dirty[0] & /*ship*/ 67108864) {
    			$$invalidate(1, active = Boolean(ship));
    		}

    		if ($$self.$$.dirty[0] & /*active, ship*/ 67108866) {
    			$$invalidate(0, imageList = active
    			? [ship.image, ...ship.media.gallery]
    			: dummyArray);
    		}

    		if ($$self.$$.dirty[0] & /*$gallery*/ 134217728) {
    			$$invalidate(20, currentIndex = $gallery.currentIndex || 0);
    		}

    		if ($$self.$$.dirty[0] & /*active, imageList, currentIndex*/ 1048579) {
    			$$invalidate(25, source = active ? imageList[currentIndex] : '');
    		}

    		if ($$self.$$.dirty[0] & /*source*/ 33554432) {
    			$$invalidate(23, fileName = source ? source.split('/').pop() : '');
    		}

    		if ($$self.$$.dirty[0] & /*source*/ 33554432) {
    			$$invalidate(7, src = source ? composeImageURL(source) : '');
    		}

    		if ($$self.$$.dirty[0] & /*foundWidth*/ 262144) {
    			$$invalidate(21, width = foundWidth || 1920);
    		}

    		if ($$self.$$.dirty[0] & /*foundHeight*/ 524288) {
    			$$invalidate(22, height = foundHeight || 1200);
    		}

    		if ($$self.$$.dirty[0] & /*height, width*/ 6291456) {
    			$$invalidate(24, ratio = height / width);
    		}

    		if ($$self.$$.dirty[0] & /*width, height*/ 6291456) {
    			workingHeight = calcHeight(width, height);
    		}

    		if ($$self.$$.dirty[0] & /*width, height*/ 6291456) {
    			workingWidth = calcWidth(width);
    		}

    		if ($$self.$$.dirty[0] & /*ratio*/ 16777216) {
    			photoClass = 'photo ' + (ratio > 1 ? 'tall' : ratio < 1 ? 'wide' : 'square');
    		}

    		if ($$self.$$.dirty[0] & /*fileName*/ 8388608) {
    			$$invalidate(6, alt = fileName || 'image');
    		}

    		if ($$self.$$.dirty[0] & /*active*/ 2) {
    			$$invalidate(5, lightboxClass = 'lightbox' + (active ? ' active' : ''));
    		}

    		if ($$self.$$.dirty[0] & /*loaded*/ 131072) {
    			photoSvgClass = 'photo-svg' + (loaded ? ' image-loaded' : '');
    		}

    		if ($$self.$$.dirty[0] & /*height, width*/ 6291456) {
    			$$invalidate(4, photoScale = composeScale(height, width));
    		}
    	};

    	return [
    		imageList,
    		active,
    		imgEl,
    		arrived,
    		photoScale,
    		lightboxClass,
    		alt,
    		src,
    		composeImageURL,
    		closeMe,
    		onImageLoad,
    		zoomIn,
    		zoomOut,
    		slideOut,
    		slideIn,
    		showNext,
    		showPrior,
    		loaded,
    		foundWidth,
    		foundHeight,
    		currentIndex,
    		width,
    		height,
    		fileName,
    		ratio,
    		source,
    		ship,
    		$gallery,
    		img_binding
    	];
    }

    class Lightbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lightbox",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    const assets = {
        images: {
            'thumb-220': {
                'CALCH.jpg': true,
                'CALEV.jpg': true,
                'CALG.jpg': true,
                'CHI.jpg': true,
                'FBLAIR.jpg': true,
                'FBLBEA.jpg': true,
                'FBLBPL.jpg': true,
                'FBLEBO.jpg': true,
                'FBLEGR.jpg': true,
                'FBLETR.jpg': true,
    			'FBLEUN.jpg': true,
                'OGKAJA.jpg': true,
    			'OGKAMK.jpg': true,
                'OGKATP.jpg': true,
                'OM.jpg': true,
                'OPALJ.jpg': true,
                'OPALJJ.jpg': true,
                'PC11.jpg': true,
                'PC9.jpg': true,
                'PF4.jpg': true,
                'PR8.jpg': true,
                'PX4.jpg': true,
                'PX5.jpg': true,
                'PX6.jpg': true,
                'TUFAFE.jpg': true,
                'VZUSAM.jpg': true,
                'VZUSOP.jpg': true
            },
            'med-720': {
                'CALCH.jpg': true,
                'CALEV.jpg': true,
                'CALG.jpg': true,
                'CHI.jpg': true,
                'FBLAIR.jpg': true,
                'FBLBEA.jpg': true,
                'FBLBPL.jpg': true,
                'FBLEBO.jpg': true,
                'FBLEGR.jpg': true,
                'FBLETR.jpg': true,
    			'FBLEUN.jpg': true,
                'OGKAJA.jpg': true,
    			'OGKAMK.jpg': true,
                'OGKATP.jpg': true,
                'OM.jpg': true,
                'OPALJ.jpg': true,
                'OPALJJ.jpg': true,
                'PC11.jpg': true,
                'PC9.jpg': true,
                'PF4.jpg': true,
                'PR8.jpg': true,
                'PX4.jpg': true,
                'PX5.jpg': true,
                'PX6.jpg': true,
                'TUFAFE.jpg': true,
                'VZUSAM.jpg': true,
                'VZUSOP.jpg': true
            }
        }
    };

    const ASCEND = 'ASCEND';
    const DESCEND = 'DESCEND';
    const RESPONSIVE = {
        MIN_WIDTH: 750
    };

    const CUSTOM_SORTS = {
       'rarity': {
            'common': 1,
            'uncommon': 2,
            'rare': 3,
            'epic': 4,
            'legendary': 5,
            'anomaly': 6
        },
        'size': {
            'xx-small': 1,
            'x-small': 2,
            'small': 3,
            'medium': 4,
            'large': 5,
            'capital': 6,
            'commander': 7,
            'titan': 8
        }
    };
    CUSTOM_SORTS['shipClass'] = CUSTOM_SORTS['size'];






    window.process = {
        env: {
            NODE_ENV: 'production'
        }
    };

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq_1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return _assocIndexOf(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = _listCacheClear;
    ListCache.prototype['delete'] = _listCacheDelete;
    ListCache.prototype.get = _listCacheGet;
    ListCache.prototype.has = _listCacheHas;
    ListCache.prototype.set = _listCacheSet;

    var _ListCache = ListCache;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new _ListCache;
      this.size = 0;
    }

    var _stackClear = stackClear;

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete;

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet;

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas;

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /** Detect free variable `global` from Node.js. */

    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal = freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = _freeGlobal || freeSelf || Function('return this')();

    var _root = root;

    /** Built-in value references. */
    var Symbol$1 = _root.Symbol;

    var _Symbol = Symbol$1;

    /** Used for built-in method references. */
    var objectProto$c = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$c.toString;

    /** Built-in value references. */
    var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$a.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag;

    /** Used for built-in method references. */
    var objectProto$b = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$b.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    var _objectToString = objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? _getRawTag(value)
        : _objectToString(value);
    }

    var _baseGetTag = baseGetTag;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag$2 = '[object Function]',
        genTag$1 = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject_1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = _baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = _root['__core-js_shared__'];

    var _coreJsData = coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$a = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty$9).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject_1(value) || _isMasked(value)) {
        return false;
      }
      var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(_toSource(value));
    }

    var _baseIsNative = baseIsNative;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = _getValue(object, key);
      return _baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative;

    /* Built-in method references that are verified to be native. */
    var Map$1 = _getNative(_root, 'Map');

    var _Map = Map$1;

    /* Built-in method references that are verified to be native. */
    var nativeCreate = _getNative(Object, 'create');

    var _nativeCreate = nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (_nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? undefined : result;
      }
      return hasOwnProperty$8.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet;

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$7.call(data, key);
    }

    var _hashHas = hashHas;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    var _hashSet = hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = _hashClear;
    Hash.prototype['delete'] = _hashDelete;
    Hash.prototype.get = _hashGet;
    Hash.prototype.has = _hashHas;
    Hash.prototype.set = _hashSet;

    var _Hash = Hash;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new _Hash,
        'map': new (_Map || _ListCache),
        'string': new _Hash
      };
    }

    var _mapCacheClear = mapCacheClear;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return _isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = _getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return _getMapData(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return _getMapData(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = _getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = _mapCacheClear;
    MapCache.prototype['delete'] = _mapCacheDelete;
    MapCache.prototype.get = _mapCacheGet;
    MapCache.prototype.has = _mapCacheHas;
    MapCache.prototype.set = _mapCacheSet;

    var _MapCache = MapCache;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof _ListCache) {
        var pairs = data.__data__;
        if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new _MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet;

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new _ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = _stackClear;
    Stack.prototype['delete'] = _stackDelete;
    Stack.prototype.get = _stackGet;
    Stack.prototype.has = _stackHas;
    Stack.prototype.set = _stackSet;

    var _Stack = Stack;

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    var _arrayEach = arrayEach;

    var defineProperty = (function() {
      try {
        var func = _getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    var _defineProperty = defineProperty;

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && _defineProperty) {
        _defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    var _baseAssignValue = baseAssignValue;

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$6.call(object, key) && eq_1(objValue, value)) ||
          (value === undefined && !(key in object))) {
        _baseAssignValue(object, key, value);
      }
    }

    var _assignValue = assignValue;

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          _baseAssignValue(object, key, newValue);
        } else {
          _assignValue(object, key, newValue);
        }
      }
      return object;
    }

    var _copyObject = copyObject;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    var _baseTimes = baseTimes;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
    }

    var _baseIsArguments = baseIsArguments;

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
      return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') &&
        !propertyIsEnumerable$1.call(value, 'callee');
    };

    var isArguments_1 = isArguments;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    var isArray_1 = isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? _root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse_1;

    module.exports = isBuffer;
    });

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    var _isIndex = isIndex;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    var isLength_1 = isLength;

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag$2 = '[object Boolean]',
        dateTag$2 = '[object Date]',
        errorTag$1 = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag$4 = '[object Map]',
        numberTag$2 = '[object Number]',
        objectTag$2 = '[object Object]',
        regexpTag$2 = '[object RegExp]',
        setTag$4 = '[object Set]',
        stringTag$2 = '[object String]',
        weakMapTag$2 = '[object WeakMap]';

    var arrayBufferTag$2 = '[object ArrayBuffer]',
        dataViewTag$3 = '[object DataView]',
        float32Tag$2 = '[object Float32Array]',
        float64Tag$2 = '[object Float64Array]',
        int8Tag$2 = '[object Int8Array]',
        int16Tag$2 = '[object Int16Array]',
        int32Tag$2 = '[object Int32Array]',
        uint8Tag$2 = '[object Uint8Array]',
        uint8ClampedTag$2 = '[object Uint8ClampedArray]',
        uint16Tag$2 = '[object Uint16Array]',
        uint32Tag$2 = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
    typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
    typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
    typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
    typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
    typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
    typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
    typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
    typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] =
    typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
    typedArrayTags[weakMapTag$2] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike_1(value) &&
        isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray;

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary;

    var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && _freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    module.exports = nodeUtil;
    });

    /* Node.js helper references. */
    var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

    var isTypedArray_1 = isTypedArray;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray_1(value),
          isArg = !isArr && isArguments_1(value),
          isBuff = !isArr && !isArg && isBuffer_1(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? _baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$4.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               _isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

      return value === proto;
    }

    var _isPrototype = isPrototype;

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = _overArg(Object.keys, Object);

    var _nativeKeys = nativeKeys;

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!_isPrototype(object)) {
        return _nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeys = baseKeys;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength_1(value.length) && !isFunction_1(value);
    }

    var isArrayLike_1 = isArrayLike;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
    }

    var keys_1 = keys;

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && _copyObject(source, keys_1(source), object);
    }

    var _baseAssign = baseAssign;

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    var _nativeKeysIn = nativeKeysIn;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject_1(object)) {
        return _nativeKeysIn(object);
      }
      var isProto = _isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeysIn = baseKeysIn;

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
    }

    var keysIn_1 = keysIn;

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && _copyObject(source, keysIn_1(source), object);
    }

    var _baseAssignIn = baseAssignIn;

    var _cloneBuffer = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? _root.Buffer : undefined,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    module.exports = cloneBuffer;
    });

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    var _copyArray = copyArray;

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    var _arrayFilter = arrayFilter;

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    var stubArray_1 = stubArray;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return _arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    var _getSymbols = getSymbols;

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return _copyObject(source, _getSymbols(source), object);
    }

    var _copySymbols = copySymbols;

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    var _arrayPush = arrayPush;

    /** Built-in value references. */
    var getPrototype = _overArg(Object.getPrototypeOf, Object);

    var _getPrototype = getPrototype;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray_1 : function(object) {
      var result = [];
      while (object) {
        _arrayPush(result, _getSymbols(object));
        object = _getPrototype(object);
      }
      return result;
    };

    var _getSymbolsIn = getSymbolsIn;

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return _copyObject(source, _getSymbolsIn(source), object);
    }

    var _copySymbolsIn = copySymbolsIn;

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys;

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return _baseGetAllKeys(object, keys_1, _getSymbols);
    }

    var _getAllKeys = getAllKeys;

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
    }

    var _getAllKeysIn = getAllKeysIn;

    /* Built-in method references that are verified to be native. */
    var DataView = _getNative(_root, 'DataView');

    var _DataView = DataView;

    /* Built-in method references that are verified to be native. */
    var Promise$1 = _getNative(_root, 'Promise');

    var _Promise = Promise$1;

    /* Built-in method references that are verified to be native. */
    var Set$1 = _getNative(_root, 'Set');

    var _Set = Set$1;

    /* Built-in method references that are verified to be native. */
    var WeakMap = _getNative(_root, 'WeakMap');

    var _WeakMap = WeakMap;

    /** `Object#toString` result references. */
    var mapTag$3 = '[object Map]',
        objectTag$1 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag$3 = '[object Set]',
        weakMapTag$1 = '[object WeakMap]';

    var dataViewTag$2 = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = _toSource(_DataView),
        mapCtorString = _toSource(_Map),
        promiseCtorString = _toSource(_Promise),
        setCtorString = _toSource(_Set),
        weakMapCtorString = _toSource(_WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = _baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
        (_Map && getTag(new _Map) != mapTag$3) ||
        (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
        (_Set && getTag(new _Set) != setTag$3) ||
        (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
      getTag = function(value) {
        var result = _baseGetTag(value),
            Ctor = result == objectTag$1 ? value.constructor : undefined,
            ctorString = Ctor ? _toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag$2;
            case mapCtorString: return mapTag$3;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag$3;
            case weakMapCtorString: return weakMapTag$1;
          }
        }
        return result;
      };
    }

    var _getTag = getTag;

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto.hasOwnProperty;

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty$1.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    var _initCloneArray = initCloneArray;

    /** Built-in value references. */
    var Uint8Array = _root.Uint8Array;

    var _Uint8Array = Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
      return result;
    }

    var _cloneArrayBuffer = cloneArrayBuffer;

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    var _cloneDataView = cloneDataView;

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    var _cloneRegExp = cloneRegExp;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    var _cloneSymbol = cloneSymbol;

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    var _cloneTypedArray = cloneTypedArray;

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        mapTag$2 = '[object Map]',
        numberTag$1 = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag$2 = '[object Set]',
        stringTag$1 = '[object String]',
        symbolTag$1 = '[object Symbol]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]',
        float32Tag$1 = '[object Float32Array]',
        float64Tag$1 = '[object Float64Array]',
        int8Tag$1 = '[object Int8Array]',
        int16Tag$1 = '[object Int16Array]',
        int32Tag$1 = '[object Int32Array]',
        uint8Tag$1 = '[object Uint8Array]',
        uint8ClampedTag$1 = '[object Uint8ClampedArray]',
        uint16Tag$1 = '[object Uint16Array]',
        uint32Tag$1 = '[object Uint32Array]';

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return _cloneArrayBuffer(object);

        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object);

        case dataViewTag$1:
          return _cloneDataView(object, isDeep);

        case float32Tag$1: case float64Tag$1:
        case int8Tag$1: case int16Tag$1: case int32Tag$1:
        case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
          return _cloneTypedArray(object, isDeep);

        case mapTag$2:
          return new Ctor;

        case numberTag$1:
        case stringTag$1:
          return new Ctor(object);

        case regexpTag$1:
          return _cloneRegExp(object);

        case setTag$2:
          return new Ctor;

        case symbolTag$1:
          return _cloneSymbol(object);
      }
    }

    var _initCloneByTag = initCloneByTag;

    /** Built-in value references. */
    var objectCreate = Object.create;

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject_1(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    var _baseCreate = baseCreate;

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !_isPrototype(object))
        ? _baseCreate(_getPrototype(object))
        : {};
    }

    var _initCloneObject = initCloneObject;

    /** `Object#toString` result references. */
    var mapTag$1 = '[object Map]';

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike_1(value) && _getTag(value) == mapTag$1;
    }

    var _baseIsMap = baseIsMap;

    /* Node.js helper references. */
    var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

    var isMap_1 = isMap;

    /** `Object#toString` result references. */
    var setTag$1 = '[object Set]';

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike_1(value) && _getTag(value) == setTag$1;
    }

    var _baseIsSet = baseIsSet;

    /* Node.js helper references. */
    var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

    var isSet_1 = isSet;

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$1 = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG$1 = 4;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] =
    cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
    cloneableTags[boolTag] = cloneableTags[dateTag] =
    cloneableTags[float32Tag] = cloneableTags[float64Tag] =
    cloneableTags[int8Tag] = cloneableTags[int16Tag] =
    cloneableTags[int32Tag] = cloneableTags[mapTag] =
    cloneableTags[numberTag] = cloneableTags[objectTag] =
    cloneableTags[regexpTag] = cloneableTags[setTag] =
    cloneableTags[stringTag] = cloneableTags[symbolTag] =
    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] =
    cloneableTags[weakMapTag] = false;

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG$1,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject_1(value)) {
        return value;
      }
      var isArr = isArray_1(value);
      if (isArr) {
        result = _initCloneArray(value);
        if (!isDeep) {
          return _copyArray(value, result);
        }
      } else {
        var tag = _getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer_1(value)) {
          return _cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : _initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? _copySymbolsIn(value, _baseAssignIn(result, value))
              : _copySymbols(value, _baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = _initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new _Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet_1(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap_1(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? _getAllKeysIn : _getAllKeys)
        : (isFlat ? keysIn_1 : keys_1);

      var props = isArr ? undefined : keysFunc(value);
      _arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    var _baseClone = baseClone;

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG = 1,
        CLONE_SYMBOLS_FLAG = 4;

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return _baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    var cloneDeep_1 = cloneDeep;

    const baseTrade = { op: 'subscribe', channel: 'trades' };
    const baseL2 = { op: 'subscribe', channel: 'level2' };

    const dummyOjbect  = {};
    const oneMinute = 1000 /* ms */ * 60;

    let currentPrices = {};
    let currentTokens = {};
    let currentTrades = {};
    let shipList = [];

    ships.subscribe(list => {shipList = list; });
    shipPrices.subscribe(priceMap => { currentPrices = priceMap; });
    shipTrades.subscribe(tradeMap => { currentTrades = tradeMap; });
    tokenPrices.subscribe(priceMap => { currentTokens = priceMap; });

    const updateTokenPrices = (() => {

        const tokens = [
            { market: 'ATLAS/USDC', dexlabAddress: 'Di66GTLsV64JgCCYGVcY21RZ173BHkjJVgPyezNN7P1K' },
            { market: 'POLIS/USDC', dexlabAddress: 'HxFLKUAmAMLz1jtT3hbvCMELwH5H9tpM2QugP8sKyfhW' },
            { market: 'SOL/USDC',   dexlabAddress: '9wFFyRfZBsuAha4YcuxcXLKwMxJR43S7fPfQLusDBzvT' }
        ];

        const priceURL = address => 'https://open-api.dexlab.space/v1/prices/' + address + '/last';
        const yesterdayURL = address => 'https://open-api.dexlab.space/v1/prices/' + address + '/closing-price';
        // const last24URL =  address => 'https://open-api.dexlab.space/v1/trades/' + address + '/24h';

        return async () => {

            for (const token of tokens) {
                const results = await fetch(priceURL(token.dexlabAddress));

                if (results.ok) {
                    const price = await results.json();

                    if (price.success && price.data) {
                        currentTokens[token.market] = Number(price.data.price);
                        tokenPrices.set(currentTokens);
                    }
                }

            }

            for (const token of tokens) {
                const results = await fetch(yesterdayURL(token.dexlabAddress));

                if (results.ok) {
                    const price = await results.json();

                    if (price.success && price.data) {
                        currentTokens['CLOSE ' + token.market] = Number(price.data.price);
                        tokenPrices.set(currentTokens);
                    }
                }

            }

        };

    })();

    const getShip = (shipList, message) => {
        return shipList.find(ship => ship.markets.find(market => market.id === message.market));
    };

    const updatePrices = (() => {

        const sortByPrice = (A, B) => Number(A[0]) > Number(B[0]) 
            ? 1 
            : Number(A[0]) < Number(B[0]) 
                ? -1 
                : 0;

        const getHighest = (A, B) => {
            if (!A && !B) { return 0;}
            const a = Number(A || 0);
            const b = Number(B || 0);
            return Math.max(a, b); 
        };

        const getLowest = (A, B) => {
            if (!A && !B) { return 0; }
            const a = Number(A || Infinity);
            const b = Number(B || Infinity);
            return Math.min(a, b); 
        };

        return messageObject => {

            const message = JSON.parse(messageObject.data);

            if (!message) { return; }

            if (message.type === 'recent_trades') {
                return updateTrades(message);
            }

            if (message.type !== 'l2snapshot' && message.type !== 'l2update') { return; }

            const ship = getShip(shipList, message);

            if (!ship) { return; }

            const prices = { ...currentPrices };

            const asks = message.asks.sort(sortByPrice);
            const bids = message.bids.sort(sortByPrice);

            let lowestAsk = asks[0];
            let highestBid = bids[bids.length - 1];

            lowestAsk = lowestAsk ? lowestAsk[0] : 0;
            highestBid = highestBid ? highestBid[0] : 0;

            ship.prices = prices[ship.id] = { 
                ...(prices[ship.id] || dummyOjbect), 
                name: ship.name, 
                id: ship.id 
            };

            const market = ship.markets.find(market => market.id === message.market);

            if (market.quotePair === 'ATLAS') {
                prices[ship.id].askATLAS = getLowest(prices[ship.id].askATLAS, lowestAsk);
                prices[ship.id].bidATLAS = getHighest(prices[ship.id].bidATLAS, highestBid);
            }

            if (market.quotePair === 'USDC') {
                prices[ship.id].askUSDC = getLowest(prices[ship.id].askUSDC, lowestAsk);            prices[ship.id].bidUSDC = getHighest(prices[ship.id].bidUSDC, highestBid);
            }

            ships.set(shipList);
            shipPrices.set(prices);
        };
    })(); 

    const updateTrades = (() => {


        /*
        const sortDatez = (A, B) => (A[0] > B[0]) ? 1 : (A[0] < B[0]) ? -1 : 0;
        const composeTradeDataCandles = (source, prior) => {
            const datez = {};

            for (const item of source) {
                const day = item.timestamp.split('T')[0];
                const stamp = new Date(item.timestamp).getTime();

                const mapDate = datez[day] = datez[day] || { ...dummyDay, time: day };
                const val = Number(item.price);

                if (val < mapDate.low) { mapDate.low = val; }
                if (val > mapDate.high) { mapDate.high = val; }

                if (stamp > mapDate.closeStamp) {
                    mapDate.closeStamp = stamp;
                    mapDate.close = val;
                }
                if (stamp < mapDate.openStamp) {
                    mapDate.openStamp = stamp;
                    mapDate.open = val;
                }
            }

            const trades = Object.entries(datez).sort(sortDatez).map(item => item[1]);

            if (prior && prior.length) {
                const additions = [];
                for (const tradeDay of prior) {
                    if (!trades.find(day => day.time === tradeDay.time)) {
                        additions.push(tradeDay);
                    }
                }
                if (additions.length) {
                    return additions.concat(trades);
                }
            }

            return trades;
        };
        */

        const composeTradeData2 = (() => {

            const stampTime = dateString => {
                const dateStamp = new Date(dateString).getTime();
                return Math.round(dateStamp / 1000);
            };
            const convertTrade = trade => ({
                time: stampTime(trade.timestamp), 
                value: Number(trade.price)
            });

            const diffPriorTime = (batch, i) => (batch[i].time !== batch[i-1].time);

            const nextTimeFar = (batch, i) => (!batch[i+1] 
                ? true 
                : (batch[i+1].time - batch[i].time) > 1
            );

            const sortTime = (A, B) => (A.time > B.time) ? 1 : (A.time < B.time) ? -1 : 0;

            return (sourceTrades, prior) => {
                const batch = sourceTrades.map(convertTrade).sort(sortTime);

                const delivery = [batch[0]];

                for (let i = 1; i < batch.length; i++) {
                    if (diffPriorTime(batch, i)) {
                        delivery.push(batch[i]);
                    } else if (nextTimeFar(batch, i)) {
                        batch[i].time++;
                        delivery.push(batch[i]);
                    }
                }

                if (prior) {
                    for (const trade of prior) {
                        if (!delivery.find(next => next.time === trade.time)) {
                            delivery.push(trade);
                        }
                    }
                }

                delivery.sort(sortTime);

                return delivery;
            };
        
        })(); 

        return message => {

            if (!message.trades || !message.trades.length) {
                // console.error('BAD TRADE MESSAGE');
                // console.log(message);
                return;
            }

            const ship = getShip(shipList, message);
            if (!ship) { return; }

            const { quotePair } = ship.markets.find(next => next.id === message.market);
            const allTrades = cloneDeep_1(currentTrades);

            const trades = allTrades[ship.id] = allTrades[ship.id] || {};
            trades[quotePair] = composeTradeData2(message.trades, trades[quotePair]);
            shipTrades.set(allTrades);

            // console.group('UPDATE TRADES');
            // console.log('message', message);
            // console.log('ship', ship);
            // console.log('trades', trades);
            // console.groupEnd();

        };
    })();

    let ws$1 = null;

    /*
    const getFTXTrades = (() => {

        const handleResults = wsResponse => {
            console.log('results', wsResponse);
            const results = JSON.parse(wsResponse.data);
            console.log('results!', results);
        };

        return () => {
            ftx.init(handleResults);

            setTimeout(() => {
                ftx.fetchPrices('ATLAS/USD');
            }, 5000);
            
        };
    })();
    */
    const getDexlabTrades = (() => {

        const getDexURL = address => 'https://open-api.dexlab.space/v1/trades/' +
            address + '/24h';

        const composeMessage = (results, market) => {
            const trades = results.data
                .filter(item => item.side === 'buy')
                .map(item => ({
                        type: item.type,
                        price: item.price,
                        side: item.side,
                        timestamp: item.time,
                        size: item.size,
                        market: market.id

                    })
                );
            const message = {
                market: market.id,
                timestamp: Date.now(),
                type: 'recent_trades',
                trades
            };
            return message;
        };

        return async market => {
            const results = await fetch(getDexURL(market.id));

            if (results.ok) {
                const trades = await results.json();
                if (trades.success && trades.data && trades.data.length);

                const message = composeMessage(trades, market);

                // console.group('DEX LAB TRADES');
                // console.log('MARKET', market);
                // console.log('Dex trades', trades);
                // console.log('Faux SA trade', message);
                // console.groupEnd();

                 updateTrades(message);

            }
        };

    })();

    const getTrades = (() => {

        const tradeTracker = {};

        return ship => {
            if (!ws$1) { return; }

            if (tradeTracker[ship.id]) { return; }
            tradeTracker[ship.id] = true;

            for (const market of ship.markets) {
                ws$1.send(JSON.stringify({ ...baseTrade, markets: [market.id] }));
                getDexlabTrades(market);
            }
        };
    })();


    const getPrices = () => {

        // DONT INITIALIZE MORE THAN ONCE
        if (ws$1) { return; }

        if (!shipList || !shipList.length) {
            console.log('NOT INITIATED -- SHIP LIST EMPTY??');
            return;
        }

        //getFTXTrades();

        updateTokenPrices();
        setInterval(updateTokenPrices, oneMinute);

        ws$1 = new WebSocket('wss://serum-vial.staratlas.cloud/v1/ws');
        ws$1.onmessage = updatePrices;

        const shipsToGet = [ ...shipList ];

        const getNextShip = () => {
            if (shipsToGet.length) {
                const ship = shipsToGet.shift();
                for (const market of ship.markets) {
                    ws$1.send(JSON.stringify({ ...baseL2, markets: [market.id] }));
                }
                callNext();
            }
        };

        const callNext = () => { 
            // THE 'wss://serum-vial.staratlas.cloud/v1/ws' ENDPOINT 
            // ALLOWS ONLY 50 CONNECTIONS PER SECOND, SO WE THROTTLE
            // TO 40 REQUESTS PER SECOND TO BE SAFE
            setTimeout(getNextShip, 50);
        };

        ws$1.onopen = callNext;
    };

    var VZUSOP = {
    	earnDailyAtlas: 69.5131,
    	burnDailyAtlas: 13.9578,
    	hoursResupply: "3D-20H",
    	timeResupply: 331233
    };
    var PX5 = {
    	earnDailyAtlas: 6.2536,
    	burnDailyAtlas: 1.5713,
    	hoursResupply: "2D-2H",
    	timeResupply: 180790
    };
    var OGKAMK = {
    	earnDailyAtlas: 33.1871,
    	burnDailyAtlas: 7.5213,
    	hoursResupply: "3D-3H",
    	timeResupply: 270991
    };
    var OGKATP = {
    	earnDailyAtlas: 360.6708,
    	burnDailyAtlas: 77.1313,
    	hoursResupply: "5D-1H",
    	timeResupply: 437412
    };
    var PF4 = {
    	earnDailyAtlas: 118.984,
    	burnDailyAtlas: 24.2877,
    	hoursResupply: "4D-1H",
    	timeResupply: 349960
    };
    var OPALJJ = {
    	earnDailyAtlas: 12.242,
    	burnDailyAtlas: 1.9457,
    	hoursResupply: "2D-2H",
    	timeResupply: 182140
    };
    var VZUSAM = {
    	earnDailyAtlas: 47.742,
    	burnDailyAtlas: 7.7423,
    	hoursResupply: "3D-9H",
    	timeResupply: 291703
    };
    var FBLEGR = {
    	earnDailyAtlas: 352.9829,
    	burnDailyAtlas: 66.5222,
    	hoursResupply: "5D-13H",
    	timeResupply: 480520
    };
    var FBLEUN = {
    	earnDailyAtlas: 1.3746,
    	burnDailyAtlas: 0.2085,
    	hoursResupply: "1D-2H",
    	timeResupply: 96369
    };
    var PR8 = {
    	earnDailyAtlas: 433.9984,
    	burnDailyAtlas: 68.0048,
    	hoursResupply: "4D-15H",
    	timeResupply: 400420
    };
    var PC11 = {
    	earnDailyAtlas: 3462.0644,
    	burnDailyAtlas: 513.0503,
    	hoursResupply: "7D-2H",
    	timeResupply: 612349
    };
    var OGKAJA = {
    	earnDailyAtlas: 1145.2769,
    	burnDailyAtlas: 145.9798,
    	hoursResupply: "5D-0H",
    	timeResupply: 434181
    };
    var PX6 = {
    	earnDailyAtlas: 38.562,
    	burnDailyAtlas: 7.5627,
    	hoursResupply: "2D-23H",
    	timeResupply: 259097
    };
    var FBLETR = {
    	earnDailyAtlas: 3980.1015,
    	burnDailyAtlas: 506.8419,
    	hoursResupply: "7D-18H",
    	timeResupply: 672605
    };
    var CHI = {
    	earnDailyAtlas: 40.1198,
    	burnDailyAtlas: 6.9534,
    	hoursResupply: "3D-1H",
    	timeResupply: 265716
    };
    var FBLBEA = {
    	earnDailyAtlas: 36.9948,
    	burnDailyAtlas: 7.1619,
    	hoursResupply: "3D-4H",
    	timeResupply: 277061
    };
    var CALEV = {
    	earnDailyAtlas: 106.5649,
    	burnDailyAtlas: 20.4952,
    	hoursResupply: "3D-16H",
    	timeResupply: 318199
    };
    var FBLAIR = {
    	earnDailyAtlas: 0.7352,
    	burnDailyAtlas: 0.18576,
    	hoursResupply: "0D-21H",
    	timeResupply: 78886.9
    };
    var FBLEBO = {
    	earnDailyAtlas: 1374.5989,
    	burnDailyAtlas: 168.496,
    	hoursResupply: "6D-16H",
    	timeResupply: 576560
    };
    var CALG = {
    	earnDailyAtlas: 1174.468,
    	burnDailyAtlas: 145.0294,
    	hoursResupply: "6D-10H",
    	timeResupply: 555360
    };
    var OM = {
    	earnDailyAtlas: 111.6444,
    	burnDailyAtlas: 18.5539,
    	hoursResupply: "3D-8H",
    	timeResupply: 290309
    };
    var FBLBPL = {
    	earnDailyAtlas: 138.9424,
    	burnDailyAtlas: 21.8387,
    	hoursResupply: "3D-12H",
    	timeResupply: 305128
    };
    var CALCH = {
    	earnDailyAtlas: 146.8696,
    	burnDailyAtlas: 20.6486,
    	hoursResupply: "4D-5H",
    	timeResupply: 364351
    };
    var PX4 = {
    	earnDailyAtlas: 0.966,
    	burnDailyAtlas: 0.2109,
    	hoursResupply: "1D-1H",
    	timeResupply: 90157
    };
    var OPALJ = {
    	earnDailyAtlas: 0.851,
    	burnDailyAtlas: 0.1845,
    	hoursResupply: "0D-23H",
    	timeResupply: 86400
    };
    var PC9 = {
    	earnDailyAtlas: 1210.4476,
    	burnDailyAtlas: 170.565,
    	hoursResupply: "6D-1H",
    	timeResupply: 524777
    };
    var TUFAFE = {
    	earnDailyAtlas: 33.9492,
    	burnDailyAtlas: 7.4495,
    	hoursResupply: "4D-8H",
    	timeResupply: 377091
    };
    var refData = {
    	VZUSOP: VZUSOP,
    	PX5: PX5,
    	OGKAMK: OGKAMK,
    	OGKATP: OGKATP,
    	PF4: PF4,
    	OPALJJ: OPALJJ,
    	VZUSAM: VZUSAM,
    	FBLEGR: FBLEGR,
    	FBLEUN: FBLEUN,
    	PR8: PR8,
    	PC11: PC11,
    	OGKAJA: OGKAJA,
    	PX6: PX6,
    	FBLETR: FBLETR,
    	CHI: CHI,
    	FBLBEA: FBLBEA,
    	CALEV: CALEV,
    	FBLAIR: FBLAIR,
    	FBLEBO: FBLEBO,
    	CALG: CALG,
    	OM: OM,
    	FBLBPL: FBLBPL,
    	CALCH: CALCH,
    	PX4: PX4,
    	OPALJ: OPALJ,
    	PC9: PC9,
    	TUFAFE: TUFAFE
    };

    const sortBy = (field, custom) => {
        if (!custom) {
            return (A, B) => {
                if (A[field] > B[field]) { return 1; }
                if (A[field] < B[field]) { return -1; }
                return 0;
            };
        }

        return (A, B) => {
            if (!custom[A[field]]) {
                console.error('A', A[field], A);
            }
            if (!custom[B[field]]) {
                console.error('B', B[field], B);
            }
            if (custom[A[field]] > custom[B[field]]) { return 1; }
            if (custom[A[field]] < custom[B[field]]) { return -1; }
            return 0;
        };

    };

    const calc = (() => {

        const apr = (type, ship, tokenPrices) => {
            if (!tokenPrices['ATLAS/USDC']) {
                return 0;
            }
            let price = 0;

            if (type === 'VWAP') {
                price = ship.tradeSettings.vwap;
            } else if (type === 'askUSDC') {
                price = ship.prices && ship.prices.askUSDC;
            }

            const burn = ship.burnDailyAtlas;
            const earn = ship.earnDailyAtlas;

            if (!price || !burn || !earn) {
                return 0;
            }

            const atlas = Number(tokenPrices['ATLAS/USDC']);

            const goal = price/atlas;
            const dayNet = earn - burn;
            const daysToGoal = goal / dayNet;

            const apr = 365 / daysToGoal;

            return apr;
        };

        return {
            apr
        };
    })();

    let prices = {};
    shipPrices.subscribe(priceMap => { prices = priceMap; });


    const fetchNFTs = async() => {
        const starAtlasURL = 'https://galaxy.staratlas.com/nfts';
        const results = await fetch(starAtlasURL);
        const nftList = await results.json();
        nfts.set(nftList);
    };

    const getShips = (() => {

        return nftList => {

            if (!nftList) { return []; }

            const shipSubset = nftList.filter(next => 
                next.attributes && 
                next.attributes.itemType === 'ship' &&
                next.deactivated === false &&
                next.markets
            );

            if (!shipSubset || !shipSubset.length) {
                return;
            }

            const delivery = shipSubset
                .map(ship => ({ 
                    ...refData[ship.symbol],
                    ...ship, 
                    prices: prices[ship.id]
                }))
                .sort(sortBy('name'));

            ships.set(delivery);

            setTimeout(getPrices, 50);
        };

    })(); 

    nfts.subscribe(getShips);

    /* src\components\Percent-display.svelte generated by Svelte v3.46.3 */

    const file$B = "src\\components\\Percent-display.svelte";

    function create_fragment$D(ctx) {
    	let div;
    	let span0;
    	let t0;
    	let t1;
    	let span1;
    	let t2;
    	let t3;
    	let span2;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			t0 = text(/*sign*/ ctx[2]);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*displayNum*/ ctx[1]);
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "%";
    			attr_dev(span0, "class", "sign svelte-1qbm6mv");
    			add_location(span0, file$B, 13, 4, 461);
    			attr_dev(span1, "class", "number svelte-1qbm6mv");
    			add_location(span1, file$B, 14, 4, 499);
    			attr_dev(span2, "class", "percent-mark svelte-1qbm6mv");
    			add_location(span2, file$B, 15, 4, 545);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*workingClass*/ ctx[4] + /*percentClass*/ ctx[3]) + " svelte-1qbm6mv"));
    			attr_dev(div, "style", /*style*/ ctx[0]);
    			add_location(div, file$B, 12, 0, 400);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(span0, t0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			append_dev(div, span2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sign*/ 4) set_data_dev(t0, /*sign*/ ctx[2]);
    			if (dirty & /*displayNum*/ 2) set_data_dev(t2, /*displayNum*/ ctx[1]);

    			if (dirty & /*workingClass, percentClass*/ 24 && div_class_value !== (div_class_value = "" + (null_to_empty(/*workingClass*/ ctx[4] + /*percentClass*/ ctx[3]) + " svelte-1qbm6mv"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*style*/ 1) {
    				attr_dev(div, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let workingClass;
    	let percentClass;
    	let sign;
    	let displayNum;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Percent_display', slots, []);
    	let { num = 0 } = $$props;
    	let { decimals = 1 } = $$props;
    	let { style = '' } = $$props;
    	let { className = '' } = $$props;
    	const writable_props = ['num', 'decimals', 'style', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Percent_display> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('num' in $$props) $$invalidate(5, num = $$props.num);
    		if ('decimals' in $$props) $$invalidate(6, decimals = $$props.decimals);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		num,
    		decimals,
    		style,
    		className,
    		displayNum,
    		sign,
    		percentClass,
    		workingClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('num' in $$props) $$invalidate(5, num = $$props.num);
    		if ('decimals' in $$props) $$invalidate(6, decimals = $$props.decimals);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('displayNum' in $$props) $$invalidate(1, displayNum = $$props.displayNum);
    		if ('sign' in $$props) $$invalidate(2, sign = $$props.sign);
    		if ('percentClass' in $$props) $$invalidate(3, percentClass = $$props.percentClass);
    		if ('workingClass' in $$props) $$invalidate(4, workingClass = $$props.workingClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 128) {
    			$$invalidate(4, workingClass = className ? className + ' ' : '');
    		}

    		if ($$self.$$.dirty & /*num*/ 32) {
    			$$invalidate(3, percentClass = num < 0
    			? 'percent-display negative'
    			: 'percent-display positive');
    		}

    		if ($$self.$$.dirty & /*num*/ 32) {
    			$$invalidate(2, sign = num === 0 ? '' : num < 0 ? '—' : '+');
    		}

    		if ($$self.$$.dirty & /*num, decimals*/ 96) {
    			$$invalidate(1, displayNum = Math.abs(num * 100).toFixed(decimals));
    		}
    	};

    	return [style, displayNum, sign, percentClass, workingClass, num, decimals, className];
    }

    class Percent_display$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			num: 5,
    			decimals: 6,
    			style: 0,
    			className: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Percent_display",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get num() {
    		throw new Error("<Percent_display>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set num(value) {
    		throw new Error("<Percent_display>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get decimals() {
    		throw new Error("<Percent_display>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set decimals(value) {
    		throw new Error("<Percent_display>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Percent_display>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Percent_display>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Percent_display>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Percent_display>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\layouts\Chart-loader.svelte generated by Svelte v3.46.3 */

    const { console: console_1$1 } = globals;
    const file$A = "src\\layouts\\Chart-loader.svelte";

    function create_fragment$C(ctx) {
    	let div1;
    	let div0;
    	let div1_resize_listener;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "id", "tradingview-target");
    			add_location(div0, file$A, 55, 4, 1664);
    			attr_dev(div1, "class", "chart-container svelte-1msyjbr");
    			add_render_callback(() => /*div1_elementresize_handler*/ ctx[2].call(div1));
    			add_location(div1, file$A, 54, 0, 1604);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[2].bind(div1));
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			div1_resize_listener();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const tradingViewJS = 'https://s3.tradingview.com/tv.js'; // 'jslib/tradingview.js';

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Chart_loader', slots, []);
    	let { message } = $$props;
    	let width;

    	const marketMap = {
    		'ATLAS/USDC': 'FTX:ATLASUSD',
    		'POLIS/USDC': 'FTX:POLISUSD',
    		'SOL/USDC': 'FTX:SOLUSD'
    	};

    	const onLoad = () => {
    		console.log('MARKET>>> ???', message, marketMap[message]);
    		const height = Math.max(Math.round(width / 1.6, 500));

    		new window.TradingView.widget({
    				width: Math.round(width / 1.1),
    				height,
    				symbol: marketMap[message], // 'FTX:ATLASUSD',
    				interval: '60',
    				timezone: 'Etc/UTC',
    				theme: 'light', // 'dark',
    				style: '1',
    				locale: 'en',
    				toolbar_bg: '#f1f3f6',
    				enable_publishing: false,
    				save_image: false,
    				// show_popup_button: true,
    				popup_width: '1000',
    				popup_height: '650',
    				container_id: 'tradingview-target'
    			});
    	};

    	const loadScript = function (src, callback) {
    		var fileRequest = document.createElement('script');
    		fileRequest.setAttribute('async', true);
    		fileRequest.setAttribute('type', "text/javascript");
    		fileRequest.setAttribute('src', src);
    		fileRequest.onload = callback;
    		document.getElementsByTagName("head")[0].appendChild(fileRequest);
    	};

    	const mounted = () => loadScript(tradingViewJS, onLoad);
    	onMount(mounted);
    	const writable_props = ['message'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Chart_loader> was created with unknown prop '${key}'`);
    	});

    	function div1_elementresize_handler() {
    		width = this.clientWidth;
    		$$invalidate(0, width);
    	}

    	$$self.$$set = $$props => {
    		if ('message' in $$props) $$invalidate(1, message = $$props.message);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		message,
    		width,
    		marketMap,
    		onLoad,
    		tradingViewJS,
    		loadScript,
    		mounted
    	});

    	$$self.$inject_state = $$props => {
    		if ('message' in $$props) $$invalidate(1, message = $$props.message);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, message, div1_elementresize_handler];
    }

    class Chart_loader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { message: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Chart_loader",
    			options,
    			id: create_fragment$C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*message*/ ctx[1] === undefined && !('message' in props)) {
    			console_1$1.warn("<Chart_loader> was created without expected prop 'message'");
    		}
    	}

    	get message() {
    		throw new Error("<Chart_loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<Chart_loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Ticker.svelte generated by Svelte v3.46.3 */

    const { Object: Object_1$1 } = globals;
    const file$z = "src\\components\\Ticker.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (37:8) {#each prices as ticker}
    function create_each_block$3(ctx) {
    	let div3;
    	let div0;
    	let t0_value = /*ticker*/ ctx[4].market[0] + "";
    	let t0;
    	let span;
    	let t2_value = /*ticker*/ ctx[4].market[1] + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*ticker*/ ctx[4].price + "";
    	let t4;
    	let t5;
    	let div2;
    	let percentdisplay;
    	let t6;
    	let current;
    	let mounted;
    	let dispose;

    	percentdisplay = new Percent_display$1({
    			props: {
    				className: "ticker",
    				num: /*ticker*/ ctx[4].diff
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			span = element("span");
    			span.textContent = "/";
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			create_component(percentdisplay.$$.fragment);
    			t6 = space();
    			attr_dev(span, "class", "slash svelte-sop6mn");
    			add_location(span, file$z, 39, 38, 1308);
    			attr_dev(div0, "class", "market svelte-sop6mn");
    			add_location(div0, file$z, 38, 16, 1199);
    			attr_dev(div1, "class", "price svelte-sop6mn");
    			add_location(div1, file$z, 41, 16, 1396);
    			attr_dev(div2, "class", "diff svelte-sop6mn");
    			add_location(div2, file$z, 42, 16, 1453);
    			attr_dev(div3, "class", "ticker-group svelte-sop6mn");
    			add_location(div3, file$z, 37, 12, 1155);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div0, span);
    			append_dev(div0, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, t4);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			mount_component(percentdisplay, div2, null);
    			append_dev(div3, t6);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					div0,
    					"click",
    					function () {
    						if (is_function(/*clickHandler*/ ctx[1](/*ticker*/ ctx[4].market.join('/')))) /*clickHandler*/ ctx[1](/*ticker*/ ctx[4].market.join('/')).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*prices*/ 1) && t0_value !== (t0_value = /*ticker*/ ctx[4].market[0] + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*prices*/ 1) && t2_value !== (t2_value = /*ticker*/ ctx[4].market[1] + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*prices*/ 1) && t4_value !== (t4_value = /*ticker*/ ctx[4].price + "")) set_data_dev(t4, t4_value);
    			const percentdisplay_changes = {};
    			if (dirty & /*prices*/ 1) percentdisplay_changes.num = /*ticker*/ ctx[4].diff;
    			percentdisplay.$set(percentdisplay_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(percentdisplay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(percentdisplay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(percentdisplay);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(37:8) {#each prices as ticker}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div1;
    	let div0;
    	let current;
    	let each_value = /*prices*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "ticker-column svelte-sop6mn");
    			add_location(div0, file$z, 35, 4, 1080);
    			attr_dev(div1, "class", "ticker-frame svelte-sop6mn");
    			add_location(div1, file$z, 34, 0, 1048);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*prices, clickHandler*/ 3) {
    				each_value = /*prices*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let prices;
    	let $tokenPrices;
    	validate_store(tokenPrices, 'tokenPrices');
    	component_subscribe($$self, tokenPrices, $$value => $$invalidate(2, $tokenPrices = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ticker', slots, []);

    	const clickHandler = market => () => {
    		modalStatus.set(bind(Chart_loader, { message: market }));
    	};

    	const composePrices = priceMap => {
    		const prices = [];
    		const markets = Object.keys(priceMap).filter(price => !price.startsWith('CLOSE '));

    		for (const market of markets) {
    			const price = priceMap[market];
    			const close = priceMap['CLOSE ' + market];
    			const diff = close ? (price - close) / close : 0;

    			prices.push({
    				market: market.split('/'),
    				price,
    				close,
    				diff
    			});
    		}

    		return prices;
    	};

    	const writable_props = [];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Ticker> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		tokenPrices,
    		PercentDisplay: Percent_display$1,
    		bind,
    		modalStatus,
    		ChartLoader: Chart_loader,
    		clickHandler,
    		composePrices,
    		prices,
    		$tokenPrices
    	});

    	$$self.$inject_state = $$props => {
    		if ('prices' in $$props) $$invalidate(0, prices = $$props.prices);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$tokenPrices*/ 4) {
    			$$invalidate(0, prices = composePrices($tokenPrices));
    		}
    	};

    	return [prices, clickHandler, $tokenPrices];
    }

    class Ticker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ticker",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* src\components\Button-display-mode.svelte generated by Svelte v3.46.3 */

    const file$y = "src\\components\\Button-display-mode.svelte";

    function create_fragment$A(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div0_class_value;
    	let t1;
    	let div1;
    	let t2;
    	let div1_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text("Table");
    			t1 = space();
    			div1 = element("div");
    			t2 = text("Grid");
    			attr_dev(div0, "class", div0_class_value = "" + (null_to_empty(/*tableClass*/ ctx[2]) + " svelte-8e4kga"));
    			add_location(div0, file$y, 10, 4, 301);
    			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*gridClass*/ ctx[1]) + " svelte-8e4kga"));
    			add_location(div1, file$y, 11, 4, 380);
    			attr_dev(div2, "class", "button-display-mode svelte-8e4kga");
    			add_location(div2, file$y, 9, 0, 262);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						div0,
    						"click",
    						function () {
    							if (is_function(/*switchDisplayMode*/ ctx[0]('table'))) /*switchDisplayMode*/ ctx[0]('table').apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						div1,
    						"click",
    						function () {
    							if (is_function(/*switchDisplayMode*/ ctx[0]('grid'))) /*switchDisplayMode*/ ctx[0]('grid').apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*tableClass*/ 4 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*tableClass*/ ctx[2]) + " svelte-8e4kga"))) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (dirty & /*gridClass*/ 2 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*gridClass*/ ctx[1]) + " svelte-8e4kga"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let tableClass;
    	let gridClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button_display_mode', slots, []);
    	let { switchDisplayMode = () => false } = $$props;
    	let { displayMode } = $$props;
    	const writable_props = ['switchDisplayMode', 'displayMode'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button_display_mode> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('switchDisplayMode' in $$props) $$invalidate(0, switchDisplayMode = $$props.switchDisplayMode);
    		if ('displayMode' in $$props) $$invalidate(3, displayMode = $$props.displayMode);
    	};

    	$$self.$capture_state = () => ({
    		switchDisplayMode,
    		displayMode,
    		gridClass,
    		tableClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('switchDisplayMode' in $$props) $$invalidate(0, switchDisplayMode = $$props.switchDisplayMode);
    		if ('displayMode' in $$props) $$invalidate(3, displayMode = $$props.displayMode);
    		if ('gridClass' in $$props) $$invalidate(1, gridClass = $$props.gridClass);
    		if ('tableClass' in $$props) $$invalidate(2, tableClass = $$props.tableClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*displayMode*/ 8) {
    			$$invalidate(2, tableClass = 'mode table' + (displayMode === 'table' ? ' active' : ''));
    		}

    		if ($$self.$$.dirty & /*displayMode*/ 8) {
    			$$invalidate(1, gridClass = 'mode grid' + (displayMode === 'grid' ? ' active' : ''));
    		}
    	};

    	return [switchDisplayMode, gridClass, tableClass, displayMode];
    }

    class Button_display_mode extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { switchDisplayMode: 0, displayMode: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button_display_mode",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*displayMode*/ ctx[3] === undefined && !('displayMode' in props)) {
    			console.warn("<Button_display_mode> was created without expected prop 'displayMode'");
    		}
    	}

    	get switchDisplayMode() {
    		throw new Error("<Button_display_mode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set switchDisplayMode(value) {
    		throw new Error("<Button_display_mode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get displayMode() {
    		throw new Error("<Button_display_mode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set displayMode(value) {
    		throw new Error("<Button_display_mode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\layouts\Header-bar.svelte generated by Svelte v3.46.3 */
    const file$x = "src\\layouts\\Header-bar.svelte";

    // (16:12) {#if showModeSwitch}
    function create_if_block$j(ctx) {
    	let buttondisplaymode;
    	let current;

    	buttondisplaymode = new Button_display_mode({
    			props: {
    				displayMode: /*displayMode*/ ctx[1],
    				switchDisplayMode: /*switchDisplayMode*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(buttondisplaymode.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(buttondisplaymode, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const buttondisplaymode_changes = {};
    			if (dirty & /*displayMode*/ 2) buttondisplaymode_changes.displayMode = /*displayMode*/ ctx[1];
    			if (dirty & /*switchDisplayMode*/ 1) buttondisplaymode_changes.switchDisplayMode = /*switchDisplayMode*/ ctx[0];
    			buttondisplaymode.$set(buttondisplaymode_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttondisplaymode.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttondisplaymode.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(buttondisplaymode, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(16:12) {#if showModeSwitch}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let header;
    	let ticker;
    	let t0;
    	let div1;
    	let div0;
    	let h1;
    	let t2;
    	let current;
    	ticker = new Ticker({ $$inline: true });
    	let if_block = /*showModeSwitch*/ ctx[2] && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			header = element("header");
    			create_component(ticker.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Ship Markets";
    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(h1, "class", "svelte-1ri3j0n");
    			add_location(h1, file$x, 14, 12, 432);
    			attr_dev(div0, "class", "header-column svelte-1ri3j0n");
    			add_location(div0, file$x, 13, 8, 391);
    			attr_dev(div1, "class", "header-frame svelte-1ri3j0n");
    			add_location(div1, file$x, 12, 4, 355);
    			attr_dev(header, "class", "svelte-1ri3j0n");
    			add_location(header, file$x, 10, 0, 325);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			mount_component(ticker, header, null);
    			append_dev(header, t0);
    			append_dev(header, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			append_dev(div0, t2);
    			if (if_block) if_block.m(div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showModeSwitch*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showModeSwitch*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ticker.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ticker.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			destroy_component(ticker);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Header_bar', slots, []);
    	let { switchDisplayMode = () => false } = $$props;
    	let { displayMode } = $$props;
    	let { showModeSwitch } = $$props;
    	const writable_props = ['switchDisplayMode', 'displayMode', 'showModeSwitch'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Header_bar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('switchDisplayMode' in $$props) $$invalidate(0, switchDisplayMode = $$props.switchDisplayMode);
    		if ('displayMode' in $$props) $$invalidate(1, displayMode = $$props.displayMode);
    		if ('showModeSwitch' in $$props) $$invalidate(2, showModeSwitch = $$props.showModeSwitch);
    	};

    	$$self.$capture_state = () => ({
    		RESPONSIVE,
    		Ticker,
    		ButtonDisplayMode: Button_display_mode,
    		switchDisplayMode,
    		displayMode,
    		showModeSwitch
    	});

    	$$self.$inject_state = $$props => {
    		if ('switchDisplayMode' in $$props) $$invalidate(0, switchDisplayMode = $$props.switchDisplayMode);
    		if ('displayMode' in $$props) $$invalidate(1, displayMode = $$props.displayMode);
    		if ('showModeSwitch' in $$props) $$invalidate(2, showModeSwitch = $$props.showModeSwitch);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [switchDisplayMode, displayMode, showModeSwitch];
    }

    class Header_bar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
    			switchDisplayMode: 0,
    			displayMode: 1,
    			showModeSwitch: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header_bar",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*displayMode*/ ctx[1] === undefined && !('displayMode' in props)) {
    			console.warn("<Header_bar> was created without expected prop 'displayMode'");
    		}

    		if (/*showModeSwitch*/ ctx[2] === undefined && !('showModeSwitch' in props)) {
    			console.warn("<Header_bar> was created without expected prop 'showModeSwitch'");
    		}
    	}

    	get switchDisplayMode() {
    		throw new Error("<Header_bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set switchDisplayMode(value) {
    		throw new Error("<Header_bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get displayMode() {
    		throw new Error("<Header_bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set displayMode(value) {
    		throw new Error("<Header_bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showModeSwitch() {
    		throw new Error("<Header_bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showModeSwitch(value) {
    		throw new Error("<Header_bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-icons\components\IconBase.svelte generated by Svelte v3.46.3 */

    const file$w = "node_modules\\svelte-icons\\components\\IconBase.svelte";

    // (18:2) {#if title}
    function create_if_block$i(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[0]);
    			add_location(title_1, file$w, 18, 4, 298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(18:2) {#if title}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let svg;
    	let if_block_anchor;
    	let current;
    	let if_block = /*title*/ ctx[0] && create_if_block$i(ctx);
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			if (default_slot) default_slot.c();
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[1]);
    			attr_dev(svg, "class", "svelte-c8tyih");
    			add_location(svg, file$w, 16, 0, 229);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			if (if_block) if_block.m(svg, null);
    			append_dev(svg, if_block_anchor);

    			if (default_slot) {
    				default_slot.m(svg, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*title*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					if_block.m(svg, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*viewBox*/ 2) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (if_block) if_block.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IconBase', slots, ['default']);
    	let { title = null } = $$props;
    	let { viewBox } = $$props;
    	const writable_props = ['title', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IconBase> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('viewBox' in $$props) $$invalidate(1, viewBox = $$props.viewBox);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ title, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('viewBox' in $$props) $$invalidate(1, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, viewBox, $$scope, slots];
    }

    class IconBase extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { title: 0, viewBox: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconBase",
    			options,
    			id: create_fragment$y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*viewBox*/ ctx[1] === undefined && !('viewBox' in props)) {
    			console.warn("<IconBase> was created without expected prop 'viewBox'");
    		}
    	}

    	get title() {
    		throw new Error("<IconBase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<IconBase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<IconBase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<IconBase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-icons\md\MdClose.svelte generated by Svelte v3.46.3 */
    const file$v = "node_modules\\svelte-icons\\md\\MdClose.svelte";

    // (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
    function create_default_slot$9(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z");
    			add_location(path, file$v, 4, 10, 151);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let iconbase;
    	let current;
    	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

    	let iconbase_props = {
    		$$slots: { default: [create_default_slot$9] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
    	}

    	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(iconbase.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconbase, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const iconbase_changes = (dirty & /*$$props*/ 1)
    			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
    			: {};

    			if (dirty & /*$$scope*/ 2) {
    				iconbase_changes.$$scope = { dirty, ctx };
    			}

    			iconbase.$set(iconbase_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbase.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconbase.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconbase, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MdClose', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$capture_state = () => ({ IconBase });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class MdClose extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MdClose",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src\components\Modal-close-button.svelte generated by Svelte v3.46.3 */
    const file$u = "src\\components\\Modal-close-button.svelte";

    function create_fragment$w(ctx) {
    	let div;
    	let mdclose;
    	let current;
    	let mounted;
    	let dispose;
    	mdclose = new MdClose({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(mdclose.$$.fragment);
    			attr_dev(div, "class", "close-button svelte-1xf9c6q");
    			add_location(div, file$u, 5, 0, 106);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(mdclose, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*onClose*/ ctx[0])) /*onClose*/ ctx[0].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdclose.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdclose.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(mdclose);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modal_close_button', slots, []);
    	let { onClose } = $$props;
    	const writable_props = ['onClose'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modal_close_button> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('onClose' in $$props) $$invalidate(0, onClose = $$props.onClose);
    	};

    	$$self.$capture_state = () => ({ MdClose, onClose });

    	$$self.$inject_state = $$props => {
    		if ('onClose' in $$props) $$invalidate(0, onClose = $$props.onClose);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [onClose];
    }

    class Modal_close_button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { onClose: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal_close_button",
    			options,
    			id: create_fragment$w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onClose*/ ctx[0] === undefined && !('onClose' in props)) {
    			console.warn("<Modal_close_button> was created without expected prop 'onClose'");
    		}
    	}

    	get onClose() {
    		throw new Error("<Modal_close_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClose(value) {
    		throw new Error("<Modal_close_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-icons\fa\FaSortUp.svelte generated by Svelte v3.46.3 */
    const file$t = "node_modules\\svelte-icons\\fa\\FaSortUp.svelte";

    // (4:8) <IconBase viewBox="0 0 320 512" {...$$props}>
    function create_default_slot$8(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M279 224H41c-21.4 0-32.1-25.9-17-41L143 64c9.4-9.4 24.6-9.4 33.9 0l119 119c15.2 15.1 4.5 41-16.9 41z");
    			add_location(path, file$t, 4, 10, 153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(4:8) <IconBase viewBox=\\\"0 0 320 512\\\" {...$$props}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let iconbase;
    	let current;
    	const iconbase_spread_levels = [{ viewBox: "0 0 320 512" }, /*$$props*/ ctx[0]];

    	let iconbase_props = {
    		$$slots: { default: [create_default_slot$8] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
    	}

    	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(iconbase.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconbase, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const iconbase_changes = (dirty & /*$$props*/ 1)
    			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
    			: {};

    			if (dirty & /*$$scope*/ 2) {
    				iconbase_changes.$$scope = { dirty, ctx };
    			}

    			iconbase.$set(iconbase_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbase.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconbase.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconbase, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FaSortUp', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$capture_state = () => ({ IconBase });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class FaSortUp extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FaSortUp",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* node_modules\svelte-icons\fa\FaSortDown.svelte generated by Svelte v3.46.3 */
    const file$s = "node_modules\\svelte-icons\\fa\\FaSortDown.svelte";

    // (4:8) <IconBase viewBox="0 0 320 512" {...$$props}>
    function create_default_slot$7(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M41 288h238c21.4 0 32.1 25.9 17 41L177 448c-9.4 9.4-24.6 9.4-33.9 0L24 329c-15.1-15.1-4.4-41 17-41z");
    			add_location(path, file$s, 4, 10, 153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(4:8) <IconBase viewBox=\\\"0 0 320 512\\\" {...$$props}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let iconbase;
    	let current;
    	const iconbase_spread_levels = [{ viewBox: "0 0 320 512" }, /*$$props*/ ctx[0]];

    	let iconbase_props = {
    		$$slots: { default: [create_default_slot$7] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
    	}

    	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(iconbase.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconbase, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const iconbase_changes = (dirty & /*$$props*/ 1)
    			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
    			: {};

    			if (dirty & /*$$scope*/ 2) {
    				iconbase_changes.$$scope = { dirty, ctx };
    			}

    			iconbase.$set(iconbase_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbase.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconbase.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconbase, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FaSortDown', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$capture_state = () => ({ IconBase });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class FaSortDown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FaSortDown",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* node_modules\svelte-icons\fa\FaSort.svelte generated by Svelte v3.46.3 */
    const file$r = "node_modules\\svelte-icons\\fa\\FaSort.svelte";

    // (4:8) <IconBase viewBox="0 0 320 512" {...$$props}>
    function create_default_slot$6(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M41 288h238c21.4 0 32.1 25.9 17 41L177 448c-9.4 9.4-24.6 9.4-33.9 0L24 329c-15.1-15.1-4.4-41 17-41zm255-105L177 64c-9.4-9.4-24.6-9.4-33.9 0L24 183c-15.1 15.1-4.4 41 17 41h238c21.4 0 32.1-25.9 17-41z");
    			add_location(path, file$r, 4, 10, 153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(4:8) <IconBase viewBox=\\\"0 0 320 512\\\" {...$$props}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let iconbase;
    	let current;
    	const iconbase_spread_levels = [{ viewBox: "0 0 320 512" }, /*$$props*/ ctx[0]];

    	let iconbase_props = {
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
    	}

    	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(iconbase.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconbase, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const iconbase_changes = (dirty & /*$$props*/ 1)
    			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
    			: {};

    			if (dirty & /*$$scope*/ 2) {
    				iconbase_changes.$$scope = { dirty, ctx };
    			}

    			iconbase.$set(iconbase_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbase.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconbase.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconbase, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FaSort', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$capture_state = () => ({ IconBase });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class FaSort extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FaSort",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* src\table\Table-header.svelte generated by Svelte v3.46.3 */
    const file$q = "src\\table\\Table-header.svelte";

    // (23:29) 
    function create_if_block_2$3(ctx) {
    	let div;
    	let fasort;
    	let current;
    	fasort = new FaSort({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasort.$$.fragment);
    			attr_dev(div, "class", "sort-icon dormant svelte-pcqtwp");
    			add_location(div, file$q, 23, 8, 931);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasort, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasort.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasort.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasort);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(23:29) ",
    		ctx
    	});

    	return block;
    }

    // (21:47) 
    function create_if_block_1$9(ctx) {
    	let div;
    	let fasortup;
    	let current;
    	fasortup = new FaSortUp({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasortup.$$.fragment);
    			attr_dev(div, "class", "sort-icon descend svelte-pcqtwp");
    			add_location(div, file$q, 21, 8, 841);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasortup, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasortup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasortup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasortup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(21:47) ",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#if column.sortDirection === ASCEND }
    function create_if_block$h(ctx) {
    	let div;
    	let fasortdown;
    	let current;
    	fasortdown = new FaSortDown({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasortdown.$$.fragment);
    			attr_dev(div, "class", "sort-icon svelte-pcqtwp");
    			add_location(div, file$q, 19, 8, 739);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasortdown, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasortdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasortdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasortdown);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(19:4) {#if column.sortDirection === ASCEND }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div;
    	let t0_value = (/*column*/ ctx[0].displayText || /*column*/ ctx[0].display) + "";
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$h, create_if_block_1$9, create_if_block_2$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*column*/ ctx[0].sortDirection === ASCEND) return 0;
    		if (/*column*/ ctx[0].sortDirection === DESCEND) return 1;
    		if (!/*column*/ ctx[0].noSort) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*headerClass*/ ctx[1]) + " svelte-pcqtwp"));
    			add_location(div, file$q, 16, 0, 568);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*column*/ ctx[0].noSort || /*column*/ ctx[0].clickHandler)) (/*column*/ ctx[0].noSort || /*column*/ ctx[0].clickHandler).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*column*/ 1) && t0_value !== (t0_value = (/*column*/ ctx[0].displayText || /*column*/ ctx[0].display) + "")) set_data_dev(t0, t0_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				} else {
    					if_block = null;
    				}
    			}

    			if (!current || dirty & /*headerClass*/ 2 && div_class_value !== (div_class_value = "" + (null_to_empty(/*headerClass*/ ctx[1]) + " svelte-pcqtwp"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let headerClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Table_header', slots, []);
    	let { column } = $$props;
    	const writable_props = ['column'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Table_header> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    	};

    	$$self.$capture_state = () => ({
    		ASCEND,
    		DESCEND,
    		FaSortUp,
    		FaSortDown,
    		FaSort,
    		column,
    		headerClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('headerClass' in $$props) $$invalidate(1, headerClass = $$props.headerClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*column*/ 1) {
    			$$invalidate(1, headerClass = 'table-header' + (column.sortDirection === ASCEND ? ' ascend' : '') + (column.sortDirection === DESCEND ? ' descend' : '') + (column.doubleLine ? ' double-line' : '') + (column.alignRight ? ' align-right' : ''));
    		}
    	};

    	return [column, headerClass];
    }

    class Table_header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { column: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Table_header",
    			options,
    			id: create_fragment$s.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[0] === undefined && !('column' in props)) {
    			console.warn("<Table_header> was created without expected prop 'column'");
    		}
    	}

    	get column() {
    		throw new Error("<Table_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Table_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Icon.svelte generated by Svelte v3.46.3 */

    const file$p = "src\\components\\Icon.svelte";

    function create_fragment$r(ctx) {
    	let div;
    	let svg;
    	let raw_value = /*displayIcon*/ ctx[4].svg + "";
    	let svg_style_value;
    	let svg_class_value;
    	let svg_viewBox_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			attr_dev(svg, "style", svg_style_value = /*displayIcon*/ ctx[4].svgStyle || '');
    			attr_dev(svg, "class", svg_class_value = /*$$props*/ ctx[5].class);
    			attr_dev(svg, "focusable", /*focusable*/ ctx[2]);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + (/*displayIcon*/ ctx[4].boxW || /*displayIcon*/ ctx[4].box) + " " + (/*displayIcon*/ ctx[4].boxH || /*displayIcon*/ ctx[4].box));
    			add_location(svg, file$p, 37, 4, 3563);
    			attr_dev(div, "class", "icon");
    			attr_dev(div, "style", /*style*/ ctx[3]);
    			add_location(div, file$p, 36, 0, 3525);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			svg.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*displayIcon*/ 16 && raw_value !== (raw_value = /*displayIcon*/ ctx[4].svg + "")) svg.innerHTML = raw_value;
    			if (dirty & /*displayIcon*/ 16 && svg_style_value !== (svg_style_value = /*displayIcon*/ ctx[4].svgStyle || '')) {
    				attr_dev(svg, "style", svg_style_value);
    			}

    			if (dirty & /*$$props*/ 32 && svg_class_value !== (svg_class_value = /*$$props*/ ctx[5].class)) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*focusable*/ 4) {
    				attr_dev(svg, "focusable", /*focusable*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*displayIcon*/ 16 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + (/*displayIcon*/ ctx[4].boxW || /*displayIcon*/ ctx[4].box) + " " + (/*displayIcon*/ ctx[4].boxH || /*displayIcon*/ ctx[4].box))) {
    				attr_dev(svg, "viewBox", svg_viewBox_value);
    			}

    			if (dirty & /*style*/ 8) {
    				attr_dev(div, "style", /*style*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let displayIcon;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	let { name } = $$props;
    	let { width = "1rem" } = $$props;
    	let { height = "1rem" } = $$props;
    	let { focusable = false } = $$props;
    	let { style = '' } = $$props;

    	const icons = {
    		'usdc': {
    			boxW: 2000,
    			boxH: 2000,
    			name: 'usdc',
    			viewBox: '0 0 2000 2000',
    			svg: `<path d="M1000 2000c554.17 0 1000-445.83 1000-1000S1554.17 0 1000 0 0 445.83 0 1000s445.83 1000 1000 1000z" fill="#2775ca"/>
  <path d="M1275 1158.33c0-145.83-87.5-195.83-262.5-216.66-125-16.67-150-50-150-108.34s41.67-95.83 125-95.83c75 0 116.67 25 137.5 87.5 4.17 12.5 16.67 20.83 29.17 20.83h66.66c16.67 0 29.17-12.5 29.17-29.16v-4.17c-16.67-91.67-91.67-162.5-187.5-170.83v-100c0-16.67-12.5-29.17-33.33-33.34h-62.5c-16.67 0-29.17 12.5-33.34 33.34v95.83c-125 16.67-204.16 100-204.16 204.17 0 137.5 83.33 191.66 258.33 212.5 116.67 20.83 154.17 45.83 154.17 112.5s-58.34 112.5-137.5 112.5c-108.34 0-145.84-45.84-158.34-108.34-4.16-16.66-16.66-25-29.16-25h-70.84c-16.66 0-29.16 12.5-29.16 29.17v4.17c16.66 104.16 83.33 179.16 220.83 200v100c0 16.66 12.5 29.16 33.33 33.33h62.5c16.67 0 29.17-12.5 33.34-33.33v-100c125-20.84 208.33-108.34 208.33-220.84z" fill="#fff"/>
  <path d="M787.5 1595.83c-325-116.66-491.67-479.16-370.83-800 62.5-175 200-308.33 370.83-370.83 16.67-8.33 25-20.83 25-41.67V325c0-16.67-8.33-29.17-25-33.33-4.17 0-12.5 0-16.67 4.16-395.83 125-612.5 545.84-487.5 941.67 75 233.33 254.17 412.5 487.5 487.5 16.67 8.33 33.34 0 37.5-16.67 4.17-4.16 4.17-8.33 4.17-16.66v-58.34c0-12.5-12.5-29.16-25-37.5zM1229.17 295.83c-16.67-8.33-33.34 0-37.5 16.67-4.17 4.17-4.17 8.33-4.17 16.67v58.33c0 16.67 12.5 33.33 25 41.67 325 116.66 491.67 479.16 370.83 800-62.5 175-200 308.33-370.83 370.83-16.67 8.33-25 20.83-25 41.67V1700c0 16.67 8.33 29.17 25 33.33 4.17 0 12.5 0 16.67-4.16 395.83-125 612.5-545.84 487.5-941.67-75-237.5-258.34-416.67-487.5-491.67z" fill="#fff"/>`
    		},
    		'trash': {
    			box: 32,
    			name: "trash",
    			svg: `<path d="M12 12h2v12h-2z" /><path d="M18 12h2v12h-2z" /><path d="M4 6v2h2v20a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8h2V6zm4 22V8h16v20z" /><path d="M12 2h8v2h-8z" />`
    		},
    		'atlas': {
    			boxW: 96,
    			boxH: 96,
    			box: 96,
    			svgStyle: 'margin-top: -1px;',
    			name: 'atlas',
    			svg: '<defs><polygon id="path-1" points="8 15.5 0.5 0.5 15.5 0.5"></polygon><path d="M26,20.487 L12.588,49.322 C12.145,50.246 11.915,50.996 10.94,50.996 L2.081,51 C0.811,51 0.111,50.669 0.727,49.326 L22.39,2.112 C22.832,1.327 23.107,0.75 24.083,0.75 L27.918,0.75 C28.893,0.75 29.168,1.327 29.611,2.112 L51.272,49.326 C51.89,50.669 51.189,51 49.919,51 L41.06,50.996 C40.085,50.996 39.855,50.246 39.412,49.322 L26,20.487 L26,20.487 Z" id="path-3"></path></defs><g id="Icon-Reverse" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Group-3" transform="translate(40.000000, 67.000000)"><mask id="mask-2" fill="white"><use xlink:href="#path-1"></use></mask><g id="Clip-2"></g><polygon id="Fill-1" fill="#32FEFF" mask="url(#mask-2)" points="-3.25 19.25 19.25 19.25 19.25 -3.25 -3.25 -3.25"></polygon></g><g id="Group-6" transform="translate(22.000000, 21.000000)"><mask id="mask-4" fill="white"><use xlink:href="#path-3"></use></mask><g id="Clip-5"></g><polygon id="Fill-4" fill="#17181D" mask="url(#mask-4)" points="-3.25 54.75 55.25 54.75 55.25 -3 -3.25 -3"></polygon></g></g>'
    		}
    	};

    	$$self.$$set = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('name' in $$new_props) $$invalidate(6, name = $$new_props.name);
    		if ('width' in $$new_props) $$invalidate(0, width = $$new_props.width);
    		if ('height' in $$new_props) $$invalidate(1, height = $$new_props.height);
    		if ('focusable' in $$new_props) $$invalidate(2, focusable = $$new_props.focusable);
    		if ('style' in $$new_props) $$invalidate(3, style = $$new_props.style);
    	};

    	$$self.$capture_state = () => ({
    		name,
    		width,
    		height,
    		focusable,
    		style,
    		icons,
    		displayIcon
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    		if ('name' in $$props) $$invalidate(6, name = $$new_props.name);
    		if ('width' in $$props) $$invalidate(0, width = $$new_props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$new_props.height);
    		if ('focusable' in $$props) $$invalidate(2, focusable = $$new_props.focusable);
    		if ('style' in $$props) $$invalidate(3, style = $$new_props.style);
    		if ('displayIcon' in $$props) $$invalidate(4, displayIcon = $$new_props.displayIcon);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*name*/ 64) {
    			$$invalidate(4, displayIcon = icons[name]);
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [width, height, focusable, style, displayIcon, $$props, name];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
    			name: 6,
    			width: 0,
    			height: 1,
    			focusable: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$r.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[6] === undefined && !('name' in props)) {
    			console.warn("<Icon> was created without expected prop 'name'");
    		}
    	}

    	get name() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\table\Table-header-usdc.svelte generated by Svelte v3.46.3 */
    const file$o = "src\\table\\Table-header-usdc.svelte";

    // (25:4) {:else}
    function create_else_block$8(ctx) {
    	let div;
    	let fasort;
    	let current;
    	fasort = new FaSort({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasort.$$.fragment);
    			attr_dev(div, "class", "sort-icon dormant svelte-6lt8ov");
    			add_location(div, file$o, 25, 8, 1014);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasort, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasort.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasort.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasort);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(25:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:47) 
    function create_if_block_1$8(ctx) {
    	let div;
    	let fasortup;
    	let current;
    	fasortup = new FaSortUp({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasortup.$$.fragment);
    			attr_dev(div, "class", "sort-icon descend svelte-6lt8ov");
    			add_location(div, file$o, 23, 8, 942);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasortup, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasortup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasortup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasortup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(23:47) ",
    		ctx
    	});

    	return block;
    }

    // (21:4) {#if column.sortDirection === ASCEND }
    function create_if_block$g(ctx) {
    	let div;
    	let fasortdown;
    	let current;
    	fasortdown = new FaSortDown({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasortdown.$$.fragment);
    			attr_dev(div, "class", "sort-icon svelte-6lt8ov");
    			add_location(div, file$o, 21, 8, 840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasortdown, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasortdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasortdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasortdown);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(21:4) {#if column.sortDirection === ASCEND }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div1;
    	let icon;
    	let t0;
    	let div0;
    	let t1_value = /*column*/ ctx[0].displayText + "";
    	let t1;
    	let t2;
    	let current_block_type_index;
    	let if_block;
    	let div1_class_value;
    	let div1_title_value;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: {
    				name: "usdc",
    				style: iconStyle$1,
    				width: "18px",
    				height: "18px"
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$g, create_if_block_1$8, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*column*/ ctx[0].sortDirection === ASCEND) return 0;
    		if (/*column*/ ctx[0].sortDirection === DESCEND) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			if_block.c();
    			attr_dev(div0, "clas", "text");
    			add_location(div0, file$o, 19, 4, 743);
    			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*headerClass*/ ctx[1]) + " svelte-6lt8ov"));
    			attr_dev(div1, "title", div1_title_value = /*column*/ ctx[0].display || '');
    			add_location(div1, file$o, 17, 0, 581);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(icon, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			append_dev(div1, t2);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					div1,
    					"click",
    					function () {
    						if (is_function(/*column*/ ctx[0].clickHandler)) /*column*/ ctx[0].clickHandler.apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*column*/ 1) && t1_value !== (t1_value = /*column*/ ctx[0].displayText + "")) set_data_dev(t1, t1_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}

    			if (!current || dirty & /*headerClass*/ 2 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*headerClass*/ ctx[1]) + " svelte-6lt8ov"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (!current || dirty & /*column*/ 1 && div1_title_value !== (div1_title_value = /*column*/ ctx[0].display || '')) {
    				attr_dev(div1, "title", div1_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const iconStyle$1 = 'margin: 8px 6px 0 0; opacity: 0.4;';

    function instance$q($$self, $$props, $$invalidate) {
    	let headerClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Table_header_usdc', slots, []);
    	let { column } = $$props;
    	const writable_props = ['column'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Table_header_usdc> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    	};

    	$$self.$capture_state = () => ({
    		ASCEND,
    		DESCEND,
    		Icon,
    		FaSortUp,
    		FaSortDown,
    		FaSort,
    		column,
    		iconStyle: iconStyle$1,
    		headerClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('headerClass' in $$props) $$invalidate(1, headerClass = $$props.headerClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*column*/ 1) {
    			$$invalidate(1, headerClass = 'table-header-usdc' + (column.sortDirection === ASCEND ? ' ascend' : '') + (column.sortDirection === DESCEND ? ' descend' : ''));
    		}
    	};

    	return [column, headerClass];
    }

    class Table_header_usdc extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { column: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Table_header_usdc",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[0] === undefined && !('column' in props)) {
    			console.warn("<Table_header_usdc> was created without expected prop 'column'");
    		}
    	}

    	get column() {
    		throw new Error("<Table_header_usdc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Table_header_usdc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\table\Table-header-atlas.svelte generated by Svelte v3.46.3 */
    const file$n = "src\\table\\Table-header-atlas.svelte";

    // (25:4) {:else}
    function create_else_block$7(ctx) {
    	let div;
    	let fasort;
    	let current;
    	fasort = new FaSort({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasort.$$.fragment);
    			attr_dev(div, "class", "sort-icon dormant svelte-s4yt7r");
    			add_location(div, file$n, 25, 8, 1071);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasort, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasort.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasort.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasort);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(25:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:47) 
    function create_if_block_1$7(ctx) {
    	let div;
    	let fasortup;
    	let current;
    	fasortup = new FaSortUp({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasortup.$$.fragment);
    			attr_dev(div, "class", "sort-icon descend svelte-s4yt7r");
    			add_location(div, file$n, 23, 8, 999);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasortup, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasortup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasortup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasortup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(23:47) ",
    		ctx
    	});

    	return block;
    }

    // (21:4) {#if column.sortDirection === ASCEND }
    function create_if_block$f(ctx) {
    	let div;
    	let fasortdown;
    	let current;
    	fasortdown = new FaSortDown({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(fasortdown.$$.fragment);
    			attr_dev(div, "class", "sort-icon svelte-s4yt7r");
    			add_location(div, file$n, 21, 8, 897);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(fasortdown, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fasortdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fasortdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(fasortdown);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(21:4) {#if column.sortDirection === ASCEND }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div1;
    	let icon;
    	let t0;
    	let div0;
    	let t1_value = /*column*/ ctx[0].displayText + "";
    	let t1;
    	let t2;
    	let current_block_type_index;
    	let if_block;
    	let div1_class_value;
    	let div1_title_value;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: {
    				name: "atlas",
    				style: iconStyle,
    				width: "28px",
    				height: "28px"
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$f, create_if_block_1$7, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*column*/ ctx[0].sortDirection === ASCEND) return 0;
    		if (/*column*/ ctx[0].sortDirection === DESCEND) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			if_block.c();
    			attr_dev(div0, "clas", "text");
    			add_location(div0, file$n, 19, 4, 800);
    			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*headerClass*/ ctx[1]) + " svelte-s4yt7r"));
    			attr_dev(div1, "title", div1_title_value = /*column*/ ctx[0].display || '');
    			add_location(div1, file$n, 17, 0, 637);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(icon, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			append_dev(div1, t2);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					div1,
    					"click",
    					function () {
    						if (is_function(/*column*/ ctx[0].clickHandler)) /*column*/ ctx[0].clickHandler.apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*column*/ 1) && t1_value !== (t1_value = /*column*/ ctx[0].displayText + "")) set_data_dev(t1, t1_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}

    			if (!current || dirty & /*headerClass*/ 2 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*headerClass*/ ctx[1]) + " svelte-s4yt7r"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (!current || dirty & /*column*/ 1 && div1_title_value !== (div1_title_value = /*column*/ ctx[0].display || '')) {
    				attr_dev(div1, "title", div1_title_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(icon);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const iconStyle = 'margin: -2px 6px 0 0; opacity: 0.9; background: white; border-radius: 40px; height: 28px;';

    function instance$p($$self, $$props, $$invalidate) {
    	let headerClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Table_header_atlas', slots, []);
    	let { column } = $$props;
    	const writable_props = ['column'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Table_header_atlas> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    	};

    	$$self.$capture_state = () => ({
    		ASCEND,
    		DESCEND,
    		Icon,
    		FaSortUp,
    		FaSortDown,
    		FaSort,
    		column,
    		iconStyle,
    		headerClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('headerClass' in $$props) $$invalidate(1, headerClass = $$props.headerClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*column*/ 1) {
    			$$invalidate(1, headerClass = 'table-header-atlas' + (column.sortDirection === ASCEND ? ' ascend' : '') + (column.sortDirection === DESCEND ? ' descend' : ''));
    		}
    	};

    	return [column, headerClass];
    }

    class Table_header_atlas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { column: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Table_header_atlas",
    			options,
    			id: create_fragment$p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[0] === undefined && !('column' in props)) {
    			console.warn("<Table_header_atlas> was created without expected prop 'column'");
    		}
    	}

    	get column() {
    		throw new Error("<Table_header_atlas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Table_header_atlas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\table\Cell-basic.svelte generated by Svelte v3.46.3 */
    const file$m = "src\\table\\Cell-basic.svelte";

    // (27:0) {:else}
    function create_else_block$6(ctx) {
    	let div;
    	let t;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*val*/ ctx[3]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-ia2vmo"));
    			add_location(div, file$m, 27, 4, 911);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*val*/ 8) set_data_dev(t, /*val*/ ctx[3]);

    			if (dirty & /*cellClass*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-ia2vmo"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(27:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (25:0) {#if column.usePercent}
    function create_if_block$e(ctx) {
    	let div;
    	let percentdisplay;
    	let div_class_value;
    	let current;

    	percentdisplay = new Percent_display$1({
    			props: {
    				className: /*percentClass*/ ctx[1],
    				num: /*val*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(percentdisplay.$$.fragment);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-ia2vmo"));
    			add_location(div, file$m, 25, 4, 814);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(percentdisplay, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const percentdisplay_changes = {};
    			if (dirty & /*percentClass*/ 2) percentdisplay_changes.className = /*percentClass*/ ctx[1];
    			if (dirty & /*val*/ 8) percentdisplay_changes.num = /*val*/ ctx[3];
    			percentdisplay.$set(percentdisplay_changes);

    			if (!current || dirty & /*cellClass*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-ia2vmo"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(percentdisplay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(percentdisplay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(percentdisplay);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(25:0) {#if column.usePercent}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$e, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*column*/ ctx[0].usePercent) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let val;
    	let odd;
    	let cellClass;
    	let percentClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell_basic', slots, []);
    	let { column } = $$props;
    	let { rowNumber } = $$props;
    	let { row } = $$props;
    	let { customClass } = $$props;
    	const simplePercent = { 'aprVWAP': true, 'aprAskUSDC': true };
    	const writable_props = ['column', 'rowNumber', 'row', 'customClass'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cell_basic> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(4, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(5, row = $$props.row);
    		if ('customClass' in $$props) $$invalidate(6, customClass = $$props.customClass);
    	};

    	$$self.$capture_state = () => ({
    		PercentDisplay: Percent_display$1,
    		column,
    		rowNumber,
    		row,
    		customClass,
    		simplePercent,
    		percentClass,
    		odd,
    		cellClass,
    		val
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(4, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(5, row = $$props.row);
    		if ('customClass' in $$props) $$invalidate(6, customClass = $$props.customClass);
    		if ('percentClass' in $$props) $$invalidate(1, percentClass = $$props.percentClass);
    		if ('odd' in $$props) $$invalidate(7, odd = $$props.odd);
    		if ('cellClass' in $$props) $$invalidate(2, cellClass = $$props.cellClass);
    		if ('val' in $$props) $$invalidate(3, val = $$props.val);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*row, column*/ 33) {
    			$$invalidate(3, val = row.data[column.dataName]);
    		}

    		if ($$self.$$.dirty & /*rowNumber*/ 16) {
    			$$invalidate(7, odd = Boolean(rowNumber % 2));
    		}

    		if ($$self.$$.dirty & /*odd, column, customClass*/ 193) {
    			$$invalidate(2, cellClass = 'cell-basic ' + (odd ? 'odd' : 'even') + (column.sortDirection ? ' sorted' : '') + (customClass ? ' ' + customClass : '') + (column.capitalize ? ' capitalize' : ''));
    		}

    		if ($$self.$$.dirty & /*column, customClass*/ 65) {
    			$$invalidate(1, percentClass = simplePercent[column.dataName]
    			? 'simple-table' + (customClass ? ' ' + customClass : '')
    			: 'table' + (customClass ? ' ' + customClass : ''));
    		}
    	};

    	return [column, percentClass, cellClass, val, rowNumber, row, customClass, odd];
    }

    class Cell_basic extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			column: 0,
    			rowNumber: 4,
    			row: 5,
    			customClass: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell_basic",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[0] === undefined && !('column' in props)) {
    			console.warn("<Cell_basic> was created without expected prop 'column'");
    		}

    		if (/*rowNumber*/ ctx[4] === undefined && !('rowNumber' in props)) {
    			console.warn("<Cell_basic> was created without expected prop 'rowNumber'");
    		}

    		if (/*row*/ ctx[5] === undefined && !('row' in props)) {
    			console.warn("<Cell_basic> was created without expected prop 'row'");
    		}

    		if (/*customClass*/ ctx[6] === undefined && !('customClass' in props)) {
    			console.warn("<Cell_basic> was created without expected prop 'customClass'");
    		}
    	}

    	get column() {
    		throw new Error("<Cell_basic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Cell_basic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowNumber() {
    		throw new Error("<Cell_basic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowNumber(value) {
    		throw new Error("<Cell_basic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<Cell_basic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<Cell_basic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customClass() {
    		throw new Error("<Cell_basic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customClass(value) {
    		throw new Error("<Cell_basic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-icons\io\IoLogoUsd.svelte generated by Svelte v3.46.3 */
    const file$l = "node_modules\\svelte-icons\\io\\IoLogoUsd.svelte";

    // (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
    function create_default_slot$5(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M411.387 303.256c-3.119-9.577-7.891-18.561-14.301-26.952-6.422-8.382-14.396-15.826-23.93-22.331-9.539-6.498-20.721-11.63-33.553-15.4-5.143-1.363-14.189-3.506-26.104-6.418-8.516-2.074-16.5-4.2-25.5-6.367V120.065c9 2.396 15.252 6.202 21.926 10.43C324.204 139.535 333.157 155 335.78 176h69.174c-.654-18-4.65-32.76-11.996-46.02-8.07-14.543-18.977-27.024-32.73-36.956-13.75-9.922-30.225-17.49-48.377-22.455C303.967 68.416 297 66.605 288 65.386V32h-64v33.167c-7 1.044-15.148 2.445-22.426 4.25-17.242 4.283-32.388 10.868-45.951 19.764-13.571 8.905-24.352 20.112-32.604 33.627-8.251 13.523-12.312 29.52-12.312 48 0 9.585 1.407 18.993 4.157 28.235 2.752 9.241 7.442 17.967 14.042 26.181 6.603 8.214 15.495 15.658 26.687 22.332 11.183 6.672 24.705 12.064 41.576 16.171 9.287 2.345 18.83 4.534 26.83 6.576v119.586c-11-2.919-21.889-7.399-30.678-13.479-9.17-6.327-16.066-13.953-21.198-23.884-4.779-9.229-7.073-20.526-7.407-32.526H96c.695 21 5.25 39.494 13.672 55.371 8.799 16.604 20.533 29.96 35.204 40.562 14.662 10.613 31.393 18.356 51.198 23.491 8.885 2.304 18.926 3.96 27.926 5.23V480h64v-34.54c10-1.069 18.957-2.69 28.527-4.879 18.701-4.273 35.645-11.036 50.316-20.276 14.662-9.24 26.621-21.128 35.611-35.681 8.98-14.541 13.545-32.085 13.545-52.619.001-9.578-1.501-19.164-4.612-28.749zM224 209.699c-12-3.743-23.912-9.088-32.051-16.048-8.621-7.355-12.673-17.534-12.673-30.545 0-9.241 2.414-16.94 7.004-23.102 4.58-6.161 9.912-11.038 16.88-14.631 6.18-3.189 13.84-5.565 20.84-7.138v91.464zm118.902 149.772c-2.939 6.673-7.699 12.576-14.303 17.711-6.602 5.133-15.744 9.328-26.377 12.577-4.5 1.378-8.223 2.444-14.223 3.236v-107.11c10 2.624 18.18 5.332 26.326 8.131 8.062 2.744 15.748 7.443 22.537 14.116 6.785 6.676 10.309 17.03 10.309 31.06.001 6.85-1.337 13.605-4.269 20.279z");
    			add_location(path, file$l, 4, 10, 153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let iconbase;
    	let current;
    	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

    	let iconbase_props = {
    		$$slots: { default: [create_default_slot$5] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
    	}

    	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(iconbase.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconbase, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const iconbase_changes = (dirty & /*$$props*/ 1)
    			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
    			: {};

    			if (dirty & /*$$scope*/ 2) {
    				iconbase_changes.$$scope = { dirty, ctx };
    			}

    			iconbase.$set(iconbase_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbase.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconbase.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconbase, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IoLogoUsd', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$capture_state = () => ({ IconBase });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class IoLogoUsd extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IoLogoUsd",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    const formatAtlas = num => !num
        ? '0' 
        : Number(num).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });

    const formatUSDC = num => !num
        ? '0'
        // : new Intl.NumberFormat('en-US', usdFormat).format(Number(num));
        : Number(num).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

    /* src\table\Cell-ask-bid.svelte generated by Svelte v3.46.3 */
    const file$k = "src\\table\\Cell-ask-bid.svelte";

    // (50:37) 
    function create_if_block_1$6(ctx) {
    	let div8;
    	let div3;
    	let div2;
    	let div0;
    	let t1;
    	let t2;
    	let div1;
    	let t3_value = formatUSDC(/*askUSDC*/ ctx[6]) + "";
    	let t3;
    	let t4;
    	let div7;
    	let div6;
    	let div4;
    	let t6;
    	let t7;
    	let div5;
    	let t8_value = formatUSDC(/*bidUSDC*/ ctx[5]) + "";
    	let t8;
    	let div8_class_value;
    	let if_block0 = /*customClass*/ ctx[1] && create_if_block_3$1(ctx);
    	let if_block1 = /*customClass*/ ctx[1] && create_if_block_2$2(ctx);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Ask";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			div1 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			div7 = element("div");
    			div6 = element("div");
    			div4 = element("div");
    			div4.textContent = "Bid";
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			div5 = element("div");
    			t8 = text(t8_value);
    			attr_dev(div0, "class", "market-position svelte-7bjqiu");
    			add_location(div0, file$k, 53, 16, 1932);
    			attr_dev(div1, "class", "price-number svelte-7bjqiu");
    			add_location(div1, file$k, 55, 16, 2062);
    			attr_dev(div2, "class", "ask-bid-cell primary svelte-7bjqiu");
    			add_location(div2, file$k, 52, 12, 1880);
    			attr_dev(div3, "class", "ask-row svelte-7bjqiu");
    			add_location(div3, file$k, 51, 8, 1845);
    			attr_dev(div4, "class", "market-position svelte-7bjqiu");
    			add_location(div4, file$k, 60, 16, 2248);
    			attr_dev(div5, "class", "price-number svelte-7bjqiu");
    			add_location(div5, file$k, 62, 16, 2378);
    			attr_dev(div6, "class", "ask-bid-cell primary svelte-7bjqiu");
    			add_location(div6, file$k, 59, 12, 2196);
    			attr_dev(div7, "class", "bid-row svelte-7bjqiu");
    			add_location(div7, file$k, 58, 8, 2161);
    			attr_dev(div8, "class", div8_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-7bjqiu"));
    			add_location(div8, file$k, 50, 4, 1812);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, t3);
    			append_dev(div8, t4);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div4);
    			append_dev(div6, t6);
    			if (if_block1) if_block1.m(div6, null);
    			append_dev(div6, t7);
    			append_dev(div6, div5);
    			append_dev(div5, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (/*customClass*/ ctx[1]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					if_block0.m(div2, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*askUSDC*/ 64 && t3_value !== (t3_value = formatUSDC(/*askUSDC*/ ctx[6]) + "")) set_data_dev(t3, t3_value);

    			if (/*customClass*/ ctx[1]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_2$2(ctx);
    					if_block1.c();
    					if_block1.m(div6, t7);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*bidUSDC*/ 32 && t8_value !== (t8_value = formatUSDC(/*bidUSDC*/ ctx[5]) + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*cellClass*/ 4 && div8_class_value !== (div8_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-7bjqiu"))) {
    				attr_dev(div8, "class", div8_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(50:37) ",
    		ctx
    	});

    	return block;
    }

    // (27:0) {#if column.currency === 'atlas'}
    function create_if_block$d(ctx) {
    	let div14;
    	let div6;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let t2_value = formatAtlas(/*askATLAS*/ ctx[8]) + "";
    	let t2;
    	let t3;
    	let div5;
    	let div3;
    	let t5;
    	let div4;
    	let t6_value = formatUSDC(/*askAtlasEq*/ ctx[4]) + "";
    	let t6;
    	let t7;
    	let div13;
    	let div9;
    	let div7;
    	let t9;
    	let div8;
    	let t10_value = formatAtlas(/*bidATLAS*/ ctx[7]) + "";
    	let t10;
    	let t11;
    	let div12;
    	let div10;
    	let t13;
    	let div11;
    	let t14_value = formatUSDC(/*bidAtlasEq*/ ctx[3]) + "";
    	let t14;
    	let div14_class_value;

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			div6 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Ask";
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div5 = element("div");
    			div3 = element("div");
    			div3.textContent = "$";
    			t5 = space();
    			div4 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			div13 = element("div");
    			div9 = element("div");
    			div7 = element("div");
    			div7.textContent = "Bid";
    			t9 = space();
    			div8 = element("div");
    			t10 = text(t10_value);
    			t11 = space();
    			div12 = element("div");
    			div10 = element("div");
    			div10.textContent = "$";
    			t13 = space();
    			div11 = element("div");
    			t14 = text(t14_value);
    			attr_dev(div0, "class", "market-position svelte-7bjqiu");
    			add_location(div0, file$k, 30, 16, 972);
    			attr_dev(div1, "class", "price-number svelte-7bjqiu");
    			add_location(div1, file$k, 31, 16, 1028);
    			attr_dev(div2, "class", "ask-bid-cell primary svelte-7bjqiu");
    			add_location(div2, file$k, 29, 12, 920);
    			attr_dev(div3, "class", "currency-mark svelte-7bjqiu");
    			add_location(div3, file$k, 34, 16, 1171);
    			attr_dev(div4, "class", "price-number svelte-7bjqiu");
    			add_location(div4, file$k, 35, 16, 1223);
    			attr_dev(div5, "class", "ask-bid-cell converted svelte-7bjqiu");
    			add_location(div5, file$k, 33, 12, 1117);
    			attr_dev(div6, "class", "ask-row svelte-7bjqiu");
    			add_location(div6, file$k, 28, 8, 885);
    			attr_dev(div7, "class", "market-position svelte-7bjqiu");
    			add_location(div7, file$k, 40, 16, 1412);
    			attr_dev(div8, "class", "price-number svelte-7bjqiu");
    			add_location(div8, file$k, 41, 16, 1468);
    			attr_dev(div9, "class", "ask-bid-cell primary svelte-7bjqiu");
    			add_location(div9, file$k, 39, 12, 1360);
    			attr_dev(div10, "class", "currency-mark svelte-7bjqiu");
    			add_location(div10, file$k, 44, 16, 1611);
    			attr_dev(div11, "class", "price-number svelte-7bjqiu");
    			add_location(div11, file$k, 45, 16, 1663);
    			attr_dev(div12, "class", "ask-bid-cell converted svelte-7bjqiu");
    			add_location(div12, file$k, 43, 12, 1557);
    			attr_dev(div13, "class", "bid-row svelte-7bjqiu");
    			add_location(div13, file$k, 38, 8, 1325);
    			attr_dev(div14, "class", div14_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-7bjqiu"));
    			add_location(div14, file$k, 27, 4, 852);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div6);
    			append_dev(div6, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div5, t5);
    			append_dev(div5, div4);
    			append_dev(div4, t6);
    			append_dev(div14, t7);
    			append_dev(div14, div13);
    			append_dev(div13, div9);
    			append_dev(div9, div7);
    			append_dev(div9, t9);
    			append_dev(div9, div8);
    			append_dev(div8, t10);
    			append_dev(div13, t11);
    			append_dev(div13, div12);
    			append_dev(div12, div10);
    			append_dev(div12, t13);
    			append_dev(div12, div11);
    			append_dev(div11, t14);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*askATLAS*/ 256 && t2_value !== (t2_value = formatAtlas(/*askATLAS*/ ctx[8]) + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*askAtlasEq*/ 16 && t6_value !== (t6_value = formatUSDC(/*askAtlasEq*/ ctx[4]) + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*bidATLAS*/ 128 && t10_value !== (t10_value = formatAtlas(/*bidATLAS*/ ctx[7]) + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*bidAtlasEq*/ 8 && t14_value !== (t14_value = formatUSDC(/*bidAtlasEq*/ ctx[3]) + "")) set_data_dev(t14, t14_value);

    			if (dirty & /*cellClass*/ 4 && div14_class_value !== (div14_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-7bjqiu"))) {
    				attr_dev(div14, "class", div14_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(27:0) {#if column.currency === 'atlas'}",
    		ctx
    	});

    	return block;
    }

    // (55:16) {#if customClass}
    function create_if_block_3$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "$";
    			attr_dev(div, "class", "currency-mark svelte-7bjqiu");
    			add_location(div, file$k, 54, 33, 2005);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(55:16) {#if customClass}",
    		ctx
    	});

    	return block;
    }

    // (62:16) {#if customClass}
    function create_if_block_2$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "$";
    			attr_dev(div, "class", "currency-mark svelte-7bjqiu");
    			add_location(div, file$k, 61, 33, 2321);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(62:16) {#if customClass}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*column*/ ctx[0].currency === 'atlas') return create_if_block$d;
    		if (/*column*/ ctx[0].currency === 'usdc') return create_if_block_1$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let askATLAS;
    	let bidATLAS;
    	let askUSDC;
    	let bidUSDC;
    	let askAtlasEq;
    	let bidAtlasEq;
    	let val;
    	let odd;
    	let cellClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell_ask_bid', slots, []);
    	let { column } = $$props;
    	let { rowNumber } = $$props;
    	let { row } = $$props;
    	let { customClass } = $$props;
    	const writable_props = ['column', 'rowNumber', 'row', 'customClass'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cell_ask_bid> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(9, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(10, row = $$props.row);
    		if ('customClass' in $$props) $$invalidate(1, customClass = $$props.customClass);
    	};

    	$$self.$capture_state = () => ({
    		IoLogoUsd,
    		formatAtlas,
    		formatUSDC,
    		column,
    		rowNumber,
    		row,
    		customClass,
    		odd,
    		cellClass,
    		val,
    		bidAtlasEq,
    		askAtlasEq,
    		bidUSDC,
    		askUSDC,
    		bidATLAS,
    		askATLAS
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(9, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(10, row = $$props.row);
    		if ('customClass' in $$props) $$invalidate(1, customClass = $$props.customClass);
    		if ('odd' in $$props) $$invalidate(11, odd = $$props.odd);
    		if ('cellClass' in $$props) $$invalidate(2, cellClass = $$props.cellClass);
    		if ('val' in $$props) val = $$props.val;
    		if ('bidAtlasEq' in $$props) $$invalidate(3, bidAtlasEq = $$props.bidAtlasEq);
    		if ('askAtlasEq' in $$props) $$invalidate(4, askAtlasEq = $$props.askAtlasEq);
    		if ('bidUSDC' in $$props) $$invalidate(5, bidUSDC = $$props.bidUSDC);
    		if ('askUSDC' in $$props) $$invalidate(6, askUSDC = $$props.askUSDC);
    		if ('bidATLAS' in $$props) $$invalidate(7, bidATLAS = $$props.bidATLAS);
    		if ('askATLAS' in $$props) $$invalidate(8, askATLAS = $$props.askATLAS);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*row*/ 1024) {
    			$$invalidate(8, askATLAS = row.data.askATLAS);
    		}

    		if ($$self.$$.dirty & /*row*/ 1024) {
    			$$invalidate(7, bidATLAS = row.data.bidATLAS);
    		}

    		if ($$self.$$.dirty & /*row*/ 1024) {
    			$$invalidate(6, askUSDC = row.data.askUSDC);
    		}

    		if ($$self.$$.dirty & /*row*/ 1024) {
    			$$invalidate(5, bidUSDC = row.data.bidUSDC);
    		}

    		if ($$self.$$.dirty & /*row*/ 1024) {
    			$$invalidate(4, askAtlasEq = row.data.askAtlasEq);
    		}

    		if ($$self.$$.dirty & /*row*/ 1024) {
    			$$invalidate(3, bidAtlasEq = row.data.bidAtlasEq);
    		}

    		if ($$self.$$.dirty & /*row, column*/ 1025) {
    			val = row.data[column.dataName];
    		}

    		if ($$self.$$.dirty & /*rowNumber*/ 512) {
    			$$invalidate(11, odd = Boolean(rowNumber % 2));
    		}

    		if ($$self.$$.dirty & /*odd, customClass, column*/ 2051) {
    			$$invalidate(2, cellClass = 'ask-bid-grid ' + (odd ? 'odd' : 'even') + (customClass ? ' ' + customClass : '') + (column.sortDirection ? ' sorted' : '') + (column.currency === 'usdc' ? ' usdc' : ''));
    		}
    	};

    	return [
    		column,
    		customClass,
    		cellClass,
    		bidAtlasEq,
    		askAtlasEq,
    		bidUSDC,
    		askUSDC,
    		bidATLAS,
    		askATLAS,
    		rowNumber,
    		row,
    		odd
    	];
    }

    class Cell_ask_bid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
    			column: 0,
    			rowNumber: 9,
    			row: 10,
    			customClass: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell_ask_bid",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[0] === undefined && !('column' in props)) {
    			console.warn("<Cell_ask_bid> was created without expected prop 'column'");
    		}

    		if (/*rowNumber*/ ctx[9] === undefined && !('rowNumber' in props)) {
    			console.warn("<Cell_ask_bid> was created without expected prop 'rowNumber'");
    		}

    		if (/*row*/ ctx[10] === undefined && !('row' in props)) {
    			console.warn("<Cell_ask_bid> was created without expected prop 'row'");
    		}

    		if (/*customClass*/ ctx[1] === undefined && !('customClass' in props)) {
    			console.warn("<Cell_ask_bid> was created without expected prop 'customClass'");
    		}
    	}

    	get column() {
    		throw new Error("<Cell_ask_bid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Cell_ask_bid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowNumber() {
    		throw new Error("<Cell_ask_bid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowNumber(value) {
    		throw new Error("<Cell_ask_bid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<Cell_ask_bid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<Cell_ask_bid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customClass() {
    		throw new Error("<Cell_ask_bid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customClass(value) {
    		throw new Error("<Cell_ask_bid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement$1(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement$1(placement) {
      return placement.split('-')[0];
    }

    var max = Math.max;
    var min = Math.min;
    var round = Math.round;

    function getBoundingClientRect(element, includeScale) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      var rect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (isHTMLElement(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`

        if (offsetWidth > 0) {
          scaleX = round(rect.width) / offsetWidth || 1;
        }

        if (offsetHeight > 0) {
          scaleY = round(rect.height) / offsetHeight || 1;
        }
      }

      return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
      var isIE = navigator.userAgent.indexOf('Trident') !== -1;

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }
    function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement$1(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (process.env.NODE_ENV !== "production") {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {
        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;

      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref4.x;
      y = _ref4.y;

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      if (process.env.NODE_ENV !== "production") {
        var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }

      var commonStyles = {
        placement: getBasePlacement$1(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement$1(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement$1(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;

        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement$1(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement$1(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement$1(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement$1(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement$1(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement$1(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis) {
        var _offsetModifierState$;

        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = offset + overflow[mainSide];
        var max$1 = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _offsetModifierState$2;

        var _mainSide = mainAxis === 'x' ? top : left;

        var _altSide = mainAxis === 'x' ? bottom : right;

        var _offset = popperOffsets[altAxis];

        var _len = altAxis === 'y' ? 'height' : 'width';

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce$1(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function format(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }

    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function (value, index, self) {
          return self.indexOf(value) === index;
        }).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }

              break;

            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }

              break;

            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }

              break;

            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'effect':
              if (modifier.effect != null && typeof modifier.effect !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'requires':
              if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }

              break;

            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }

              break;

            case 'options':
            case 'data':
              break;

            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }

          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }

    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);

        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason

            if (process.env.NODE_ENV !== "production") {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);

              if (getBasePlacement$1(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });

                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }

              var _getComputedStyle = getComputedStyle$1(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer


              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }

            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              if (process.env.NODE_ENV !== "production") {
                console.error(INVALID_ELEMENT_ERROR);
              }

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;

            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (process.env.NODE_ENV !== "production") {
                __debug_loops__ += 1;

                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /**!
    * tippy.js v6.3.7
    * (c) 2017-2021 atomiks
    * MIT License
    */
    var BOX_CLASS = "tippy-box";
    var CONTENT_CLASS = "tippy-content";
    var BACKDROP_CLASS = "tippy-backdrop";
    var ARROW_CLASS = "tippy-arrow";
    var SVG_ARROW_CLASS = "tippy-svg-arrow";
    var TOUCH_OPTIONS = {
      passive: true,
      capture: true
    };
    var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
      return document.body;
    };

    function hasOwnProperty(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function getValueAtIndexOrReturn(value, index, defaultValue) {
      if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
      }

      return value;
    }
    function isType(value, type) {
      var str = {}.toString.call(value);
      return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
      return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce(fn, ms) {
      // Avoid wrapping in `setTimeout` if ms is 0 anyway
      if (ms === 0) {
        return fn;
      }

      var timeout;
      return function (arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          fn(arg);
        }, ms);
      };
    }
    function removeProperties(obj, keys) {
      var clone = Object.assign({}, obj);
      keys.forEach(function (key) {
        delete clone[key];
      });
      return clone;
    }
    function splitBySpaces(value) {
      return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
      return [].concat(value);
    }
    function pushIfUnique(arr, value) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    function unique(arr) {
      return arr.filter(function (item, index) {
        return arr.indexOf(item) === index;
      });
    }
    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }
    function arrayFrom(value) {
      return [].slice.call(value);
    }
    function removeUndefinedProps(obj) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (obj[key] !== undefined) {
          acc[key] = obj[key];
        }

        return acc;
      }, {});
    }

    function div() {
      return document.createElement('div');
    }
    function isElement(value) {
      return ['Element', 'Fragment'].some(function (type) {
        return isType(value, type);
      });
    }
    function isNodeList(value) {
      return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
      return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
      return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
      if (isElement(value)) {
        return [value];
      }

      if (isNodeList(value)) {
        return arrayFrom(value);
      }

      if (Array.isArray(value)) {
        return value;
      }

      return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
      els.forEach(function (el) {
        if (el) {
          el.style.transitionDuration = value + "ms";
        }
      });
    }
    function setVisibilityState(els, state) {
      els.forEach(function (el) {
        if (el) {
          el.setAttribute('data-state', state);
        }
      });
    }
    function getOwnerDocument(elementOrElements) {
      var _element$ownerDocumen;

      var _normalizeToArray = normalizeToArray(elementOrElements),
          element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


      return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
      var clientX = event.clientX,
          clientY = event.clientY;
      return popperTreeData.every(function (_ref) {
        var popperRect = _ref.popperRect,
            popperState = _ref.popperState,
            props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;

        if (!offsetData) {
          return true;
        }

        var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
        var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
      });
    }
    function updateTransitionEndListener(box, action, listener) {
      var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
      // `webkitTransitionEnd`...

      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        box[method](event, listener);
      });
    }
    /**
     * Compared to xxx.contains, this function works for dom structures with shadow
     * dom
     */

    function actualContains(parent, child) {
      var target = child;

      while (target) {
        var _target$getRootNode;

        if (parent.contains(target)) {
          return true;
        }

        target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
      }

      return false;
    }

    var currentInput = {
      isTouch: false
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
      if (currentInput.isTouch) {
        return;
      }

      currentInput.isTouch = true;

      if (window.performance) {
        document.addEventListener('mousemove', onDocumentMouseMove);
      }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
      var now = performance.now();

      if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener('mousemove', onDocumentMouseMove);
      }

      lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
      var activeElement = document.activeElement;

      if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;

        if (activeElement.blur && !instance.state.isVisible) {
          activeElement.blur();
        }
      }
    }
    function bindGlobalEventListeners() {
      document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
      window.addEventListener('blur', onWindowBlur);
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var isIE11 = isBrowser ? // @ts-ignore
    !!window.msCrypto : false;

    function createMemoryLeakWarning(method) {
      var txt = method === 'destroy' ? 'n already-' : ' ';
      return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
    }
    function clean(value) {
      var spacesAndTabs = /[ \t]{2,}/g;
      var lineStartWithSpaces = /^[ \t]*/gm;
      return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
    }

    function getDevMessage(message) {
      return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
    }

    function getFormattedMessage(message) {
      return [getDevMessage(message), // title
      'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
      'line-height: 1.5', // footer
      'color: #a6a095;'];
    } // Assume warnings and errors never have the same message

    var visitedMessages;

    if (process.env.NODE_ENV !== "production") {
      resetVisitedMessages();
    }

    function resetVisitedMessages() {
      visitedMessages = new Set();
    }
    function warnWhen(condition, message) {
      if (condition && !visitedMessages.has(message)) {
        var _console;

        visitedMessages.add(message);

        (_console = console).warn.apply(_console, getFormattedMessage(message));
      }
    }
    function errorWhen(condition, message) {
      if (condition && !visitedMessages.has(message)) {
        var _console2;

        visitedMessages.add(message);

        (_console2 = console).error.apply(_console2, getFormattedMessage(message));
      }
    }
    function validateTargets(targets) {
      var didPassFalsyValue = !targets;
      var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
      errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
      errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
    }

    var pluginProps = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    };
    var renderProps = {
      allowHTML: false,
      animation: 'fade',
      arrow: true,
      content: '',
      inertia: false,
      maxWidth: 350,
      role: 'tooltip',
      theme: '',
      zIndex: 9999
    };
    var defaultProps = Object.assign({
      appendTo: TIPPY_DEFAULT_APPEND_TO,
      aria: {
        content: 'auto',
        expanded: 'auto'
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: '',
      offset: [0, 10],
      onAfterUpdate: function onAfterUpdate() {},
      onBeforeUpdate: function onBeforeUpdate() {},
      onCreate: function onCreate() {},
      onDestroy: function onDestroy() {},
      onHidden: function onHidden() {},
      onHide: function onHide() {},
      onMount: function onMount() {},
      onShow: function onShow() {},
      onShown: function onShown() {},
      onTrigger: function onTrigger() {},
      onUntrigger: function onUntrigger() {},
      onClickOutside: function onClickOutside() {},
      placement: 'top',
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: 'mouseenter focus',
      triggerTarget: null
    }, pluginProps, renderProps);
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== "production") {
        validateProps(partialProps, []);
      }

      var keys = Object.keys(partialProps);
      keys.forEach(function (key) {
        defaultProps[key] = partialProps[key];
      });
    };
    function getExtendedPassedProps(passedProps) {
      var plugins = passedProps.plugins || [];
      var pluginProps = plugins.reduce(function (acc, plugin) {
        var name = plugin.name,
            defaultValue = plugin.defaultValue;

        if (name) {
          var _name;

          acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
        }

        return acc;
      }, {});
      return Object.assign({}, passedProps, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
      var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
      }))) : defaultKeys;
      var props = propKeys.reduce(function (acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

        if (!valueAsString) {
          return acc;
        }

        if (key === 'content') {
          acc[key] = valueAsString;
        } else {
          try {
            acc[key] = JSON.parse(valueAsString);
          } catch (e) {
            acc[key] = valueAsString;
          }
        }

        return acc;
      }, {});
      return props;
    }
    function evaluateProps(reference, props) {
      var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [reference])
      }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
      out.aria = Object.assign({}, defaultProps.aria, out.aria);
      out.aria = {
        expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
        content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
      };
      return out;
    }
    function validateProps(partialProps, plugins) {
      if (partialProps === void 0) {
        partialProps = {};
      }

      if (plugins === void 0) {
        plugins = [];
      }

      var keys = Object.keys(partialProps);
      keys.forEach(function (prop) {
        var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
        var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

        if (didPassUnknownProp) {
          didPassUnknownProp = plugins.filter(function (plugin) {
            return plugin.name === prop;
          }).length === 0;
        }

        warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
      });
    }

    var innerHTML = function innerHTML() {
      return 'innerHTML';
    };

    function dangerouslySetInnerHTML(element, html) {
      element[innerHTML()] = html;
    }

    function createArrowElement(value) {
      var arrow = div();

      if (value === true) {
        arrow.className = ARROW_CLASS;
      } else {
        arrow.className = SVG_ARROW_CLASS;

        if (isElement(value)) {
          arrow.appendChild(value);
        } else {
          dangerouslySetInnerHTML(arrow, value);
        }
      }

      return arrow;
    }

    function setContent(content, props) {
      if (isElement(props.content)) {
        dangerouslySetInnerHTML(content, '');
        content.appendChild(props.content);
      } else if (typeof props.content !== 'function') {
        if (props.allowHTML) {
          dangerouslySetInnerHTML(content, props.content);
        } else {
          content.textContent = props.content;
        }
      }
    }
    function getChildren(popper) {
      var box = popper.firstElementChild;
      var boxChildren = arrayFrom(box.children);
      return {
        box: box,
        content: boxChildren.find(function (node) {
          return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function (node) {
          return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function (node) {
          return node.classList.contains(BACKDROP_CLASS);
        })
      };
    }
    function render(instance) {
      var popper = div();
      var box = div();
      box.className = BOX_CLASS;
      box.setAttribute('data-state', 'hidden');
      box.setAttribute('tabindex', '-1');
      var content = div();
      content.className = CONTENT_CLASS;
      content.setAttribute('data-state', 'hidden');
      setContent(content, instance.props);
      popper.appendChild(box);
      box.appendChild(content);
      onUpdate(instance.props, instance.props);

      function onUpdate(prevProps, nextProps) {
        var _getChildren = getChildren(popper),
            box = _getChildren.box,
            content = _getChildren.content,
            arrow = _getChildren.arrow;

        if (nextProps.theme) {
          box.setAttribute('data-theme', nextProps.theme);
        } else {
          box.removeAttribute('data-theme');
        }

        if (typeof nextProps.animation === 'string') {
          box.setAttribute('data-animation', nextProps.animation);
        } else {
          box.removeAttribute('data-animation');
        }

        if (nextProps.inertia) {
          box.setAttribute('data-inertia', '');
        } else {
          box.removeAttribute('data-inertia');
        }

        box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

        if (nextProps.role) {
          box.setAttribute('role', nextProps.role);
        } else {
          box.removeAttribute('role');
        }

        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
          setContent(content, instance.props);
        }

        if (nextProps.arrow) {
          if (!arrow) {
            box.appendChild(createArrowElement(nextProps.arrow));
          } else if (prevProps.arrow !== nextProps.arrow) {
            box.removeChild(arrow);
            box.appendChild(createArrowElement(nextProps.arrow));
          }
        } else if (arrow) {
          box.removeChild(arrow);
        }
      }

      return {
        popper: popper,
        onUpdate: onUpdate
      };
    } // Runtime check to identify if the render function is the default one; this
    // way we can apply default CSS transitions logic and it can be tree-shaken away

    render.$$tippy = true;

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
      var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
      // 🔒 Private members
      // ===========================================================================

      var showTimeout;
      var hideTimeout;
      var scheduleHideAnimationFrame;
      var isVisibleFromClick = false;
      var didHideDueToDocumentMouseDown = false;
      var didTouchMove = false;
      var ignoreOnFirstUpdate = false;
      var lastTriggerEvent;
      var currentTransitionEndListener;
      var onFirstUpdate;
      var listeners = [];
      var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
      var currentTarget; // ===========================================================================
      // 🔑 Public members
      // ===========================================================================

      var id = idCounter++;
      var popperInstance = null;
      var plugins = unique(props.plugins);
      var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      };
      var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
      }; // TODO: Investigate why this early return causes a TDZ error in the tests —
      // it doesn't seem to happen in the browser

      /* istanbul ignore if */

      if (!props.render) {
        if (process.env.NODE_ENV !== "production") {
          errorWhen(true, 'render() function has not been supplied.');
        }

        return instance;
      } // ===========================================================================
      // Initial mutations
      // ===========================================================================


      var _props$render = props.render(instance),
          popper = _props$render.popper,
          onUpdate = _props$render.onUpdate;

      popper.setAttribute('data-tippy-root', '');
      popper.id = "tippy-" + instance.id;
      instance.popper = popper;
      reference._tippy = instance;
      popper._tippy = instance;
      var pluginsHooks = plugins.map(function (plugin) {
        return plugin.fn(instance);
      });
      var hasAriaExpanded = reference.hasAttribute('aria-expanded');
      addListeners();
      handleAriaExpandedAttribute();
      handleStyles();
      invokeHook('onCreate', [instance]);

      if (props.showOnCreate) {
        scheduleShow();
      } // Prevent a tippy with a delay from hiding if the cursor left then returned
      // before it started hiding


      popper.addEventListener('mouseenter', function () {
        if (instance.props.interactive && instance.state.isVisible) {
          instance.clearDelayTimeouts();
        }
      });
      popper.addEventListener('mouseleave', function () {
        if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
          getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        }
      });
      return instance; // ===========================================================================
      // 🔒 Private methods
      // ===========================================================================

      function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [touch, 0];
      }

      function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === 'hold';
      }

      function getIsDefaultRenderFn() {
        var _instance$props$rende;

        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
      }

      function getCurrentTarget() {
        return currentTarget || reference;
      }

      function getDocument() {
        var parent = getCurrentTarget().parentNode;
        return parent ? getOwnerDocument(parent) : document;
      }

      function getDefaultTemplateChildren() {
        return getChildren(popper);
      }

      function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
          return 0;
        }

        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
      }

      function handleStyles(fromHide) {
        if (fromHide === void 0) {
          fromHide = false;
        }

        popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
        popper.style.zIndex = "" + instance.props.zIndex;
      }

      function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
          shouldInvokePropsHook = true;
        }

        pluginsHooks.forEach(function (pluginHooks) {
          if (pluginHooks[hook]) {
            pluginHooks[hook].apply(pluginHooks, args);
          }
        });

        if (shouldInvokePropsHook) {
          var _instance$props;

          (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
      }

      function handleAriaContentAttribute() {
        var aria = instance.props.aria;

        if (!aria.content) {
          return;
        }

        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          var currentValue = node.getAttribute(attr);

          if (instance.state.isVisible) {
            node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
          } else {
            var nextValue = currentValue && currentValue.replace(id, '').trim();

            if (nextValue) {
              node.setAttribute(attr, nextValue);
            } else {
              node.removeAttribute(attr);
            }
          }
        });
      }

      function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) {
          return;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          if (instance.props.interactive) {
            node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
          } else {
            node.removeAttribute('aria-expanded');
          }
        });
      }

      function cleanupInteractiveMouseListeners() {
        getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
          return listener !== debouncedOnMouseMove;
        });
      }

      function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if (currentInput.isTouch) {
          if (didTouchMove || event.type === 'mousedown') {
            return;
          }
        }

        var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

        if (instance.props.interactive && actualContains(popper, actualTarget)) {
          return;
        } // Clicked on the event listeners target


        if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
          return actualContains(el, actualTarget);
        })) {
          if (currentInput.isTouch) {
            return;
          }

          if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
            return;
          }
        } else {
          invokeHook('onClickOutside', [instance, event]);
        }

        if (instance.props.hideOnClick === true) {
          instance.clearDelayTimeouts();
          instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
          // currentTarget. This lets a tippy with `focus` trigger know that it
          // should not show

          didHideDueToDocumentMouseDown = true;
          setTimeout(function () {
            didHideDueToDocumentMouseDown = false;
          }); // The listener gets added in `scheduleShow()`, but this may be hiding it
          // before it shows, and hide()'s early bail-out behavior can prevent it
          // from being cleaned up

          if (!instance.state.isMounted) {
            removeDocumentPress();
          }
        }
      }

      function onTouchMove() {
        didTouchMove = true;
      }

      function onTouchStart() {
        didTouchMove = false;
      }

      function addDocumentPress() {
        var doc = getDocument();
        doc.addEventListener('mousedown', onDocumentPress, true);
        doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function removeDocumentPress() {
        var doc = getDocument();
        doc.removeEventListener('mousedown', onDocumentPress, true);
        doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function () {
          if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
            callback();
          }
        });
      }

      function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
      }

      function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;

        function listener(event) {
          if (event.target === box) {
            updateTransitionEndListener(box, 'remove', listener);
            callback();
          }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise


        if (duration === 0) {
          return callback();
        }

        updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
        updateTransitionEndListener(box, 'add', listener);
        currentTransitionEndListener = listener;
      }

      function on(eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          node.addEventListener(eventType, handler, options);
          listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
          });
        });
      }

      function addListeners() {
        if (getIsCustomTouchBehavior()) {
          on('touchstart', onTrigger, {
            passive: true
          });
          on('touchend', onMouseLeave, {
            passive: true
          });
        }

        splitBySpaces(instance.props.trigger).forEach(function (eventType) {
          if (eventType === 'manual') {
            return;
          }

          on(eventType, onTrigger);

          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;

            case 'focus':
              on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
              break;

            case 'focusin':
              on('focusout', onBlurOrFocusOut);
              break;
          }
        });
      }

      function removeListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function onTrigger(event) {
        var _lastTriggerEvent;

        var shouldScheduleClickHide = false;

        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
          return;
        }

        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();

        if (!instance.state.isVisible && isMouseEvent(event)) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        } // Toggle show/hide when clicking click-triggered tooltips


        if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
          shouldScheduleClickHide = true;
        } else {
          scheduleShow(event);
        }

        if (event.type === 'click') {
          isVisibleFromClick = !shouldScheduleClickHide;
        }

        if (shouldScheduleClickHide && !wasFocused) {
          scheduleHide(event);
        }
      }

      function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

        if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
          return;
        }

        var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
          var _instance$popperInsta;

          var instance = popper._tippy;
          var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

          if (state) {
            return {
              popperRect: popper.getBoundingClientRect(),
              popperState: state,
              props: props
            };
          }

          return null;
        }).filter(Boolean);

        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
          cleanupInteractiveMouseListeners();
          scheduleHide(event);
        }
      }

      function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

        if (shouldBail) {
          return;
        }

        if (instance.props.interactive) {
          instance.hideWithInteractivity(event);
          return;
        }

        scheduleHide(event);
      }

      function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
          return;
        } // If focus was moved to within the popper


        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
          return;
        }

        scheduleHide(event);
      }

      function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
      }

      function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props,
            popperOptions = _instance$props2.popperOptions,
            placement = _instance$props2.placement,
            offset = _instance$props2.offset,
            getReferenceClientRect = _instance$props2.getReferenceClientRect,
            moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
          getBoundingClientRect: getReferenceClientRect,
          contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
          name: '$$tippy',
          enabled: true,
          phase: 'beforeWrite',
          requires: ['computeStyles'],
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (getIsDefaultRenderFn()) {
              var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                  box = _getDefaultTemplateCh.box;

              ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                if (attr === 'placement') {
                  box.setAttribute('data-placement', state.placement);
                } else {
                  if (state.attributes.popper["data-popper-" + attr]) {
                    box.setAttribute("data-" + attr, '');
                  } else {
                    box.removeAttribute("data-" + attr);
                  }
                }
              });
              state.attributes.popper = {};
            }
          }
        };
        var modifiers = [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: 'flip',
          options: {
            padding: 5
          }
        }, {
          name: 'computeStyles',
          options: {
            adaptive: !moveTransition
          }
        }, tippyModifier];

        if (getIsDefaultRenderFn() && arrow) {
          modifiers.push({
            name: 'arrow',
            options: {
              element: arrow,
              padding: 3
            }
          });
        }

        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
          placement: placement,
          onFirstUpdate: onFirstUpdate,
          modifiers: modifiers
        }));
      }

      function destroyPopperInstance() {
        if (instance.popperInstance) {
          instance.popperInstance.destroy();
          instance.popperInstance = null;
        }
      }

      function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually

        var node = getCurrentTarget();

        if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
          parentNode = node.parentNode;
        } else {
          parentNode = invokeWithArgsOrReturn(appendTo, [node]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions


        if (!parentNode.contains(popper)) {
          parentNode.appendChild(popper);
        }

        instance.state.isMounted = true;
        createPopperInstance();
        /* istanbul ignore else */

        if (process.env.NODE_ENV !== "production") {
          // Accessibility check
          warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
        }
      }

      function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
      }

      function scheduleShow(event) {
        instance.clearDelayTimeouts();

        if (event) {
          invokeHook('onTrigger', [instance, event]);
        }

        addDocumentPress();
        var delay = getDelay(true);

        var _getNormalizedTouchSe = getNormalizedTouchSettings(),
            touchValue = _getNormalizedTouchSe[0],
            touchDelay = _getNormalizedTouchSe[1];

        if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
          delay = touchDelay;
        }

        if (delay) {
          showTimeout = setTimeout(function () {
            instance.show();
          }, delay);
        } else {
          instance.show();
        }
      }

      function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook('onUntrigger', [instance, event]);

        if (!instance.state.isVisible) {
          removeDocumentPress();
          return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.


        if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
          return;
        }

        var delay = getDelay(false);

        if (delay) {
          hideTimeout = setTimeout(function () {
            if (instance.state.isVisible) {
              instance.hide();
            }
          }, delay);
        } else {
          // Fixes a `transitionend` problem when it fires 1 frame too
          // late sometimes, we don't want hide() to be called.
          scheduleHideAnimationFrame = requestAnimationFrame(function () {
            instance.hide();
          });
        }
      } // ===========================================================================
      // 🔑 Public methods
      // ===========================================================================


      function enable() {
        instance.state.isEnabled = true;
      }

      function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
      }

      function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
      }

      function setProps(partialProps) {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== "production") {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
        }

        if (instance.state.isDestroyed) {
          return;
        }

        invokeHook('onBeforeUpdate', [instance, partialProps]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
          ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();

        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
          cleanupInteractiveMouseListeners();
          debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed


        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
          normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
            node.removeAttribute('aria-expanded');
          });
        } else if (nextProps.triggerTarget) {
          reference.removeAttribute('aria-expanded');
        }

        handleAriaExpandedAttribute();
        handleStyles();

        if (onUpdate) {
          onUpdate(prevProps, nextProps);
        }

        if (instance.popperInstance) {
          createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
          // and the nested ones get re-rendered first.
          // https://github.com/atomiks/tippyjs-react/issues/177
          // TODO: find a cleaner / more efficient solution(!)

          getNestedPopperTree().forEach(function (nestedPopper) {
            // React (and other UI libs likely) requires a rAF wrapper as it flushes
            // its work in one
            requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
          });
        }

        invokeHook('onAfterUpdate', [instance, partialProps]);
      }

      function setContent(content) {
        instance.setProps({
          content: content
        });
      }

      function show() {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== "production") {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
        } // Early bail-out


        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
          return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.


        if (getCurrentTarget().hasAttribute('disabled')) {
          return;
        }

        invokeHook('onShow', [instance], false);

        if (instance.props.onShow(instance) === false) {
          return;
        }

        instance.state.isVisible = true;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'visible';
        }

        handleStyles();
        addDocumentPress();

        if (!instance.state.isMounted) {
          popper.style.transition = 'none';
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration


        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh2.box,
              content = _getDefaultTemplateCh2.content;

          setTransitionDuration([box, content], 0);
        }

        onFirstUpdate = function onFirstUpdate() {
          var _instance$popperInsta2;

          if (!instance.state.isVisible || ignoreOnFirstUpdate) {
            return;
          }

          ignoreOnFirstUpdate = true; // reflow

          void popper.offsetHeight;
          popper.style.transition = instance.props.moveTransition;

          if (getIsDefaultRenderFn() && instance.props.animation) {
            var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                _box = _getDefaultTemplateCh3.box,
                _content = _getDefaultTemplateCh3.content;

            setTransitionDuration([_box, _content], duration);
            setVisibilityState([_box, _content], 'visible');
          }

          handleAriaContentAttribute();
          handleAriaExpandedAttribute();
          pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
          // popper has been positioned for the first time

          (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
          invokeHook('onMount', [instance]);

          if (instance.props.animation && getIsDefaultRenderFn()) {
            onTransitionedIn(duration, function () {
              instance.state.isShown = true;
              invokeHook('onShown', [instance]);
            });
          }
        };

        mount();
      }

      function hide() {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== "production") {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
        } // Early bail-out


        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

        if (isAlreadyHidden || isDestroyed || isDisabled) {
          return;
        }

        invokeHook('onHide', [instance], false);

        if (instance.props.onHide(instance) === false) {
          return;
        }

        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;
        isVisibleFromClick = false;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'hidden';
        }

        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles(true);

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh4.box,
              content = _getDefaultTemplateCh4.content;

          if (instance.props.animation) {
            setTransitionDuration([box, content], duration);
            setVisibilityState([box, content], 'hidden');
          }
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();

        if (instance.props.animation) {
          if (getIsDefaultRenderFn()) {
            onTransitionedOut(duration, instance.unmount);
          }
        } else {
          instance.unmount();
        }
      }

      function hideWithInteractivity(event) {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== "production") {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
        }

        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }

      function unmount() {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== "production") {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
        }

        if (instance.state.isVisible) {
          instance.hide();
        }

        if (!instance.state.isMounted) {
          return;
        }

        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible

        getNestedPopperTree().forEach(function (nestedPopper) {
          nestedPopper._tippy.unmount();
        });

        if (popper.parentNode) {
          popper.parentNode.removeChild(popper);
        }

        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance;
        });
        instance.state.isMounted = false;
        invokeHook('onHidden', [instance]);
      }

      function destroy() {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== "production") {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
        }

        if (instance.state.isDestroyed) {
          return;
        }

        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook('onDestroy', [instance]);
      }
    }

    function tippy(targets, optionalProps) {
      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
      /* istanbul ignore else */

      if (process.env.NODE_ENV !== "production") {
        validateTargets(targets);
        validateProps(optionalProps, plugins);
      }

      bindGlobalEventListeners();
      var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
      });
      var elements = getArrayOfElements(targets);
      /* istanbul ignore else */

      if (process.env.NODE_ENV !== "production") {
        var isSingleContentElement = isElement(passedProps.content);
        var isMoreThanOneReferenceElement = elements.length > 1;
        warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
      }

      var instances = elements.reduce(function (acc, reference) {
        var instance = reference && createTippy(reference, passedProps);

        if (instance) {
          acc.push(instance);
        }

        return acc;
      }, []);
      return isElement(targets) ? instances[0] : instances;
    }

    tippy.defaultProps = defaultProps;
    tippy.setDefaultProps = setDefaultProps;
    tippy.currentInput = currentInput;

    // every time the popper is destroyed (i.e. a new target), removing the styles
    // and causing transitions to break for singletons when the console is open, but
    // most notably for non-transform styles being used, `gpuAcceleration: false`.

    Object.assign({}, applyStyles$1, {
      effect: function effect(_ref) {
        var state = _ref.state;
        var initialStyles = {
          popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
          },
          arrow: {
            position: 'absolute'
          },
          reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;

        if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow);
        } // intentionally return no cleanup function
        // return () => { ... }

      }
    });

    tippy.setDefaultProps({
      render: render
    });

    /* src\table\Cell-atlas.svelte generated by Svelte v3.46.3 */
    const file$j = "src\\table\\Cell-atlas.svelte";

    // (57:0) {:else}
    function create_else_block$5(ctx) {
    	let div;
    	let t_value = formatAtlas(/*val*/ ctx[2]) + "";
    	let t;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[1]) + " svelte-17jeuor"));
    			add_location(div, file$j, 57, 4, 1660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*val*/ 4 && t_value !== (t_value = formatAtlas(/*val*/ ctx[2]) + "")) set_data_dev(t, t_value);

    			if (dirty & /*cellClass*/ 2 && div_class_value !== (div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[1]) + " svelte-17jeuor"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(57:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:0) {#if atlasUSDC}
    function create_if_block$c(ctx) {
    	let div;
    	let t_value = formatAtlas(/*val*/ ctx[2]) + "";
    	let t;
    	let div_class_value;
    	let tooltip_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[1] + ' point') + " svelte-17jeuor"));
    			add_location(div, file$j, 53, 4, 1516);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = /*tooltip*/ ctx[4].call(null, div, {
    					.../*tooltipParams*/ ctx[3],
    					content: /*atlasUSDC*/ ctx[0]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*val*/ 4 && t_value !== (t_value = formatAtlas(/*val*/ ctx[2]) + "")) set_data_dev(t, t_value);

    			if (dirty & /*cellClass*/ 2 && div_class_value !== (div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[1] + ' point') + " svelte-17jeuor"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (tooltip_action && is_function(tooltip_action.update) && dirty & /*atlasUSDC*/ 1) tooltip_action.update.call(null, {
    				.../*tooltipParams*/ ctx[3],
    				content: /*atlasUSDC*/ ctx[0]
    			});
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(53:0) {#if atlasUSDC}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*atlasUSDC*/ ctx[0]) return create_if_block$c;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let val;
    	let odd;
    	let cellClass;
    	let askBid;
    	let atlasUSDC;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell_atlas', slots, []);
    	let { column } = $$props;
    	let { rowNumber } = $$props;
    	let { row } = $$props;

    	const composeConversion = (text, val) => {
    		if (!val) {
    			return 0;
    		}

    		return '<span class="market-position">' + text + '</span>' + formatUSDC(Number(val)) + '<span class="currency-mark">USDC</span>';
    	};

    	const tooltipParams = {
    		allowHTML: true,
    		delay: [200, 100],
    		offset: [20, 0],
    		placement: 'top'
    	};

    	function tooltip(node, params) {
    		let tip = tippy(node, params);

    		return {
    			update: newParams => {
    				tip.setProps(newParams);
    			},
    			destroy: () => {
    				tip.destroy();
    			}
    		};
    	}

    	const writable_props = ['column', 'rowNumber', 'row'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cell_atlas> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(5, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(6, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(7, row = $$props.row);
    	};

    	$$self.$capture_state = () => ({
    		formatAtlas,
    		formatUSDC,
    		tippy,
    		column,
    		rowNumber,
    		row,
    		composeConversion,
    		tooltipParams,
    		tooltip,
    		askBid,
    		atlasUSDC,
    		odd,
    		cellClass,
    		val
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(5, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(6, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(7, row = $$props.row);
    		if ('askBid' in $$props) $$invalidate(8, askBid = $$props.askBid);
    		if ('atlasUSDC' in $$props) $$invalidate(0, atlasUSDC = $$props.atlasUSDC);
    		if ('odd' in $$props) $$invalidate(9, odd = $$props.odd);
    		if ('cellClass' in $$props) $$invalidate(1, cellClass = $$props.cellClass);
    		if ('val' in $$props) $$invalidate(2, val = $$props.val);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*row, column*/ 160) {
    			$$invalidate(2, val = row.data[column.dataName]);
    		}

    		if ($$self.$$.dirty & /*rowNumber*/ 64) {
    			$$invalidate(9, odd = Boolean(rowNumber % 2));
    		}

    		if ($$self.$$.dirty & /*odd, column*/ 544) {
    			$$invalidate(1, cellClass = 'market-number ' + (odd ? 'odd' : 'even') + (column.sortDirection ? ' sorted' : ''));
    		}

    		if ($$self.$$.dirty & /*column*/ 32) {
    			$$invalidate(8, askBid = column.dataName === 'askATLAS'
    			? 'Ask'
    			: column.dataName === 'bidATLAS' ? 'Bid' : '');
    		}

    		if ($$self.$$.dirty & /*column, askBid, row*/ 416) {
    			$$invalidate(0, atlasUSDC = column.dataName === 'askATLAS'
    			? composeConversion(askBid, row.data['askAtlasEq'])
    			: column.dataName === 'bidATLAS'
    				? composeConversion(askBid, row.data['bidAtlasEq'])
    				: 0);
    		}
    	};

    	return [
    		atlasUSDC,
    		cellClass,
    		val,
    		tooltipParams,
    		tooltip,
    		column,
    		rowNumber,
    		row,
    		askBid,
    		odd
    	];
    }

    class Cell_atlas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { column: 5, rowNumber: 6, row: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell_atlas",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[5] === undefined && !('column' in props)) {
    			console.warn("<Cell_atlas> was created without expected prop 'column'");
    		}

    		if (/*rowNumber*/ ctx[6] === undefined && !('rowNumber' in props)) {
    			console.warn("<Cell_atlas> was created without expected prop 'rowNumber'");
    		}

    		if (/*row*/ ctx[7] === undefined && !('row' in props)) {
    			console.warn("<Cell_atlas> was created without expected prop 'row'");
    		}
    	}

    	get column() {
    		throw new Error("<Cell_atlas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Cell_atlas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowNumber() {
    		throw new Error("<Cell_atlas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowNumber(value) {
    		throw new Error("<Cell_atlas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<Cell_atlas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<Cell_atlas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-icons\fa\FaExpand.svelte generated by Svelte v3.46.3 */
    const file$i = "node_modules\\svelte-icons\\fa\\FaExpand.svelte";

    // (4:8) <IconBase viewBox="0 0 448 512" {...$$props}>
    function create_default_slot$4(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H64v84c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12zM288 44v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12V56c0-13.3-10.7-24-24-24H300c-6.6 0-12 5.4-12 12zm148 276h-40c-6.6 0-12 5.4-12 12v84h-84c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24V332c0-6.6-5.4-12-12-12zM160 468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6 0-12 5.4-12 12v124c0 13.3 10.7 24 24 24h124c6.6 0 12-5.4 12-12z");
    			add_location(path, file$i, 4, 10, 153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(4:8) <IconBase viewBox=\\\"0 0 448 512\\\" {...$$props}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let iconbase;
    	let current;
    	const iconbase_spread_levels = [{ viewBox: "0 0 448 512" }, /*$$props*/ ctx[0]];

    	let iconbase_props = {
    		$$slots: { default: [create_default_slot$4] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
    		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
    	}

    	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(iconbase.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconbase, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const iconbase_changes = (dirty & /*$$props*/ 1)
    			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
    			: {};

    			if (dirty & /*$$scope*/ 2) {
    				iconbase_changes.$$scope = { dirty, ctx };
    			}

    			iconbase.$set(iconbase_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbase.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconbase.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconbase, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FaExpand', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$capture_state = () => ({ IconBase });

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class FaExpand extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FaExpand",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src\components\Price-ask-bid.svelte generated by Svelte v3.46.3 */
    const file$h = "src\\components\\Price-ask-bid.svelte";

    // (48:0) {#if ship.prices}
    function create_if_block$b(ctx) {
    	let div4;
    	let div1;
    	let t0;
    	let div0;
    	let previous_key = /*askUSDC*/ ctx[8];
    	let t1;
    	let div3;
    	let t2;
    	let div2;
    	let previous_key_1 = /*bidUSDC*/ ctx[7];
    	let div4_class_value;

    	function select_block_type(ctx, dirty) {
    		if (/*conversion*/ ctx[3]) return create_if_block_2$1;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let key_block0 = create_key_block_3(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*conversion*/ ctx[3]) return create_if_block_1$5;
    		return create_else_block$4;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);
    	let key_block1 = create_key_block$1(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div1 = element("div");
    			if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			key_block0.c();
    			t1 = space();
    			div3 = element("div");
    			if_block1.c();
    			t2 = space();
    			div2 = element("div");
    			key_block1.c();
    			attr_dev(div0, "class", "price-usdc svelte-161yoxw");
    			add_location(div0, file$h, 73, 12, 2656);
    			attr_dev(div1, "class", "ship-price svelte-161yoxw");
    			add_location(div1, file$h, 49, 8, 1541);
    			attr_dev(div2, "class", "price-usdc svelte-161yoxw");
    			add_location(div2, file$h, 107, 12, 4222);
    			attr_dev(div3, "class", "ship-price row-2 svelte-161yoxw");
    			add_location(div3, file$h, 83, 8, 3101);
    			attr_dev(div4, "class", div4_class_value = "" + (null_to_empty(/*priceClass*/ ctx[1]) + " svelte-161yoxw"));
    			add_location(div4, file$h, 48, 4, 1507);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			if_block0.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			key_block0.m(div0, null);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			if_block1.m(div3, null);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			key_block1.m(div2, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t0);
    				}
    			}

    			if (dirty & /*askUSDC*/ 256 && safe_not_equal(previous_key, previous_key = /*askUSDC*/ ctx[8])) {
    				group_outros();
    				transition_out(key_block0, 1, 1, noop);
    				check_outros();
    				key_block0 = create_key_block_3(ctx);
    				key_block0.c();
    				transition_in(key_block0);
    				key_block0.m(div0, null);
    			} else {
    				key_block0.p(ctx, dirty);
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t2);
    				}
    			}

    			if (dirty & /*bidUSDC*/ 128 && safe_not_equal(previous_key_1, previous_key_1 = /*bidUSDC*/ ctx[7])) {
    				group_outros();
    				transition_out(key_block1, 1, 1, noop);
    				check_outros();
    				key_block1 = create_key_block$1(ctx);
    				key_block1.c();
    				transition_in(key_block1);
    				key_block1.m(div2, null);
    			} else {
    				key_block1.p(ctx, dirty);
    			}

    			if (dirty & /*priceClass*/ 2 && div4_class_value !== (div4_class_value = "" + (null_to_empty(/*priceClass*/ ctx[1]) + " svelte-161yoxw"))) {
    				attr_dev(div4, "class", div4_class_value);
    			}
    		},
    		i: function intro(local) {
    			transition_in(if_block0);
    			transition_in(key_block0);
    			transition_in(if_block1);
    			transition_in(key_block1);
    		},
    		o: function outro(local) {
    			transition_out(key_block0);
    			transition_out(key_block1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if_block0.d();
    			key_block0.d(detaching);
    			if_block1.d();
    			key_block1.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(48:0) {#if ship.prices}",
    		ctx
    	});

    	return block;
    }

    // (62:12) {:else}
    function create_else_block_1$1(ctx) {
    	let div;
    	let previous_key = /*askATLAS*/ ctx[4];
    	let key_block = create_key_block_5(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			key_block.c();
    			attr_dev(div, "class", "price-atlas svelte-161yoxw");
    			add_location(div, file$h, 62, 16, 2165);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			key_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*askATLAS*/ 16 && safe_not_equal(previous_key, previous_key = /*askATLAS*/ ctx[4])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block_5(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			transition_in(key_block);
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(62:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (52:12) {#if conversion}
    function create_if_block_2$1(ctx) {
    	let div;
    	let previous_key = /*askATLAS*/ ctx[4];
    	let tooltip_action;
    	let mounted;
    	let dispose;
    	let key_block = create_key_block_4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			key_block.c();
    			attr_dev(div, "class", "price-atlas svelte-161yoxw");
    			add_location(div, file$h, 52, 16, 1615);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			key_block.m(div, null);

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = /*tooltip*/ ctx[10].call(null, div, {
    					.../*tooltipParams*/ ctx[9],
    					content: /*askAtlasEq*/ ctx[6]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*askATLAS*/ 16 && safe_not_equal(previous_key, previous_key = /*askATLAS*/ ctx[4])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block_4(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (tooltip_action && is_function(tooltip_action.update) && dirty & /*askAtlasEq*/ 64) tooltip_action.update.call(null, {
    				.../*tooltipParams*/ ctx[9],
    				content: /*askAtlasEq*/ ctx[6]
    			});
    		},
    		i: function intro(local) {
    			transition_in(key_block);
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			key_block.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(52:12) {#if conversion}",
    		ctx
    	});

    	return block;
    }

    // (64:20) {#key askATLAS}
    function create_key_block_5(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = formatAtlas(/*askATLAS*/ ctx[4]) + "";
    	let t2;
    	let t3;
    	let span2;
    	let div_intro;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Ask";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "Atlas";
    			attr_dev(span0, "class", "market-position svelte-161yoxw");
    			add_location(span0, file$h, 65, 24, 2351);
    			attr_dev(span1, "class", "market-number svelte-161yoxw");
    			add_location(span1, file$h, 66, 24, 2417);
    			attr_dev(span2, "class", "currency-mark svelte-161yoxw");
    			add_location(span2, file$h, 67, 24, 2501);
    			attr_dev(div, "class", "internal svelte-161yoxw");
    			add_location(div, file$h, 64, 20, 2249);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			append_dev(div, span2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*askATLAS*/ 16 && t2_value !== (t2_value = formatAtlas(/*askATLAS*/ ctx[4]) + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, { duration: 1000, start: 0.4, amount: 8 });
    					div_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_5.name,
    		type: "key",
    		source: "(64:20) {#key askATLAS}",
    		ctx
    	});

    	return block;
    }

    // (54:20) {#key askATLAS}
    function create_key_block_4(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = formatAtlas(/*askATLAS*/ ctx[4]) + "";
    	let t2;
    	let t3;
    	let span2;
    	let div_intro;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Ask";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "Atlas";
    			attr_dev(span0, "class", "market-position svelte-161yoxw");
    			add_location(span0, file$h, 55, 24, 1856);
    			attr_dev(span1, "class", "market-number svelte-161yoxw");
    			add_location(span1, file$h, 56, 24, 1922);
    			attr_dev(span2, "class", "currency-mark svelte-161yoxw");
    			add_location(span2, file$h, 57, 24, 2006);
    			attr_dev(div, "class", "internal svelte-161yoxw");
    			add_location(div, file$h, 54, 20, 1754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			append_dev(div, span2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*askATLAS*/ 16 && t2_value !== (t2_value = formatAtlas(/*askATLAS*/ ctx[4]) + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, { duration: 1000, start: 0.4, amount: 8 });
    					div_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_4.name,
    		type: "key",
    		source: "(54:20) {#key askATLAS}",
    		ctx
    	});

    	return block;
    }

    // (75:16) {#key askUSDC}
    function create_key_block_3(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = formatUSDC(/*askUSDC*/ ctx[8]) + "";
    	let t2;
    	let t3;
    	let span2;
    	let div_intro;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Ask";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "USDC";
    			attr_dev(span0, "class", "market-position svelte-161yoxw");
    			add_location(span0, file$h, 76, 20, 2828);
    			attr_dev(span1, "class", "market-number svelte-161yoxw");
    			add_location(span1, file$h, 77, 20, 2890);
    			attr_dev(span2, "class", "currency-mark svelte-161yoxw");
    			add_location(span2, file$h, 78, 20, 2968);
    			attr_dev(div, "class", "internal svelte-161yoxw");
    			add_location(div, file$h, 75, 16, 2730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			append_dev(div, span2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*askUSDC*/ 256 && t2_value !== (t2_value = formatUSDC(/*askUSDC*/ ctx[8]) + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, { duration: 1000, start: 0.4, amount: 8 });
    					div_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_3.name,
    		type: "key",
    		source: "(75:16) {#key askUSDC}",
    		ctx
    	});

    	return block;
    }

    // (96:12) {:else}
    function create_else_block$4(ctx) {
    	let div;
    	let previous_key = /*bidATLAS*/ ctx[2];
    	let key_block = create_key_block_2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			key_block.c();
    			attr_dev(div, "class", "price-atlas svelte-161yoxw");
    			add_location(div, file$h, 96, 16, 3731);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			key_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bidATLAS*/ 4 && safe_not_equal(previous_key, previous_key = /*bidATLAS*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block_2(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			transition_in(key_block);
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(96:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (86:12) {#if conversion}
    function create_if_block_1$5(ctx) {
    	let div;
    	let previous_key = /*bidATLAS*/ ctx[2];
    	let tooltip_action;
    	let mounted;
    	let dispose;
    	let key_block = create_key_block_1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			key_block.c();
    			attr_dev(div, "class", "price-atlas svelte-161yoxw");
    			add_location(div, file$h, 86, 16, 3181);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			key_block.m(div, null);

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = /*tooltip*/ ctx[10].call(null, div, {
    					.../*tooltipParams*/ ctx[9],
    					content: /*bidAtlasEq*/ ctx[5]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bidATLAS*/ 4 && safe_not_equal(previous_key, previous_key = /*bidATLAS*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block_1(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (tooltip_action && is_function(tooltip_action.update) && dirty & /*bidAtlasEq*/ 32) tooltip_action.update.call(null, {
    				.../*tooltipParams*/ ctx[9],
    				content: /*bidAtlasEq*/ ctx[5]
    			});
    		},
    		i: function intro(local) {
    			transition_in(key_block);
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			key_block.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(86:12) {#if conversion}",
    		ctx
    	});

    	return block;
    }

    // (98:20) {#key bidATLAS}
    function create_key_block_2(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = formatAtlas(/*bidATLAS*/ ctx[2]) + "";
    	let t2;
    	let t3;
    	let span2;
    	let div_intro;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Bid";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "Atlas";
    			attr_dev(span0, "class", "market-position svelte-161yoxw");
    			add_location(span0, file$h, 99, 24, 3917);
    			attr_dev(span1, "class", "market-number svelte-161yoxw");
    			add_location(span1, file$h, 100, 24, 3983);
    			attr_dev(span2, "class", "currency-mark svelte-161yoxw");
    			add_location(span2, file$h, 101, 24, 4067);
    			attr_dev(div, "class", "internal svelte-161yoxw");
    			add_location(div, file$h, 98, 20, 3815);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			append_dev(div, span2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bidATLAS*/ 4 && t2_value !== (t2_value = formatAtlas(/*bidATLAS*/ ctx[2]) + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, { duration: 1000, start: 0.4, amount: 8 });
    					div_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_2.name,
    		type: "key",
    		source: "(98:20) {#key bidATLAS}",
    		ctx
    	});

    	return block;
    }

    // (88:20) {#key bidATLAS}
    function create_key_block_1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = formatAtlas(/*bidATLAS*/ ctx[2]) + "";
    	let t2;
    	let t3;
    	let span2;
    	let div_intro;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Bid";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "Atlas";
    			attr_dev(span0, "class", "market-position svelte-161yoxw");
    			add_location(span0, file$h, 89, 24, 3422);
    			attr_dev(span1, "class", "market-number svelte-161yoxw");
    			add_location(span1, file$h, 90, 24, 3488);
    			attr_dev(span2, "class", "currency-mark svelte-161yoxw");
    			add_location(span2, file$h, 91, 24, 3572);
    			attr_dev(div, "class", "internal svelte-161yoxw");
    			add_location(div, file$h, 88, 20, 3320);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			append_dev(div, span2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bidATLAS*/ 4 && t2_value !== (t2_value = formatAtlas(/*bidATLAS*/ ctx[2]) + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, { duration: 1000, start: 0.4, amount: 8 });
    					div_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_1.name,
    		type: "key",
    		source: "(88:20) {#key bidATLAS}",
    		ctx
    	});

    	return block;
    }

    // (109:16) {#key bidUSDC}
    function create_key_block$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2_value = formatUSDC(/*bidUSDC*/ ctx[7]) + "";
    	let t2;
    	let t3;
    	let span2;
    	let div_intro;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Bid";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "USDC";
    			attr_dev(span0, "class", "market-position svelte-161yoxw");
    			add_location(span0, file$h, 110, 20, 4394);
    			attr_dev(span1, "class", "market-number svelte-161yoxw");
    			add_location(span1, file$h, 111, 20, 4456);
    			attr_dev(span2, "class", "currency-mark svelte-161yoxw");
    			add_location(span2, file$h, 112, 20, 4534);
    			attr_dev(div, "class", "internal svelte-161yoxw");
    			add_location(div, file$h, 109, 16, 4296);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			append_dev(div, span2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bidUSDC*/ 128 && t2_value !== (t2_value = formatUSDC(/*bidUSDC*/ ctx[7]) + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, { duration: 1000, start: 0.4, amount: 8 });
    					div_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$1.name,
    		type: "key",
    		source: "(109:16) {#key bidUSDC}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let if_block_anchor;
    	let if_block = /*ship*/ ctx[0].prices && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*ship*/ ctx[0].prices) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*ship*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			transition_in(if_block);
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let askATLAS;
    	let askUSDC;
    	let bidATLAS;
    	let bidUSDC;
    	let conversion;
    	let askAtlasEq;
    	let bidAtlasEq;
    	let $tokenPrices;
    	validate_store(tokenPrices, 'tokenPrices');
    	component_subscribe($$self, tokenPrices, $$value => $$invalidate(11, $tokenPrices = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Price_ask_bid', slots, []);
    	let { ship } = $$props;
    	let { priceClass = 'price-ask-bid' } = $$props;

    	const composeConversion = (conversion, text, val) => {
    		if (!conversion) {
    			return 0;
    		}

    		return '<span class="market-position">' + text + '</span>' + formatUSDC(Number(val) * conversion) + '<span class="currency-mark">USDC</span>';
    	};

    	const tooltipParams = {
    		allowHTML: true,
    		delay: [200, 100],
    		offset: [-18, -8],
    		placement: 'top'
    	};

    	function tooltip(node, params) {
    		let tip = tippy(node, params);

    		return {
    			update: newParams => {
    				tip.setProps(newParams);
    			},
    			destroy: () => {
    				tip.destroy();
    			}
    		};
    	}
    	const writable_props = ['ship', 'priceClass'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Price_ask_bid> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ship' in $$props) $$invalidate(0, ship = $$props.ship);
    		if ('priceClass' in $$props) $$invalidate(1, priceClass = $$props.priceClass);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		tippy,
    		formatAtlas,
    		formatUSDC,
    		tokenPrices,
    		ship,
    		priceClass,
    		composeConversion,
    		tooltipParams,
    		tooltip,
    		bidATLAS,
    		conversion,
    		bidAtlasEq,
    		askATLAS,
    		askAtlasEq,
    		bidUSDC,
    		askUSDC,
    		$tokenPrices
    	});

    	$$self.$inject_state = $$props => {
    		if ('ship' in $$props) $$invalidate(0, ship = $$props.ship);
    		if ('priceClass' in $$props) $$invalidate(1, priceClass = $$props.priceClass);
    		if ('bidATLAS' in $$props) $$invalidate(2, bidATLAS = $$props.bidATLAS);
    		if ('conversion' in $$props) $$invalidate(3, conversion = $$props.conversion);
    		if ('bidAtlasEq' in $$props) $$invalidate(5, bidAtlasEq = $$props.bidAtlasEq);
    		if ('askATLAS' in $$props) $$invalidate(4, askATLAS = $$props.askATLAS);
    		if ('askAtlasEq' in $$props) $$invalidate(6, askAtlasEq = $$props.askAtlasEq);
    		if ('bidUSDC' in $$props) $$invalidate(7, bidUSDC = $$props.bidUSDC);
    		if ('askUSDC' in $$props) $$invalidate(8, askUSDC = $$props.askUSDC);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*ship*/ 1) {
    			$$invalidate(4, askATLAS = ship.prices ? ship.prices.askATLAS || 0 : 0);
    		}

    		if ($$self.$$.dirty & /*ship*/ 1) {
    			$$invalidate(8, askUSDC = ship.prices ? ship.prices.askUSDC || 0 : 0);
    		}

    		if ($$self.$$.dirty & /*ship*/ 1) {
    			$$invalidate(2, bidATLAS = ship.prices ? ship.prices.bidATLAS || 0 : 0);
    		}

    		if ($$self.$$.dirty & /*ship*/ 1) {
    			$$invalidate(7, bidUSDC = ship.prices ? ship.prices.bidUSDC || 0 : 0);
    		}

    		if ($$self.$$.dirty & /*$tokenPrices*/ 2048) {
    			$$invalidate(3, conversion = $tokenPrices['ATLAS/USDC'] || 0);
    		}

    		if ($$self.$$.dirty & /*conversion, askATLAS*/ 24) {
    			$$invalidate(6, askAtlasEq = composeConversion(conversion, 'ask', askATLAS));
    		}

    		if ($$self.$$.dirty & /*conversion, bidATLAS*/ 12) {
    			$$invalidate(5, bidAtlasEq = composeConversion(conversion, 'bid', bidATLAS));
    		}
    	};

    	return [
    		ship,
    		priceClass,
    		bidATLAS,
    		conversion,
    		askATLAS,
    		bidAtlasEq,
    		askAtlasEq,
    		bidUSDC,
    		askUSDC,
    		tooltipParams,
    		tooltip,
    		$tokenPrices
    	];
    }

    class Price_ask_bid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { ship: 0, priceClass: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Price_ask_bid",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ship*/ ctx[0] === undefined && !('ship' in props)) {
    			console.warn("<Price_ask_bid> was created without expected prop 'ship'");
    		}
    	}

    	get ship() {
    		throw new Error("<Price_ask_bid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ship(value) {
    		throw new Error("<Price_ask_bid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceClass() {
    		throw new Error("<Price_ask_bid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceClass(value) {
    		throw new Error("<Price_ask_bid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Meta-tags.svelte generated by Svelte v3.46.3 */

    const file$g = "src\\components\\Meta-tags.svelte";

    // (10:0) {#if ship}
    function create_if_block$a(ctx) {
    	let div;
    	let span0;
    	let t0_value = /*ship*/ ctx[2].attributes.spec + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2_value = /*ship*/ ctx[2].attributes.class + "";
    	let t2;
    	let t3;
    	let div_class_value;
    	let if_block = /*includeSymbol*/ ctx[0] && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			attr_dev(span0, "class", "capitalize svelte-1pw61jn");
    			add_location(span0, file$g, 11, 8, 279);
    			attr_dev(span1, "class", "subtitle svelte-1pw61jn");
    			add_location(span1, file$g, 12, 8, 343);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*metaClass*/ ctx[3]) + " svelte-1pw61jn"));
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			add_location(div, file$g, 10, 4, 232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(span0, t0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ship*/ 4 && t0_value !== (t0_value = /*ship*/ ctx[2].attributes.spec + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*ship*/ 4 && t2_value !== (t2_value = /*ship*/ ctx[2].attributes.class + "")) set_data_dev(t2, t2_value);

    			if (/*includeSymbol*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$4(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*metaClass*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*metaClass*/ ctx[3]) + " svelte-1pw61jn"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(10:0) {#if ship}",
    		ctx
    	});

    	return block;
    }

    // (14:8) {#if includeSymbol}
    function create_if_block_1$4(ctx) {
    	let span;
    	let t0;
    	let t1_value = /*ship*/ ctx[2].symbol + "";
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("Symbol: ");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "ship-symbol svelte-1pw61jn");
    			add_location(span, file$g, 13, 27, 425);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ship*/ 4 && t1_value !== (t1_value = /*ship*/ ctx[2].symbol + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(14:8) {#if includeSymbol}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let if_block_anchor;
    	let if_block = /*ship*/ ctx[2] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*ship*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let metaClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Meta_tags', slots, []);
    	let { includeSymbol = false } = $$props;
    	let { style = '' } = $$props;
    	let { className = '' } = $$props;
    	let { ship } = $$props;
    	const writable_props = ['includeSymbol', 'style', 'className', 'ship'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Meta_tags> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('includeSymbol' in $$props) $$invalidate(0, includeSymbol = $$props.includeSymbol);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('ship' in $$props) $$invalidate(2, ship = $$props.ship);
    	};

    	$$self.$capture_state = () => ({
    		includeSymbol,
    		style,
    		className,
    		ship,
    		metaClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('includeSymbol' in $$props) $$invalidate(0, includeSymbol = $$props.includeSymbol);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('ship' in $$props) $$invalidate(2, ship = $$props.ship);
    		if ('metaClass' in $$props) $$invalidate(3, metaClass = $$props.metaClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 16) {
    			$$invalidate(3, metaClass = 'ship-meta' + (className ? ' ' + className : ''));
    		}
    	};

    	return [includeSymbol, style, ship, metaClass, className];
    }

    class Meta_tags extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			includeSymbol: 0,
    			style: 1,
    			className: 4,
    			ship: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Meta_tags",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ship*/ ctx[2] === undefined && !('ship' in props)) {
    			console.warn("<Meta_tags> was created without expected prop 'ship'");
    		}
    	}

    	get includeSymbol() {
    		throw new Error("<Meta_tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set includeSymbol(value) {
    		throw new Error("<Meta_tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Meta_tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Meta_tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Meta_tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Meta_tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ship() {
    		throw new Error("<Meta_tags>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ship(value) {
    		throw new Error("<Meta_tags>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var defaultBindingOptions = {
        allowDownsampling: true,
    };
    function bindToDevicePixelRatio(canvas, options) {
        if (options === void 0) { options = defaultBindingOptions; }
        return new DevicePixelRatioBinding(canvas, options);
    }
    var DevicePixelRatioBinding = /** @class */ (function () {
        function DevicePixelRatioBinding(canvas, options) {
            var _this = this;
            this._resolutionMediaQueryList = null;
            this._resolutionListener = function (ev) { return _this._onResolutionChanged(); };
            this._canvasConfiguredListeners = [];
            this.canvas = canvas;
            this._canvasSize = {
                width: this.canvas.clientWidth,
                height: this.canvas.clientHeight,
            };
            this._options = options;
            this._configureCanvas();
            this._installResolutionListener();
        }
        DevicePixelRatioBinding.prototype.destroy = function () {
            this._canvasConfiguredListeners.length = 0;
            this._uninstallResolutionListener();
            this.canvas = null;
        };
        Object.defineProperty(DevicePixelRatioBinding.prototype, "canvasSize", {
            get: function () {
                return {
                    width: this._canvasSize.width,
                    height: this._canvasSize.height,
                };
            },
            enumerable: true,
            configurable: true
        });
        DevicePixelRatioBinding.prototype.resizeCanvas = function (size) {
            this._canvasSize = {
                width: size.width,
                height: size.height,
            };
            this._configureCanvas();
        };
        Object.defineProperty(DevicePixelRatioBinding.prototype, "pixelRatio", {
            get: function () {
                // According to DOM Level 2 Core specification, ownerDocument should never be null for HTMLCanvasElement
                // see https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#node-ownerDoc
                var win = this.canvas.ownerDocument.defaultView;
                if (win == null) {
                    throw new Error('No window is associated with the canvas');
                }
                return win.devicePixelRatio > 1 || this._options.allowDownsampling ? win.devicePixelRatio : 1;
            },
            enumerable: true,
            configurable: true
        });
        DevicePixelRatioBinding.prototype.subscribeCanvasConfigured = function (listener) {
            this._canvasConfiguredListeners.push(listener);
        };
        DevicePixelRatioBinding.prototype.unsubscribeCanvasConfigured = function (listener) {
            this._canvasConfiguredListeners = this._canvasConfiguredListeners.filter(function (l) { return l != listener; });
        };
        DevicePixelRatioBinding.prototype._configureCanvas = function () {
            var ratio = this.pixelRatio;
            this.canvas.style.width = this._canvasSize.width + "px";
            this.canvas.style.height = this._canvasSize.height + "px";
            this.canvas.width = this._canvasSize.width * ratio;
            this.canvas.height = this._canvasSize.height * ratio;
            this._emitCanvasConfigured();
        };
        DevicePixelRatioBinding.prototype._emitCanvasConfigured = function () {
            var _this = this;
            this._canvasConfiguredListeners.forEach(function (listener) { return listener.call(_this); });
        };
        DevicePixelRatioBinding.prototype._installResolutionListener = function () {
            if (this._resolutionMediaQueryList !== null) {
                throw new Error('Resolution listener is already installed');
            }
            // According to DOM Level 2 Core specification, ownerDocument should never be null for HTMLCanvasElement
            // see https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#node-ownerDoc
            var win = this.canvas.ownerDocument.defaultView;
            if (win == null) {
                throw new Error('No window is associated with the canvas');
            }
            var dppx = win.devicePixelRatio;
            this._resolutionMediaQueryList = win.matchMedia("all and (resolution: " + dppx + "dppx)");
            // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener
            this._resolutionMediaQueryList.addListener(this._resolutionListener);
        };
        DevicePixelRatioBinding.prototype._uninstallResolutionListener = function () {
            if (this._resolutionMediaQueryList !== null) {
                // IE and some versions of Edge do not support addEventListener/removeEventListener, and we are going to use the deprecated addListener/removeListener
                this._resolutionMediaQueryList.removeListener(this._resolutionListener);
                this._resolutionMediaQueryList = null;
            }
        };
        DevicePixelRatioBinding.prototype._reinstallResolutionListener = function () {
            this._uninstallResolutionListener();
            this._installResolutionListener();
        };
        DevicePixelRatioBinding.prototype._onResolutionChanged = function () {
            this._configureCanvas();
            this._reinstallResolutionListener();
        };
        return DevicePixelRatioBinding;
    }());

    /*!
     * @license
     * TradingView Lightweight Charts v3.7.0
     * Copyright (c) 2020 TradingView, Inc.
     * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
     */
    var i,n;function s(t,i){var n,s=((n={})[0]=[],n[1]=[t.lineWidth,t.lineWidth],n[2]=[2*t.lineWidth,2*t.lineWidth],n[3]=[6*t.lineWidth,6*t.lineWidth],n[4]=[t.lineWidth,4*t.lineWidth],n)[i];t.setLineDash(s);}function h(t,i,n,s){t.beginPath();var h=t.lineWidth%2?.5:0;t.moveTo(n,i+h),t.lineTo(s,i+h),t.stroke();}!function(t){t[t.Simple=0]="Simple",t[t.WithSteps=1]="WithSteps";}(i||(i={})),function(t){t[t.Solid=0]="Solid",t[t.Dotted=1]="Dotted",t[t.Dashed=2]="Dashed",t[t.LargeDashed=3]="LargeDashed",t[t.SparseDotted=4]="SparseDotted";}(n||(n={}));var r=function(t,i){return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,i){t.__proto__=i;}||function(t,i){for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(t[n]=i[n]);},r(t,i)};function e(t,i){if("function"!=typeof i&&null!==i)throw new TypeError("Class extends value "+String(i)+" is not a constructor or null");function n(){this.constructor=t;}r(t,i),t.prototype=null===i?Object.create(i):(n.prototype=i.prototype,new n);}var u=function(){return u=Object.assign||function(t){for(var i,n=1,s=arguments.length;n<s;n++)for(var h in i=arguments[n])Object.prototype.hasOwnProperty.call(i,h)&&(t[h]=i[h]);return t},u.apply(this,arguments)};function a(t,i,n){if(n||2===arguments.length)for(var s,h=0,r=i.length;h<r;h++)!s&&h in i||(s||(s=Array.prototype.slice.call(i,0,h)),s[h]=i[h]);return t.concat(s||Array.prototype.slice.call(i))}function o(t,i){if(!t)throw new Error("Assertion failed"+(i?": "+i:""))}function l(t){if(void 0===t)throw new Error("Value is undefined");return t}function f(t){if(null===t)throw new Error("Value is null");return t}function c(t){return f(l(t))}function v(t){for(var i=[],n=1;n<arguments.length;n++)i[n-1]=arguments[n];for(var s=0,h=i;s<h.length;s++){var r=h[s];for(var e in r)void 0!==r[e]&&("object"!=typeof r[e]||void 0===t[e]?t[e]=r[e]:v(t[e],r[e]));}return t}function _(t){return "number"==typeof t&&isFinite(t)}function d(t){return "number"==typeof t&&t%1==0}function w(t){return "string"==typeof t}function M(t){return "boolean"==typeof t}function b(t){var i,n,s,h=t;if(!h||"object"!=typeof h)return h;for(n in i=Array.isArray(h)?[]:{},h)h.hasOwnProperty(n)&&(s=h[n],i[n]=s&&"object"==typeof s?b(s):s);return i}function m(t){return null!==t}function p(t){return null===t?void 0:t}var g=function(){function t(){this.t=[];}return t.prototype.i=function(t){this.t=t;},t.prototype.h=function(t,i,n,s){this.t.forEach((function(h){t.save(),h.h(t,i,n,s),t.restore();}));},t}(),y=function(){function t(){}return t.prototype.h=function(t,i,n,s){t.save(),t.scale(i,i),this.u(t,n,s),t.restore();},t.prototype.o=function(t,i,n,s){t.save(),t.scale(i,i),this.l(t,n,s),t.restore();},t.prototype.l=function(t,i,n){},t}(),k=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.v=null,i}return e(i,t),i.prototype._=function(t){this.v=t;},i.prototype.u=function(t){if(null!==this.v&&null!==this.v.M){var i=this.v.M,n=this.v,s=function(s){t.beginPath();for(var h=i.to-1;h>=i.from;--h){var r=n.m[h];t.moveTo(r.p,r.g),t.arc(r.p,r.g,s,0,2*Math.PI);}t.fill();};t.fillStyle=n.k,s(n.C+2),t.fillStyle=n.N,s(n.C);}},i}(y);function C(){return {m:[{p:0,g:0,S:0,D:0}],N:"",k:"",C:0,M:null}}var N={from:0,to:1},x=function(){function t(t,i){this.A=new g,this.T=[],this.B=[],this.L=!0,this.F=t,this.V=i,this.A.i(this.T);}return t.prototype.O=function(t){var i=this.F.W();i.length!==this.T.length&&(this.B=i.map(C),this.T=this.B.map((function(t){var i=new k;return i._(t),i})),this.A.i(this.T)),this.L=!0;},t.prototype.P=function(t,i,n){return this.L&&(this.R(t),this.L=!1),this.A},t.prototype.R=function(t){var i=this,n=this.F.W(),s=this.V.I(),h=this.F.j();n.forEach((function(n,r){var e,u=i.B[r],a=n.q(s);if(null!==a&&n.U()){var o=f(n.H());u.N=a.Y,u.C=a.C,u.m[0].D=a.D,u.m[0].g=n.$().K(a.D,o.X),u.k=null!==(e=a.Z)&&void 0!==e?e:i.F.J(u.m[0].g/t),u.m[0].S=s,u.m[0].p=h.G(s),u.M=N;}else u.M=null;}));},t}(),S=function(){function t(t){this.tt=t;}return t.prototype.h=function(t,i,n,r){if(null!==this.tt){var e=this.tt.it.U,u=this.tt.nt.U;if(e||u){t.save();var a=Math.round(this.tt.p*i),o=Math.round(this.tt.g*i),l=Math.ceil(this.tt.st*i),f=Math.ceil(this.tt.ht*i);t.lineCap="butt",e&&a>=0&&(t.lineWidth=Math.floor(this.tt.it.rt*i),t.strokeStyle=this.tt.it.et,t.fillStyle=this.tt.it.et,s(t,this.tt.it.ut),function(t,i,n,s){t.beginPath();var h=t.lineWidth%2?.5:0;t.moveTo(i+h,n),t.lineTo(i+h,s),t.stroke();}(t,a,0,f)),u&&o>=0&&(t.lineWidth=Math.floor(this.tt.nt.rt*i),t.strokeStyle=this.tt.nt.et,t.fillStyle=this.tt.nt.et,s(t,this.tt.nt.ut),h(t,o,0,l)),t.restore();}}},t}(),D=function(){function t(t){this.L=!0,this.at={it:{rt:1,ut:0,et:"",U:!1},nt:{rt:1,ut:0,et:"",U:!1},st:0,ht:0,p:0,g:0},this.ot=new S(this.at),this.lt=t;}return t.prototype.O=function(){this.L=!0;},t.prototype.P=function(t,i){return this.L&&(this.R(),this.L=!1),this.ot},t.prototype.R=function(){var t=this.lt.U(),i=f(this.lt.ft()),n=i.vt().ct().crosshair,s=this.at;s.nt.U=t&&this.lt._t(i),s.it.U=t&&this.lt.dt(),s.nt.rt=n.horzLine.width,s.nt.ut=n.horzLine.style,s.nt.et=n.horzLine.color,s.it.rt=n.vertLine.width,s.it.ut=n.vertLine.style,s.it.et=n.vertLine.color,s.st=i.wt(),s.ht=i.Mt(),s.p=this.lt.bt(),s.g=this.lt.gt();},t}(),A={khaki:"#f0e68c",azure:"#f0ffff",aliceblue:"#f0f8ff",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",gray:"#808080",green:"#008000",honeydew:"#f0fff0",floralwhite:"#fffaf0",lightblue:"#add8e6",lightcoral:"#f08080",lemonchiffon:"#fffacd",hotpink:"#ff69b4",lightyellow:"#ffffe0",greenyellow:"#adff2f",lightgoldenrodyellow:"#fafad2",limegreen:"#32cd32",linen:"#faf0e6",lightcyan:"#e0ffff",magenta:"#f0f",maroon:"#800000",olive:"#808000",orange:"#ffa500",oldlace:"#fdf5e6",mediumblue:"#0000cd",transparent:"#0000",lime:"#0f0",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",midnightblue:"#191970",orchid:"#da70d6",mediumorchid:"#ba55d3",mediumturquoise:"#48d1cc",orangered:"#ff4500",royalblue:"#4169e1",powderblue:"#b0e0e6",red:"#f00",coral:"#ff7f50",turquoise:"#40e0d0",white:"#fff",whitesmoke:"#f5f5f5",wheat:"#f5deb3",teal:"#008080",steelblue:"#4682b4",bisque:"#ffe4c4",aquamarine:"#7fffd4",aqua:"#0ff",sienna:"#a0522d",silver:"#c0c0c0",springgreen:"#00ff7f",antiquewhite:"#faebd7",burlywood:"#deb887",brown:"#a52a2a",beige:"#f5f5dc",chocolate:"#d2691e",chartreuse:"#7fff00",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cadetblue:"#5f9ea0",tomato:"#ff6347",fuchsia:"#f0f",blue:"#00f",salmon:"#fa8072",blanchedalmond:"#ffebcd",slateblue:"#6a5acd",slategray:"#708090",thistle:"#d8bfd8",tan:"#d2b48c",cyan:"#0ff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",blueviolet:"#8a2be2",black:"#000",darkmagenta:"#8b008b",darkslateblue:"#483d8b",darkkhaki:"#bdb76b",darkorchid:"#9932cc",darkorange:"#ff8c00",darkgreen:"#006400",darkred:"#8b0000",dodgerblue:"#1e90ff",darkslategray:"#2f4f4f",dimgray:"#696969",deepskyblue:"#00bfff",firebrick:"#b22222",forestgreen:"#228b22",indigo:"#4b0082",ivory:"#fffff0",lavenderblush:"#fff0f5",feldspar:"#d19275",indianred:"#cd5c5c",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightskyblue:"#87cefa",lightslategray:"#789",lightslateblue:"#8470ff",snow:"#fffafa",lightseagreen:"#20b2aa",lightsalmon:"#ffa07a",darksalmon:"#e9967a",darkviolet:"#9400d3",mediumpurple:"#9370d8",mediumaquamarine:"#66cdaa",skyblue:"#87ceeb",lavender:"#e6e6fa",lightsteelblue:"#b0c4de",mediumvioletred:"#c71585",mintcream:"#f5fffa",navajowhite:"#ffdead",navy:"#000080",olivedrab:"#6b8e23",palevioletred:"#d87093",violetred:"#d02090",yellow:"#ff0",yellowgreen:"#9acd32",lawngreen:"#7cfc00",pink:"#ffc0cb",paleturquoise:"#afeeee",palegoldenrod:"#eee8aa",darkolivegreen:"#556b2f",darkseagreen:"#8fbc8f",darkturquoise:"#00ced1",peachpuff:"#ffdab9",deeppink:"#ff1493",violet:"#ee82ee",palegreen:"#98fb98",mediumseagreen:"#3cb371",peru:"#cd853f",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",purple:"#800080",seagreen:"#2e8b57",seashell:"#fff5ee",papayawhip:"#ffefd5",mediumslateblue:"#7b68ee",plum:"#dda0dd",mediumspringgreen:"#00fa9a"};function T(t){return t<0?0:t>255?255:Math.round(t)||0}function B(t){return t<=0||t>0?t<0?0:t>1?1:Math.round(1e4*t)/1e4:0}var L=/^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i,F=/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i,E=/^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/,V=/^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/;function O(t){var i;if((t=t.toLowerCase())in A&&(t=A[t]),i=V.exec(t)||E.exec(t))return [T(parseInt(i[1],10)),T(parseInt(i[2],10)),T(parseInt(i[3],10)),B(i.length<5?1:parseFloat(i[4]))];if(i=F.exec(t))return [T(parseInt(i[1],16)),T(parseInt(i[2],16)),T(parseInt(i[3],16)),1];if(i=L.exec(t))return [T(17*parseInt(i[1],16)),T(17*parseInt(i[2],16)),T(17*parseInt(i[3],16)),1];throw new Error("Cannot parse color: "+t)}function W(t){var i,n=O(t);return {yt:"rgb("+n[0]+", "+n[1]+", "+n[2]+")",kt:(i=n,.199*i[0]+.687*i[1]+.114*i[2]>160?"black":"white")}}function z(t,i,n,s,h,r){t.fillRect(i+r,n,s-2*r,r),t.fillRect(i+r,n+h-r,s-2*r,r),t.fillRect(i,n,r,h),t.fillRect(i+s-r,n,r,h);}function P(t,i,n){t.save(),t.scale(i,i),n(),t.restore();}function R(t,i,n,s,h,r){t.save(),t.globalCompositeOperation="copy",t.fillStyle=r,t.fillRect(i,n,s,h),t.restore();}function I(t,i,n,s,h,r,e){t.save(),t.globalCompositeOperation="copy";var u=t.createLinearGradient(0,0,0,h);u.addColorStop(0,r),u.addColorStop(1,e),t.fillStyle=u,t.fillRect(i,n,s,h),t.restore();}var j,q=function(){function t(t,i){this._(t,i);}return t.prototype._=function(t,i){this.tt=t,this.Ct=i;},t.prototype.h=function(t,i,n,s,h,r){if(this.tt.U){t.font=i.Nt;var e=this.tt.xt||!this.tt.St?i.Dt:0,u=i.At,a=i.Tt,o=i.Bt,l=i.Lt,f=i.Ft,c=this.tt.Et,v=Math.ceil(n.Vt(t,c)),_=i.Ot,d=i.Wt+a+o,w=Math.ceil(.5*d),M=u+v+l+f+e,b=this.Ct.zt;this.Ct.Pt&&(b=this.Ct.Pt);var m,p,g=(b=Math.round(b))-w,y=g+d,k="right"===h,C=k?s:0,N=Math.ceil(s*r),x=C;if(t.fillStyle=this.Ct.yt,t.lineWidth=1,t.lineCap="butt",c){k?(m=C-e,p=(x=C-M)+f):(x=C+M,m=C+e,p=C+u+e+l);var S=Math.max(1,Math.floor(r)),D=Math.max(1,Math.floor(u*r)),A=k?N:0,T=Math.round(g*r),B=Math.round(x*r),L=Math.round(b*r)-Math.floor(.5*r),F=L+S+(L-T),E=Math.round(m*r);t.save(),t.beginPath(),t.moveTo(A,T),t.lineTo(B,T),t.lineTo(B,F),t.lineTo(A,F),t.fill(),t.fillStyle=this.tt.Z,t.fillRect(k?N-D:0,T,D,F-T),this.tt.xt&&(t.fillStyle=this.Ct.et,t.fillRect(A,L,E-A,S)),t.textAlign="left",t.fillStyle=this.Ct.et,P(t,r,(function(){t.fillText(c,p,y-o-_);})),t.restore();}}},t.prototype.Mt=function(t,i){return this.tt.U?t.Wt+t.Tt+t.Bt:0},t}(),U=function(){function t(t){this.Rt={zt:0,et:"#FFF",yt:"#000"},this.It={Et:"",U:!1,xt:!0,St:!1,Z:""},this.jt={Et:"",U:!1,xt:!1,St:!0,Z:""},this.L=!0,this.qt=new(t||q)(this.It,this.Rt),this.Ut=new(t||q)(this.jt,this.Rt);}return t.prototype.Et=function(){return this.It.Et},t.prototype.zt=function(){return this.Ht(),this.Rt.zt},t.prototype.O=function(){this.L=!0;},t.prototype.Mt=function(t,i){return void 0===i&&(i=!1),Math.max(this.qt.Mt(t,i),this.Ut.Mt(t,i))},t.prototype.Yt=function(){return this.Rt.Pt||0},t.prototype.Kt=function(t){this.Rt.Pt=t;},t.prototype.$t=function(){return this.Ht(),this.It.U||this.jt.U},t.prototype.Xt=function(){return this.Ht(),this.It.U},t.prototype.P=function(t){return this.Ht(),this.It.xt=this.It.xt&&t.ct().drawTicks,this.jt.xt=this.jt.xt&&t.ct().drawTicks,this.qt._(this.It,this.Rt),this.Ut._(this.jt,this.Rt),this.qt},t.prototype.Zt=function(){return this.Ht(),this.qt._(this.It,this.Rt),this.Ut._(this.jt,this.Rt),this.Ut},t.prototype.Ht=function(){this.L&&(this.It.xt=!0,this.jt.xt=!1,this.Jt(this.It,this.jt,this.Rt));},t}(),H=function(t){function i(i,n,s){var h=t.call(this)||this;return h.lt=i,h.Gt=n,h.Qt=s,h}return e(i,t),i.prototype.Jt=function(t,i,n){t.U=!1;var s=this.lt.ct().horzLine;if(s.labelVisible){var h=this.Gt.H();if(this.lt.U()&&!this.Gt.ti()&&null!==h){var r=W(s.labelBackgroundColor);n.yt=r.yt,n.et=r.kt;var e=this.Qt(this.Gt);n.zt=e.zt,t.Et=this.Gt.ii(e.D,h),t.U=!0;}}},i}(U),Y=/[1-9]/g,K=function(){function t(){this.tt=null;}return t.prototype._=function(t){this.tt=t;},t.prototype.h=function(t,i,n){var s=this;if(null!==this.tt&&!1!==this.tt.U&&0!==this.tt.Et.length){t.font=i.Nt;var h=Math.round(i.ni.Vt(t,this.tt.Et,Y));if(!(h<=0)){t.save();var r=i.si,e=h+2*r,u=e/2,a=this.tt.wt,o=this.tt.zt,l=Math.floor(o-u)+.5;l<0?(o+=Math.abs(0-l),l=Math.floor(o-u)+.5):l+e>a&&(o-=Math.abs(a-(l+e)),l=Math.floor(o-u)+.5);var c=l+e,v=0+i.At+i.Tt+i.Wt+i.Bt;t.fillStyle=this.tt.yt;var _=Math.round(l*n),d=Math.round(0*n),w=Math.round(c*n),M=Math.round(v*n);t.fillRect(_,d,w-_,M-d);var b=Math.round(this.tt.zt*n),m=d,p=Math.round((m+i.At+i.Dt)*n);t.fillStyle=this.tt.et;var g=Math.max(1,Math.floor(n)),y=Math.floor(.5*n);t.fillRect(b-y,m,g,p-m);var k=v-i.Ot-i.Bt;t.textAlign="left",t.fillStyle=this.tt.et,P(t,n,(function(){t.fillText(f(s.tt).Et,l+r,k);})),t.restore();}}},t}(),$=function(){function t(t,i,n){this.L=!0,this.ot=new K,this.at={U:!1,yt:"#4c525e",et:"white",Et:"",wt:0,zt:NaN},this.V=t,this.hi=i,this.Qt=n;}return t.prototype.O=function(){this.L=!0;},t.prototype.P=function(){return this.L&&(this.R(),this.L=!1),this.ot._(this.at),this.ot},t.prototype.R=function(){var t=this.at;t.U=!1;var i=this.V.ct().vertLine;if(i.labelVisible){var n=this.hi.j();if(!n.ti()){var s=n.ri(this.V.I());t.wt=n.wt();var h=this.Qt();if(h.S){t.zt=h.zt,t.Et=n.ei(f(s)),t.U=!0;var r=W(i.labelBackgroundColor);t.yt=r.yt,t.et=r.kt;}}}},t}(),X=function(){function t(){this.ui=null,this.ai=0;}return t.prototype.oi=function(){return this.ai},t.prototype.li=function(t){this.ai=t;},t.prototype.$=function(){return this.ui},t.prototype.fi=function(t){this.ui=t;},t.prototype.ci=function(){return []},t.prototype.U=function(){return !0},t}();!function(t){t[t.Normal=0]="Normal",t[t.Magnet=1]="Magnet";}(j||(j={}));var Z=function(t){function i(i,n){var s=t.call(this)||this;s.vi=null,s._i=NaN,s.di=0,s.wi=!0,s.Mi=new Map,s.bi=!1,s.mi=NaN,s.pi=NaN,s.gi=NaN,s.yi=NaN,s.hi=i,s.ki=n,s.Ci=new x(i,s);var h,r;s.Ni=(h=function(){return s._i},r=function(){return s.pi},function(t){var i=r(),n=h();if(t===f(s.vi).xi())return {D:n,zt:i};var e=f(t.H());return {D:t.Si(i,e),zt:i}});var e=function(t,i){return function(){return {S:s.hi.j().ri(t()),zt:i()}}}((function(){return s.di}),(function(){return s.bt()}));return s.Di=new $(s,i,e),s.Ai=new D(s),s}return e(i,t),i.prototype.ct=function(){return this.ki},i.prototype.Ti=function(t,i){this.gi=t,this.yi=i;},i.prototype.Bi=function(){this.gi=NaN,this.yi=NaN;},i.prototype.Li=function(){return this.gi},i.prototype.Fi=function(){return this.yi},i.prototype.Ei=function(t,i,n){this.bi||(this.bi=!0),this.wi=!0,this.Vi(t,i,n);},i.prototype.I=function(){return this.di},i.prototype.bt=function(){return this.mi},i.prototype.gt=function(){return this.pi},i.prototype.U=function(){return this.wi},i.prototype.Oi=function(){this.wi=!1,this.Wi(),this._i=NaN,this.mi=NaN,this.pi=NaN,this.vi=null,this.Bi();},i.prototype.zi=function(t){return null!==this.vi?[this.Ai,this.Ci]:[]},i.prototype._t=function(t){return t===this.vi&&this.ki.horzLine.visible},i.prototype.dt=function(){return this.ki.vertLine.visible},i.prototype.Pi=function(t,i){this.wi&&this.vi===t||this.Mi.clear();var n=[];return this.vi===t&&n.push(this.Ri(this.Mi,i,this.Ni)),n},i.prototype.ci=function(){return this.wi?[this.Di]:[]},i.prototype.ft=function(){return this.vi},i.prototype.Ii=function(){this.Ai.O(),this.Mi.forEach((function(t){return t.O()})),this.Di.O(),this.Ci.O();},i.prototype.ji=function(t){return t&&!t.xi().ti()?t.xi():null},i.prototype.Vi=function(t,i,n){this.qi(t,i,n)&&this.Ii();},i.prototype.qi=function(t,i,n){var s=this.mi,h=this.pi,r=this._i,e=this.di,u=this.vi,a=this.ji(n);this.di=t,this.mi=isNaN(t)?NaN:this.hi.j().G(t),this.vi=n;var o=null!==a?a.H():null;return null!==a&&null!==o?(this._i=i,this.pi=a.K(i,o)):(this._i=NaN,this.pi=NaN),s!==this.mi||h!==this.pi||e!==this.di||r!==this._i||u!==this.vi},i.prototype.Wi=function(){var t=this.hi.W().map((function(t){return t.Hi().Ui()})).filter(m),i=0===t.length?null:Math.max.apply(Math,t);this.di=null!==i?i:NaN;},i.prototype.Ri=function(t,i,n){var s=t.get(i);return void 0===s&&(s=new H(this,i,n),t.set(i,s)),s},i}(X),J=".";function G(t,i){if(!_(t))return "n/a";if(!d(i))throw new TypeError("invalid length");if(i<0||i>16)throw new TypeError("invalid length");if(0===i)return t.toString();return ("0000000000000000"+t.toString()).slice(-i)}var Q=function(){function t(t,i){if(i||(i=1),_(t)&&d(t)||(t=100),t<0)throw new TypeError("invalid base");this.Gt=t,this.Yi=i,this.Ki();}return t.prototype.format=function(t){var i=t<0?"−":"";return t=Math.abs(t),i+this.$i(t)},t.prototype.Ki=function(){if(this.Xi=0,this.Gt>0&&this.Yi>0)for(var t=this.Gt;t>1;)t/=10,this.Xi++;},t.prototype.$i=function(t){var i=this.Gt/this.Yi,n=Math.floor(t),s="",h=void 0!==this.Xi?this.Xi:NaN;if(i>1){var r=+(Math.round(t*i)-n*i).toFixed(this.Xi);r>=i&&(r-=i,n+=1),s=J+G(+r.toFixed(this.Xi)*this.Yi,h);}else n=Math.round(n*i)/i,h>0&&(s=J+G(0,h));return n.toFixed(0)+s},t}(),tt=function(t){function i(i){return void 0===i&&(i=100),t.call(this,i)||this}return e(i,t),i.prototype.format=function(i){return t.prototype.format.call(this,i)+"%"},i}(Q),it=function(){function t(){this.Zi=[];}return t.prototype.Ji=function(t,i,n){var s={Gi:t,Qi:i,tn:!0===n};this.Zi.push(s);},t.prototype.nn=function(t){var i=this.Zi.findIndex((function(i){return t===i.Gi}));i>-1&&this.Zi.splice(i,1);},t.prototype.sn=function(t){this.Zi=this.Zi.filter((function(i){return i.Qi===t}));},t.prototype.hn=function(t,i){var n=a([],this.Zi,!0);this.Zi=this.Zi.filter((function(t){return !t.tn})),n.forEach((function(n){return n.Gi(t,i)}));},t.prototype.rn=function(){return this.Zi.length>0},t.prototype.en=function(){this.Zi=[];},t}(),nt=function(){function t(t,i){this.un=t,this.an=i;}return t.prototype.on=function(t){return null!==t&&(this.un===t.un&&this.an===t.an)},t.prototype.ln=function(){return new t(this.un,this.an)},t.prototype.fn=function(){return this.un},t.prototype.cn=function(){return this.an},t.prototype.vn=function(){return this.an-this.un},t.prototype.ti=function(){return this.an===this.un||Number.isNaN(this.an)||Number.isNaN(this.un)},t.prototype._n=function(i){return null===i?this:new t(Math.min(this.fn(),i.fn()),Math.max(this.cn(),i.cn()))},t.prototype.dn=function(t){if(_(t)&&0!==this.an-this.un){var i=.5*(this.an+this.un),n=this.an-i,s=this.un-i;n*=t,s*=t,this.an=i+n,this.un=i+s;}},t.prototype.wn=function(t){_(t)&&(this.an+=t,this.un+=t);},t.prototype.Mn=function(){return {minValue:this.un,maxValue:this.an}},t.bn=function(i){return null===i?null:new t(i.minValue,i.maxValue)},t}();function st(t,i,n){return Math.min(Math.max(t,i),n)}function ht(t,i,n){return i-t<=n}function rt(t){return t<=0?NaN:Math.log(t)/Math.log(10)}function et(t){var i=Math.ceil(t);return i%2!=0?i-1:i}function ut(t){var i=Math.ceil(t);return i%2==0?i-1:i}function at(t,i){var n=100*(t-i)/i;return i<0?-n:n}function ot(t,i){var n=at(t.fn(),i),s=at(t.cn(),i);return new nt(n,s)}function lt(t,i){var n=100*(t-i)/i+100;return i<0?-n:n}function ft(t,i){var n=lt(t.fn(),i),s=lt(t.cn(),i);return new nt(n,s)}function ct(t){var i=Math.abs(t);if(i<1e-8)return 0;var n=rt(i+1e-4)+4;return t<0?-n:n}function vt(t){var i=Math.abs(t);if(i<1e-8)return 0;var n=Math.pow(10,i-4)-1e-4;return t<0?-n:n}function _t(t){if(null===t)return null;var i=ct(t.fn()),n=ct(t.cn());return new nt(i,n)}var dt,wt=function(){function t(t,i){if(this.mn=t,this.pn=i,function(t){if(t<0)return !1;for(var i=t;i>1;i/=10)if(i%10!=0)return !1;return !0}(this.mn))this.gn=[2,2.5,2];else {this.gn=[];for(var n=this.mn;1!==n;){if(n%2==0)this.gn.push(2),n/=2;else {if(n%5!=0)throw new Error("unexpected base");this.gn.push(2,2.5),n/=5;}if(this.gn.length>100)throw new Error("something wrong with base")}}}return t.prototype.yn=function(t,i,n){for(var s,h,r,e=0===this.mn?0:1/this.mn,u=Math.pow(10,Math.max(0,Math.ceil(rt(t-i)))),a=0,o=this.pn[0];;){var l=ht(u,e,1e-14)&&u>e+1e-14,f=ht(u,n*o,1e-14),c=ht(u,1,1e-14);if(!(l&&f&&c))break;u/=o,o=this.pn[++a%this.pn.length];}if(u<=e+1e-14&&(u=e),u=Math.max(1,u),this.gn.length>0&&(s=u,h=1,r=1e-14,Math.abs(s-h)<r))for(a=0,o=this.gn[0];ht(u,n*o,1e-14)&&u>e+1e-14;)u/=o,o=this.gn[++a%this.gn.length];return u},t}(),Mt=function(){function t(t,i,n,s){this.kn=[],this.Gt=t,this.mn=i,this.Cn=n,this.Nn=s;}return t.prototype.yn=function(t,i){if(t<i)throw new Error("high < low");var n=this.Gt.Mt(),s=(t-i)*this.xn()/n,h=new wt(this.mn,[2,2.5,2]),r=new wt(this.mn,[2,2,2.5]),e=new wt(this.mn,[2.5,2,2]),u=[];return u.push(h.yn(t,i,s),r.yn(t,i,s),e.yn(t,i,s)),function(t){if(t.length<1)throw Error("array is empty");for(var i=t[0],n=1;n<t.length;++n)t[n]<i&&(i=t[n]);return i}(u)},t.prototype.Sn=function(){var t=this.Gt,i=t.H();if(null!==i){var n=t.Mt(),s=this.Cn(n-1,i),h=this.Cn(0,i),r=this.Gt.ct().entireTextOnly?this.Dn()/2:0,e=r,u=n-1-r,a=Math.max(s,h),o=Math.min(s,h);if(a!==o){for(var l=this.yn(a,o),f=a%l,c=a>=o?1:-1,v=null,_=0,d=a-(f+=f<0?l:0);d>o;d-=l){var w=this.Nn(d,i,!0);null!==v&&Math.abs(w-v)<this.xn()||(w<e||w>u||(_<this.kn.length?(this.kn[_].An=w,this.kn[_].Tn=t.Bn(d)):this.kn.push({An:w,Tn:t.Bn(d)}),_++,v=w,t.Ln()&&(l=this.yn(d*c,o))));}this.kn.length=_;}else this.kn=[];}else this.kn=[];},t.prototype.Fn=function(){return this.kn},t.prototype.Dn=function(){return this.Gt.Wt()},t.prototype.xn=function(){return Math.ceil(2.5*this.Dn())},t}();function bt(t){return t.slice().sort((function(t,i){return f(t.oi())-f(i.oi())}))}!function(t){t[t.Normal=0]="Normal",t[t.Logarithmic=1]="Logarithmic",t[t.Percentage=2]="Percentage",t[t.IndexedTo100=3]="IndexedTo100";}(dt||(dt={}));var mt,pt,gt=new tt,yt=new Q(100,1),kt=function(){function t(t,i,n,s){this.En=0,this.Vn=null,this.On=null,this.Wn=null,this.zn={Pn:!1,Rn:null},this.In=0,this.jn=0,this.qn=new it,this.Un=new it,this.Hn=[],this.Yn=null,this.Kn=null,this.$n=null,this.Xn=null,this.Zn=yt,this.Jn=t,this.ki=i,this.Gn=n,this.Qn=s,this.ts=new Mt(this,100,this.ns.bind(this),this.ss.bind(this));}return t.prototype.hs=function(){return this.Jn},t.prototype.ct=function(){return this.ki},t.prototype.rs=function(t){if(v(this.ki,t),this.es(),void 0!==t.mode&&this.us({os:t.mode}),void 0!==t.scaleMargins){var i=l(t.scaleMargins.top),n=l(t.scaleMargins.bottom);if(i<0||i>1)throw new Error("Invalid top margin - expect value between 0 and 1, given="+i);if(n<0||n>1||i+n>1)throw new Error("Invalid bottom margin - expect value between 0 and 1, given="+n);if(i+n>1)throw new Error("Invalid margins - sum of margins must be less than 1, given="+(i+n));this.ls(),this.Kn=null;}},t.prototype.fs=function(){return this.ki.autoScale},t.prototype.Ln=function(){return 1===this.ki.mode},t.prototype.cs=function(){return 2===this.ki.mode},t.prototype.vs=function(){return 3===this.ki.mode},t.prototype.os=function(){return {_s:this.ki.autoScale,ds:this.ki.invertScale,os:this.ki.mode}},t.prototype.us=function(t){var i=this.os(),n=null;void 0!==t._s&&(this.ki.autoScale=t._s),void 0!==t.os&&(this.ki.mode=t.os,2!==t.os&&3!==t.os||(this.ki.autoScale=!0),this.zn.Pn=!1),1===i.os&&t.os!==i.os&&(!function(t){if(null===t)return !1;var i=vt(t.fn()),n=vt(t.cn());return isFinite(i)&&isFinite(n)}(this.On)?this.ki.autoScale=!0:(n=function(t){if(null===t)return null;var i=vt(t.fn()),n=vt(t.cn());return new nt(i,n)}(this.On),null!==n&&this.ws(n))),1===t.os&&t.os!==i.os&&null!==(n=_t(this.On))&&this.ws(n);var s=i.os!==this.ki.mode;s&&(2===i.os||this.cs())&&this.es(),s&&(3===i.os||this.vs())&&this.es(),void 0!==t.ds&&i.ds!==t.ds&&(this.ki.invertScale=t.ds,this.Ms()),this.Un.hn(i,this.os());},t.prototype.bs=function(){return this.Un},t.prototype.Wt=function(){return this.Gn.fontSize},t.prototype.Mt=function(){return this.En},t.prototype.ps=function(t){this.En!==t&&(this.En=t,this.ls(),this.Kn=null);},t.prototype.gs=function(){if(this.Vn)return this.Vn;var t=this.Mt()-this.ys()-this.ks();return this.Vn=t,t},t.prototype.Cs=function(){return this.Ns(),this.On},t.prototype.ws=function(t,i){var n=this.On;(i||null===n&&null!==t||null!==n&&!n.on(t))&&(this.Kn=null,this.On=t);},t.prototype.ti=function(){return this.Ns(),0===this.En||!this.On||this.On.ti()},t.prototype.xs=function(t){return this.ds()?t:this.Mt()-1-t},t.prototype.K=function(t,i){return this.cs()?t=at(t,i):this.vs()&&(t=lt(t,i)),this.ss(t,i)},t.prototype.Ss=function(t,i,n){this.Ns();for(var s=this.ks(),h=f(this.Cs()),r=h.fn(),e=h.cn(),u=this.gs()-1,a=this.ds(),o=u/(e-r),l=void 0===n?0:n.from,c=void 0===n?t.length:n.to,v=this.Ds(),_=l;_<c;_++){var d=t[_],w=d.D;if(!isNaN(w)){var M=w;null!==v&&(M=v(d.D,i));var b=s+o*(M-r),m=a?b:this.En-1-b;d.g=m;}}},t.prototype.As=function(t,i,n){this.Ns();for(var s=this.ks(),h=f(this.Cs()),r=h.fn(),e=h.cn(),u=this.gs()-1,a=this.ds(),o=u/(e-r),l=void 0===n?0:n.from,c=void 0===n?t.length:n.to,v=this.Ds(),_=l;_<c;_++){var d=t[_],w=d.open,M=d.high,b=d.low,m=d.close;null!==v&&(w=v(d.open,i),M=v(d.high,i),b=v(d.low,i),m=v(d.close,i));var p=s+o*(w-r),g=a?p:this.En-1-p;d.Ts=g,p=s+o*(M-r),g=a?p:this.En-1-p,d.Bs=g,p=s+o*(b-r),g=a?p:this.En-1-p,d.Ls=g,p=s+o*(m-r),g=a?p:this.En-1-p,d.Fs=g;}},t.prototype.Si=function(t,i){var n=this.ns(t,i);return this.Es(n,i)},t.prototype.Es=function(t,i){var n=t;return this.cs()?n=function(t,i){return i<0&&(t=-t),t/100*i+i}(n,i):this.vs()&&(n=function(t,i){return t-=100,i<0&&(t=-t),t/100*i+i}(n,i)),n},t.prototype.Vs=function(){return this.Hn},t.prototype.Os=function(){if(this.Yn)return this.Yn;for(var t=[],i=0;i<this.Hn.length;i++){var n=this.Hn[i];null===n.oi()&&n.li(i+1),t.push(n);}return t=bt(t),this.Yn=t,this.Yn},t.prototype.Ws=function(t){-1===this.Hn.indexOf(t)&&(this.Hn.push(t),this.es(),this.zs());},t.prototype.Ps=function(t){var i=this.Hn.indexOf(t);if(-1===i)throw new Error("source is not attached to scale");this.Hn.splice(i,1),0===this.Hn.length&&(this.us({_s:!0}),this.ws(null)),this.es(),this.zs();},t.prototype.H=function(){for(var t=null,i=0,n=this.Hn;i<n.length;i++){var s=n[i].H();null!==s&&((null===t||s.Rs<t.Rs)&&(t=s));}return null===t?null:t.X},t.prototype.ds=function(){return this.ki.invertScale},t.prototype.Fn=function(){return this.Kn||(this.ts.Sn(),this.Kn=this.ts.Fn(),this.qn.hn()),this.Kn},t.prototype.Is=function(){return this.qn},t.prototype.js=function(t){this.cs()||this.vs()||null===this.$n&&null===this.Wn&&(this.ti()||(this.$n=this.En-t,this.Wn=f(this.Cs()).ln()));},t.prototype.qs=function(t){if(!this.cs()&&!this.vs()&&null!==this.$n){this.us({_s:!1}),(t=this.En-t)<0&&(t=0);var i=(this.$n+.2*(this.En-1))/(t+.2*(this.En-1)),n=f(this.Wn).ln();i=Math.max(i,.1),n.dn(i),this.ws(n);}},t.prototype.Us=function(){this.cs()||this.vs()||(this.$n=null,this.Wn=null);},t.prototype.Hs=function(t){this.fs()||null===this.Xn&&null===this.Wn&&(this.ti()||(this.Xn=t,this.Wn=f(this.Cs()).ln()));},t.prototype.Ys=function(t){if(!this.fs()&&null!==this.Xn){var i=f(this.Cs()).vn()/(this.gs()-1),n=t-this.Xn;this.ds()&&(n*=-1);var s=n*i,h=f(this.Wn).ln();h.wn(s),this.ws(h,!0),this.Kn=null;}},t.prototype.Ks=function(){this.fs()||null!==this.Xn&&(this.Xn=null,this.Wn=null);},t.prototype.$s=function(){return this.Zn||this.es(),this.Zn},t.prototype.ii=function(t,i){switch(this.ki.mode){case 2:return this.$s().format(at(t,i));case 3:return this.$s().format(lt(t,i));default:return this.Xs(t)}},t.prototype.Bn=function(t){switch(this.ki.mode){case 2:case 3:return this.$s().format(t);default:return this.Xs(t)}},t.prototype.Zs=function(t){return this.Xs(t,f(this.Js()).$s())},t.prototype.Gs=function(t,i){return t=at(t,i),gt.format(t)},t.prototype.Qs=function(){return this.Hn},t.prototype.th=function(t){this.zn={Rn:t,Pn:!1};},t.prototype.Ii=function(){this.Hn.forEach((function(t){return t.Ii()}));},t.prototype.es=function(){this.Kn=null;var t=this.Js(),i=100;null!==t&&(i=Math.round(1/t.ih())),this.Zn=yt,this.cs()?(this.Zn=gt,i=100):this.vs()?(this.Zn=new Q(100,1),i=100):null!==t&&(this.Zn=t.$s()),this.ts=new Mt(this,i,this.ns.bind(this),this.ss.bind(this)),this.ts.Sn();},t.prototype.zs=function(){this.Yn=null;},t.prototype.Js=function(){return this.Hn[0]||null},t.prototype.ys=function(){return this.ds()?this.ki.scaleMargins.bottom*this.Mt()+this.jn:this.ki.scaleMargins.top*this.Mt()+this.In},t.prototype.ks=function(){return this.ds()?this.ki.scaleMargins.top*this.Mt()+this.In:this.ki.scaleMargins.bottom*this.Mt()+this.jn},t.prototype.Ns=function(){this.zn.Pn||(this.zn.Pn=!0,this.nh());},t.prototype.ls=function(){this.Vn=null;},t.prototype.ss=function(t,i){if(this.Ns(),this.ti())return 0;t=this.Ln()&&t?ct(t):t;var n=f(this.Cs()),s=this.ks()+(this.gs()-1)*(t-n.fn())/n.vn();return this.xs(s)},t.prototype.ns=function(t,i){if(this.Ns(),this.ti())return 0;var n=this.xs(t),s=f(this.Cs()),h=s.fn()+s.vn()*((n-this.ks())/(this.gs()-1));return this.Ln()?vt(h):h},t.prototype.Ms=function(){this.Kn=null,this.ts.Sn();},t.prototype.nh=function(){var t=this.zn.Rn;if(null!==t){for(var i=null,n=0,s=0,h=0,r=this.Qs();h<r.length;h++){var e=r[h];if(e.U()){var u=e.H();if(null!==u){var a=e.sh(t.hh(),t.rh()),o=a&&a.Cs();if(null!==o){switch(this.ki.mode){case 1:o=_t(o);break;case 2:o=ot(o,u.X);break;case 3:o=ft(o,u.X);}if(i=null===i?o:i._n(f(o)),null!==a){var l=a.eh();null!==l&&(n=Math.max(n,l.above),s=Math.max(n,l.below));}}}}}if(n===this.In&&s===this.jn||(this.In=n,this.jn=s,this.Kn=null,this.ls()),null!==i){if(i.fn()===i.cn()){var c=this.Js(),v=5*(null===c||this.cs()||this.vs()?1:c.ih());i=new nt(i.fn()-v,i.cn()+v);}this.ws(i);}else null===this.On&&this.ws(new nt(-.5,.5));this.zn.Pn=!0;}},t.prototype.Ds=function(){return this.cs()?at:this.vs()?lt:this.Ln()?ct:null},t.prototype.Xs=function(t,i){return void 0===this.Qn.priceFormatter?(void 0===i&&(i=this.$s()),i.format(t)):this.Qn.priceFormatter(t)},t}();function Ct(t){void 0!==t.borderColor&&(t.borderUpColor=t.borderColor,t.borderDownColor=t.borderColor),void 0!==t.wickColor&&(t.wickUpColor=t.wickColor,t.wickDownColor=t.wickColor);}!function(t){t[t.Disabled=0]="Disabled",t[t.Continuous=1]="Continuous",t[t.OnDataUpdate=2]="OnDataUpdate";}(mt||(mt={})),function(t){t[t.LastBar=0]="LastBar",t[t.LastVisible=1]="LastVisible";}(pt||(pt={}));var Nt=function(t){return t.getUTCFullYear()};function xt(t,i,n){return i.replace(/yyyy/g,function(t){return G(Nt(t),4)}(t)).replace(/yy/g,function(t){return G(Nt(t)%100,2)}(t)).replace(/MMMM/g,function(t,i){return new Date(t.getUTCFullYear(),t.getUTCMonth(),1).toLocaleString(i,{month:"long"})}(t,n)).replace(/MMM/g,function(t,i){return new Date(t.getUTCFullYear(),t.getUTCMonth(),1).toLocaleString(i,{month:"short"})}(t,n)).replace(/MM/g,function(t){return G(function(t){return t.getUTCMonth()+1}(t),2)}(t)).replace(/dd/g,function(t){return G(function(t){return t.getUTCDate()}(t),2)}(t))}var St=function(){function t(t,i){void 0===t&&(t="yyyy-MM-dd"),void 0===i&&(i="default"),this.uh=t,this.ah=i;}return t.prototype.oh=function(t){return xt(t,this.uh,this.ah)},t}(),Dt=function(){function t(t){this.lh=t||"%h:%m:%s";}return t.prototype.oh=function(t){return this.lh.replace("%h",G(t.getUTCHours(),2)).replace("%m",G(t.getUTCMinutes(),2)).replace("%s",G(t.getUTCSeconds(),2))},t}(),At={fh:"yyyy-MM-dd",_h:"%h:%m:%s",dh:" ",wh:"default"},Tt=function(){function t(t){void 0===t&&(t={});var i=u(u({},At),t);this.Mh=new St(i.fh,i.wh),this.bh=new Dt(i._h),this.mh=i.dh;}return t.prototype.oh=function(t){return ""+this.Mh.oh(t)+this.mh+this.bh.oh(t)},t}();function Bt(t,i,n,s,h){void 0===s&&(s=0),void 0===h&&(h=t.length);for(var r=h-s;0<r;){var e=r>>1,u=s+e;n(t[u],i)?(s=u+1,r-=e+1):r=e;}return s}function Lt(t,i,n,s,h){void 0===s&&(s=0),void 0===h&&(h=t.length);for(var r=h-s;0<r;){var e=r>>1,u=s+e;n(i,t[u])?r=e:(s=u+1,r-=e+1);}return s}var Ft=function(){function t(t,i){void 0===i&&(i=50),this.ph=0,this.gh=1,this.yh=1,this.kh=new Map,this.Ch=new Map,this.Nh=t,this.xh=i;}return t.prototype.oh=function(t){var i=void 0===t.Sh?new Date(1e3*t.Dh).getTime():new Date(Date.UTC(t.Sh.year,t.Sh.month-1,t.Sh.day)).getTime(),n=this.kh.get(i);if(void 0!==n)return n.Ah;if(this.ph===this.xh){var s=this.Ch.get(this.yh);this.Ch.delete(this.yh),this.kh.delete(l(s)),this.yh++,this.ph--;}var h=this.Nh(t);return this.kh.set(i,{Ah:h,Th:this.gh}),this.Ch.set(this.gh,i),this.ph++,this.gh++,h},t}(),Et=function(){function t(t,i){o(t<=i,"right should be >= left"),this.Bh=t,this.Lh=i;}return t.prototype.hh=function(){return this.Bh},t.prototype.rh=function(){return this.Lh},t.prototype.Fh=function(){return this.Lh-this.Bh+1},t.prototype.Eh=function(t){return this.Bh<=t&&t<=this.Lh},t.prototype.on=function(t){return this.Bh===t.hh()&&this.Lh===t.rh()},t}();function Vt(t,i){return null===t||null===i?t===i:t.on(i)}var Ot,Wt=function(){function t(){this.Vh=new Map,this.kh=null;}return t.prototype.Oh=function(t,i){this.Wh(i),this.kh=null;for(var n=i;n<t.length;++n){var s=t[n],h=this.Vh.get(s.zh);void 0===h&&(h=[],this.Vh.set(s.zh,h)),h.push({Ph:n,S:s.S,Rh:s.zh});}},t.prototype.Ih=function(t,i){var n=Math.ceil(i/t);return null!==this.kh&&this.kh.jh===n||(this.kh={Fn:this.qh(n),jh:n}),this.kh.Fn},t.prototype.Wh=function(t){if(0!==t){var i=[];this.Vh.forEach((function(n,s){t<=n[0].Ph?i.push(s):n.splice(Bt(n,t,(function(i){return i.Ph<t})),1/0);}));for(var n=0,s=i;n<s.length;n++){var h=s[n];this.Vh.delete(h);}}else this.Vh.clear();},t.prototype.qh=function(t){for(var i=[],n=0,s=Array.from(this.Vh.keys()).sort((function(t,i){return i-t}));n<s.length;n++){var h=s[n];if(this.Vh.get(h)){var r=i;i=[];for(var e=r.length,u=0,a=l(this.Vh.get(h)),o=a.length,f=1/0,c=-1/0,v=0;v<o;v++){for(var _=a[v],d=_.Ph;u<e;){var w=r[u],M=w.Ph;if(!(M<d)){f=M;break}u++,i.push(w),c=M,f=1/0;}f-d>=t&&d-c>=t&&(i.push(_),c=d);}for(;u<e;u++)i.push(r[u]);}}return i},t}(),zt=function(){function t(t){this.Uh=t;}return t.prototype.Hh=function(){return null===this.Uh?null:new Et(Math.floor(this.Uh.hh()),Math.ceil(this.Uh.rh()))},t.prototype.Yh=function(){return this.Uh},t.Kh=function(){return new t(null)},t}();!function(t){t[t.Year=0]="Year",t[t.Month=1]="Month",t[t.DayOfMonth=2]="DayOfMonth",t[t.Time=3]="Time",t[t.TimeWithSeconds=4]="TimeWithSeconds";}(Ot||(Ot={}));var Pt,Rt=function(){function t(t,i,n){this.$h=0,this.Xh=null,this.Zh=[],this.Xn=null,this.$n=null,this.Jh=new Wt,this.Gh=new Map,this.Qh=zt.Kh(),this.tr=!0,this.ir=new it,this.nr=new it,this.sr=new it,this.hr=null,this.rr=null,this.er=[],this.ki=i,this.Qn=n,this.ur=i.rightOffset,this.ar=i.barSpacing,this.hi=t,this.lr();}return t.prototype.ct=function(){return this.ki},t.prototype.cr=function(t){v(this.Qn,t),this.vr(),this.lr();},t.prototype.rs=function(t,i){var n;v(this.ki,t),this.ki.fixLeftEdge&&this._r(),this.ki.fixRightEdge&&this.dr(),void 0!==t.barSpacing&&this.hi.wr(t.barSpacing),void 0!==t.rightOffset&&this.hi.Mr(t.rightOffset),void 0!==t.minBarSpacing&&this.hi.wr(null!==(n=t.barSpacing)&&void 0!==n?n:this.ar),this.vr(),this.lr(),this.sr.hn();},t.prototype.ri=function(t){var i;return (null===(i=this.Zh[t])||void 0===i?void 0:i.S)||null},t.prototype.br=function(t,i){if(this.Zh.length<1)return null;if(t.Dh>this.Zh[this.Zh.length-1].S.Dh)return i?this.Zh.length-1:null;var n=Bt(this.Zh,t.Dh,(function(t,i){return t.S.Dh<i}));return t.Dh<this.Zh[n].S.Dh?i?n:null:n},t.prototype.ti=function(){return 0===this.$h||0===this.Zh.length},t.prototype.mr=function(){return this.pr(),this.Qh.Hh()},t.prototype.gr=function(){return this.pr(),this.Qh.Yh()},t.prototype.yr=function(){var t=this.mr();if(null===t)return null;var i={from:t.hh(),to:t.rh()};return this.kr(i)},t.prototype.kr=function(t){var i=Math.round(t.from),n=Math.round(t.to),s=f(this.Cr()),h=f(this.Nr());return {from:f(this.ri(Math.max(s,i))),to:f(this.ri(Math.min(h,n)))}},t.prototype.Sr=function(t){return {from:f(this.br(t.from,!0)),to:f(this.br(t.to,!0))}},t.prototype.wt=function(){return this.$h},t.prototype.Dr=function(t){if(isFinite(t)&&!(t<=0)&&this.$h!==t){if(this.ki.lockVisibleTimeRangeOnResize&&this.$h){var i=this.ar*t/this.$h;this.ar=i;}if(this.ki.fixLeftEdge){var n=this.mr();if(null!==n)if(n.hh()<=0){var s=this.$h-t;this.ur-=Math.round(s/this.ar)+1;}}this.$h=t,this.tr=!0,this.Ar(),this.Tr();}},t.prototype.G=function(t){if(this.ti()||!d(t))return 0;var i=this.Br()+this.ur-t;return this.$h-(i+.5)*this.ar-1},t.prototype.Lr=function(t,i){for(var n=this.Br(),s=void 0===i?0:i.from,h=void 0===i?t.length:i.to,r=s;r<h;r++){var e=t[r].S,u=n+this.ur-e,a=this.$h-(u+.5)*this.ar-1;t[r].p=a;}},t.prototype.Fr=function(t){return Math.ceil(this.Er(t))},t.prototype.Mr=function(t){this.tr=!0,this.ur=t,this.Tr(),this.hi.Vr(),this.hi.Or();},t.prototype.Wr=function(){return this.ar},t.prototype.wr=function(t){this.zr(t),this.Tr(),this.hi.Vr(),this.hi.Or();},t.prototype.Pr=function(){return this.ur},t.prototype.Fn=function(){if(this.ti())return null;if(null!==this.rr)return this.rr;for(var t=this.ar,i=5*(this.hi.ct().layout.fontSize+4),n=Math.round(i/t),s=f(this.mr()),h=Math.max(s.hh(),s.hh()-n),r=Math.max(s.rh(),s.rh()-n),e=this.Jh.Ih(t,i),u=this.Cr()+n,a=this.Nr()-n,o=0,l=0,c=e;l<c.length;l++){var v=c[l];if(h<=v.Ph&&v.Ph<=r){var _=void 0;o<this.er.length?((_=this.er[o]).An=this.G(v.Ph),_.Tn=this.Rr(v.S,v.Rh),_.Rh=v.Rh):(_={Ir:!1,An:this.G(v.Ph),Tn:this.Rr(v.S,v.Rh),Rh:v.Rh},this.er.push(_)),this.ar>i/2?_.Ir=!1:_.Ir=this.ki.fixLeftEdge&&v.Ph<=u||this.ki.fixRightEdge&&v.Ph>=a,o++;}}return this.er.length=o,this.rr=this.er,this.er},t.prototype.jr=function(){this.tr=!0,this.wr(this.ki.barSpacing),this.Mr(this.ki.rightOffset);},t.prototype.qr=function(t){this.tr=!0,this.Xh=t,this.Tr(),this._r();},t.prototype.Ur=function(t,i){var n=this.Er(t),s=this.Wr(),h=s+i*(s/10);this.wr(h),this.ki.rightBarStaysOnScroll||this.Mr(this.Pr()+(n-this.Er(t)));},t.prototype.js=function(t){this.Xn&&this.Ks(),null===this.$n&&null===this.hr&&(this.ti()||(this.$n=t,this.Hr()));},t.prototype.qs=function(t){if(null!==this.hr){var i=st(this.$h-t,0,this.$h),n=st(this.$h-f(this.$n),0,this.$h);0!==i&&0!==n&&this.wr(this.hr.Wr*i/n);}},t.prototype.Us=function(){null!==this.$n&&(this.$n=null,this.Yr());},t.prototype.Hs=function(t){null===this.Xn&&null===this.hr&&(this.ti()||(this.Xn=t,this.Hr()));},t.prototype.Ys=function(t){if(null!==this.Xn){var i=(this.Xn-t)/this.Wr();this.ur=f(this.hr).Pr+i,this.tr=!0,this.Tr();}},t.prototype.Ks=function(){null!==this.Xn&&(this.Xn=null,this.Yr());},t.prototype.Kr=function(){this.$r(this.ki.rightOffset);},t.prototype.$r=function(t,i){var n=this;if(void 0===i&&(i=400),!isFinite(t))throw new RangeError("offset is required and must be finite number");if(!isFinite(i)||i<=0)throw new RangeError("animationDuration (optional) must be finite positive number");var s=this.ur,h=performance.now(),r=function(){var e=(performance.now()-h)/i,u=e>=1,a=u?t:s+(t-s)*e;n.Mr(a),u||setTimeout(r,20);};r();},t.prototype.O=function(t,i){this.tr=!0,this.Zh=t,this.Jh.Oh(t,i),this.Tr();},t.prototype.Xr=function(){return this.ir},t.prototype.Zr=function(){return this.nr},t.prototype.Jr=function(){return this.sr},t.prototype.Br=function(){return this.Xh||0},t.prototype.Gr=function(t){var i=t.Fh();this.zr(this.$h/i),this.ur=t.rh()-this.Br(),this.Tr(),this.tr=!0,this.hi.Vr(),this.hi.Or();},t.prototype.Qr=function(){var t=this.Cr(),i=this.Nr();null!==t&&null!==i&&this.Gr(new Et(t,i+this.ki.rightOffset));},t.prototype.te=function(t){var i=new Et(t.from,t.to);this.Gr(i);},t.prototype.ei=function(t){return void 0!==this.Qn.timeFormatter?this.Qn.timeFormatter(t.Sh||t.Dh):this.ie.oh(new Date(1e3*t.Dh))},t.prototype.Cr=function(){return 0===this.Zh.length?null:0},t.prototype.Nr=function(){return 0===this.Zh.length?null:this.Zh.length-1},t.prototype.ne=function(t){return (this.$h-1-t)/this.ar},t.prototype.Er=function(t){var i=this.ne(t),n=this.Br()+this.ur-i;return Math.round(1e6*n)/1e6},t.prototype.zr=function(t){var i=this.ar;this.ar=t,this.Ar(),i!==this.ar&&(this.tr=!0,this.se());},t.prototype.pr=function(){if(this.tr)if(this.tr=!1,this.ti())this.he(zt.Kh());else {var t=this.Br(),i=this.$h/this.ar,n=this.ur+t,s=new Et(n-i+1,n);this.he(new zt(s));}},t.prototype.Ar=function(){var t=this.re();if(this.ar<t&&(this.ar=t,this.tr=!0),0!==this.$h){var i=.5*this.$h;this.ar>i&&(this.ar=i,this.tr=!0);}},t.prototype.re=function(){return this.ki.fixLeftEdge&&this.ki.fixRightEdge&&0!==this.Zh.length?this.$h/this.Zh.length:this.ki.minBarSpacing},t.prototype.Tr=function(){var t=this.ee();this.ur>t&&(this.ur=t,this.tr=!0);var i=this.ue();null!==i&&this.ur<i&&(this.ur=i,this.tr=!0);},t.prototype.ue=function(){var t=this.Cr(),i=this.Xh;return null===t||null===i?null:t-i-1+(this.ki.fixLeftEdge?this.$h/this.ar:Math.min(2,this.Zh.length))},t.prototype.ee=function(){return this.ki.fixRightEdge?0:this.$h/this.ar-Math.min(2,this.Zh.length)},t.prototype.Hr=function(){this.hr={Wr:this.Wr(),Pr:this.Pr()};},t.prototype.Yr=function(){this.hr=null;},t.prototype.Rr=function(t,i){var n=this,s=this.Gh.get(i);return void 0===s&&(s=new Ft((function(t){return n.ae(t,i)})),this.Gh.set(i,s)),s.oh(t)},t.prototype.ae=function(t,i){var n,s=function(t,i,n){switch(t){case 0:case 10:return i?n?4:3:2;case 20:case 21:case 22:case 30:case 31:case 32:case 33:return i?3:2;case 50:return 2;case 60:return 1;case 70:return 0}}(i,this.ki.timeVisible,this.ki.secondsVisible);return void 0!==this.ki.tickMarkFormatter?this.ki.tickMarkFormatter(null!==(n=t.Sh)&&void 0!==n?n:t.Dh,s,this.Qn.locale):function(t,i,n){var s={};switch(i){case 0:s.year="numeric";break;case 1:s.month="short";break;case 2:s.day="numeric";break;case 3:s.hour12=!1,s.hour="2-digit",s.minute="2-digit";break;case 4:s.hour12=!1,s.hour="2-digit",s.minute="2-digit",s.second="2-digit";}var h=void 0===t.Sh?new Date(1e3*t.Dh):new Date(Date.UTC(t.Sh.year,t.Sh.month-1,t.Sh.day));return new Date(h.getUTCFullYear(),h.getUTCMonth(),h.getUTCDate(),h.getUTCHours(),h.getUTCMinutes(),h.getUTCSeconds(),h.getUTCMilliseconds()).toLocaleString(n,s)}(t,s,this.Qn.locale)},t.prototype.he=function(t){var i=this.Qh;this.Qh=t,Vt(i.Hh(),this.Qh.Hh())||this.ir.hn(),Vt(i.Yh(),this.Qh.Yh())||this.nr.hn(),this.se();},t.prototype.se=function(){this.rr=null;},t.prototype.vr=function(){this.se(),this.Gh.clear();},t.prototype.lr=function(){var t=this.Qn.dateFormat;this.ki.timeVisible?this.ie=new Tt({fh:t,_h:this.ki.secondsVisible?"%h:%m:%s":"%h:%m",dh:"   ",wh:this.Qn.locale}):this.ie=new St(t,this.Qn.locale);},t.prototype._r=function(){if(this.ki.fixLeftEdge){var t=this.Cr();if(null!==t){var i=this.mr();if(null!==i){var n=i.hh()-t;if(n<0){var s=this.ur-n-1;this.Mr(s);}this.Ar();}}}},t.prototype.dr=function(){this.Tr(),this.Ar();},t}();function It(t){return !_(t)&&!w(t)}function jt(t){return _(t)}!function(t){t.Solid="solid",t.VerticalGradient="gradient";}(Pt||(Pt={}));var qt="'Trebuchet MS', Roboto, Ubuntu, sans-serif";function Ut(t,i,n){return void 0!==n?n+=" ":n="",void 0===i&&(i=qt),""+n+t+"px "+i}var Ht=function(){function t(t){this.oe={At:1,Dt:4,Wt:NaN,Nt:"",le:"",et:"",Bt:0,Lt:0,Ft:0,Tt:0,Ot:0},this.F=t;}return t.prototype.ct=function(){var t=this.oe,i=this.fe(),n=this.ce();return t.Wt===i&&t.le===n||(t.Wt=i,t.le=n,t.Nt=Ut(i,n),t.Tt=Math.floor(i/3.5),t.Bt=t.Tt,t.Lt=Math.max(Math.ceil(i/2-t.Dt/2),0),t.Ft=Math.ceil(i/2+t.Dt/2),t.Ot=Math.round(i/10)),t.et=this.ve(),this.oe},t.prototype.ve=function(){return this.F.ct().layout.textColor},t.prototype.fe=function(){return this.F.ct().layout.fontSize},t.prototype.ce=function(){return this.F.ct().layout.fontFamily},t}();function Yt(t){return "left"===t||"right"===t}var Kt=function(){function t(t){this._e=new Map,this.de=!1,this.we=[],this.Me=t;}return t.prototype.be=function(t,i){var n=function(t,i){return void 0===t?i:{me:Math.max(t.me,i.me),_s:t._s||i._s}}(this._e.get(t),i);this._e.set(t,n);},t.prototype.pe=function(){return this.Me},t.prototype.ge=function(t){var i=this._e.get(t);return void 0===i?{me:this.Me}:{me:Math.max(this.Me,i.me),_s:i._s}},t.prototype.ye=function(){this.we=[{ke:0}];},t.prototype.Ce=function(t){this.we=[{ke:1,X:t}];},t.prototype.Ne=function(){this.we=[{ke:4}];},t.prototype.wr=function(t){this.we.push({ke:2,X:t});},t.prototype.Mr=function(t){this.we.push({ke:3,X:t});},t.prototype.xe=function(){return this.we},t.prototype._n=function(t){var i=this;this.de=this.de||t.de,this.we=this.we.concat(t.we);for(var n=0,s=t.we;n<s.length;n++){var h=s[n];this.Se(h);}this.Me=Math.max(this.Me,t.Me),t._e.forEach((function(t,n){i.be(n,t);}));},t.prototype.Se=function(t){switch(t.ke){case 0:this.ye();break;case 1:this.Ce(t.X);break;case 2:this.wr(t.X);break;case 3:this.Mr(t.X);break;case 4:this.Ne();}},t}(),$t=function(){function t(t){this.De=t;}return t.prototype.format=function(t){var i="";return t<0&&(i="-",t=-t),t<995?i+this.Ae(t):t<999995?i+this.Ae(t/1e3)+"K":t<999999995?(t=1e3*Math.round(t/1e3),i+this.Ae(t/1e6)+"M"):(t=1e6*Math.round(t/1e6),i+this.Ae(t/1e9)+"B")},t.prototype.Ae=function(t){var i=Math.pow(10,this.De);return ((t=Math.round(t*i)/i)>=1e-15&&t<1?t.toFixed(this.De).replace(/\.?0+$/,""):String(t)).replace(/(\.[1-9]*)0+$/,(function(t,i){return i}))},t}();function Xt(t,i,n,s){if(0!==i.length){var h=i[s.from].p,r=i[s.from].g;t.moveTo(h,r);for(var e=s.from+1;e<s.to;++e){var u=i[e];if(1===n){var a=i[e-1].g,o=u.p;t.lineTo(o,a);}t.lineTo(u.p,u.g);}}}var Zt=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.v=null,i}return e(i,t),i.prototype._=function(t){this.v=t;},i.prototype.u=function(t){if(null!==this.v&&0!==this.v.m.length&&null!==this.v.M){if(t.lineCap="butt",t.lineJoin="round",t.lineWidth=this.v.rt,s(t,this.v.ut),t.lineWidth=1,t.beginPath(),1===this.v.m.length){var i=this.v.m[0],n=this.v.Te/2;t.moveTo(i.p-n,this.v.Be),t.lineTo(i.p-n,i.g),t.lineTo(i.p+n,i.g),t.lineTo(i.p+n,this.v.Be);}else t.moveTo(this.v.m[this.v.M.from].p,this.v.Be),t.lineTo(this.v.m[this.v.M.from].p,this.v.m[this.v.M.from].g),Xt(t,this.v.m,this.v.Le,this.v.M),this.v.M.to>this.v.M.from&&(t.lineTo(this.v.m[this.v.M.to-1].p,this.v.Be),t.lineTo(this.v.m[this.v.M.from].p,this.v.Be));t.closePath(),t.fillStyle=this.Fe(t),t.fill();}},i}(y),Jt=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.Fe=function(t){var i=this.v,n=t.createLinearGradient(0,0,0,i.Ee);return n.addColorStop(0,i.Ve),n.addColorStop(1,i.Oe),n},i}(Zt),Gt=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.v=null,i}return e(i,t),i.prototype._=function(t){this.v=t;},i.prototype.u=function(t){if(null!==this.v&&0!==this.v.m.length&&null!==this.v.M){if(t.lineCap="butt",t.lineWidth=this.v.rt,s(t,this.v.ut),t.strokeStyle=this.We(t),t.lineJoin="round",t.beginPath(),1===this.v.m.length){var i=this.v.m[0];t.moveTo(i.p-this.v.Te/2,i.g),t.lineTo(i.p+this.v.Te/2,i.g);}else Xt(t,this.v.m,this.v.Le,this.v.M);t.stroke();}},i}(y),Qt=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.We=function(){return this.v.N},i}(Gt);function ti(t,i){return t.S<i}function ii(t,i){return t<i.S}function ni(t,i,n){var s=i.hh(),h=i.rh(),r=Bt(t,s,ti),e=Lt(t,h,ii);if(!n)return {from:r,to:e};var u=r,a=e;return r>0&&r<t.length&&t[r].S>=s&&(u=r-1),e>0&&e<t.length&&t[e-1].S<=h&&(a=e+1),{from:u,to:a}}var si=function(){function t(t,i,n){this.ze=!0,this.Pe=!0,this.Re=!0,this.Ie=[],this.je=null,this.qe=t,this.Ue=i,this.He=n;}return t.prototype.O=function(t){this.ze=!0,"data"===t&&(this.Pe=!0),"options"===t&&(this.Re=!0);},t.prototype.Ye=function(){this.Pe&&(this.Ke(),this.Pe=!1),this.ze&&(this.$e(),this.ze=!1),this.Re&&(this.Xe(),this.Re=!1);},t.prototype.Ze=function(){this.je=null;},t.prototype.$e=function(){var t=this.qe.$(),i=this.Ue.j();if(this.Ze(),!i.ti()&&!t.ti()){var n=i.mr();if(null!==n&&0!==this.qe.Hi().Je()){var s=this.qe.H();null!==s&&(this.je=ni(this.Ie,n,this.He),this.Ge(t,i,s.X));}}},t}(),hi=function(t){function i(i,n){return t.call(this,i,n,!0)||this}return e(i,t),i.prototype.Ge=function(t,i,n){i.Lr(this.Ie,p(this.je)),t.Ss(this.Ie,n,p(this.je));},i.prototype.Qe=function(t,i){return {S:t,D:i,p:NaN,g:NaN}},i.prototype.Xe=function(){},i.prototype.Ke=function(){var t=this,i=this.qe.tu();this.Ie=this.qe.Hi().iu().map((function(n){var s=n.X[3];return t.nu(n.Ph,s,i)}));},i}(si),ri=function(t){function i(i,n){var s=t.call(this,i,n)||this;return s.ot=new g,s.su=new Jt,s.hu=new Qt,s.ot.i([s.su,s.hu]),s}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.ct();return this.Ye(),this.su._({Le:n.lineType,m:this.Ie,ut:n.lineStyle,rt:n.lineWidth,Ve:n.topColor,Oe:n.bottomColor,Be:t,Ee:t,M:this.je,Te:this.Ue.j().Wr()}),this.hu._({Le:n.lineType,m:this.Ie,N:n.lineColor,ut:n.lineStyle,rt:n.lineWidth,M:this.je,Te:this.Ue.j().Wr()}),this.ot},i.prototype.nu=function(t,i){return this.Qe(t,i)},i}(hi);var ei=function(){function t(){this.tt=null,this.ru=0,this.eu=0;}return t.prototype._=function(t){this.tt=t;},t.prototype.h=function(t,i,n,s){if(null!==this.tt&&0!==this.tt.Hi.length&&null!==this.tt.M){if(this.ru=this.uu(i),this.ru>=2)Math.max(1,Math.floor(i))%2!=this.ru%2&&this.ru--;this.eu=this.tt.au?Math.min(this.ru,Math.floor(i)):this.ru;for(var h=null,r=this.eu<=this.ru&&this.tt.Wr>=Math.floor(1.5*i),e=this.tt.M.from;e<this.tt.M.to;++e){var u=this.tt.Hi[e];h!==u.et&&(t.fillStyle=u.et,h=u.et);var a=Math.floor(.5*this.eu),o=Math.round(u.p*i),l=o-a,f=this.eu,c=l+f-1,v=Math.min(u.Bs,u.Ls),_=Math.max(u.Bs,u.Ls),d=Math.round(v*i)-a,w=Math.round(_*i)+a,M=Math.max(w-d,this.eu);t.fillRect(l,d,f,M);var b=Math.ceil(1.5*this.ru);if(r){if(this.tt.ou){var m=o-b,p=Math.max(d,Math.round(u.Ts*i)-a),g=p+f-1;g>d+M-1&&(p=(g=d+M-1)-f+1),t.fillRect(m,p,l-m,g-p+1);}var y=o+b,k=Math.max(d,Math.round(u.Fs*i)-a),C=k+f-1;C>d+M-1&&(k=(C=d+M-1)-f+1),t.fillRect(c+1,k,y-c,C-k+1);}}}},t.prototype.uu=function(t){var i=Math.floor(t);return Math.max(i,Math.floor(function(t,i){return Math.floor(.3*t*i)}(f(this.tt).Wr,t)))},t}(),ui=function(t){function i(i,n){return t.call(this,i,n,!1)||this}return e(i,t),i.prototype.Ge=function(t,i,n){i.Lr(this.Ie,p(this.je)),t.As(this.Ie,n,p(this.je));},i.prototype.lu=function(t,i,n){return {S:t,open:i.X[0],high:i.X[1],low:i.X[2],close:i.X[3],p:NaN,Ts:NaN,Bs:NaN,Ls:NaN,Fs:NaN}},i.prototype.Ke=function(){var t=this,i=this.qe.tu();this.Ie=this.qe.Hi().iu().map((function(n){return t.nu(n.Ph,n,i)}));},i}(si),ai=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.ot=new ei,i}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.ct();this.Ye();var s={Hi:this.Ie,Wr:this.Ue.j().Wr(),ou:n.openVisible,au:n.thinBars,M:this.je};return this.ot._(s),this.ot},i.prototype.Xe=function(){var t=this;this.Ie.forEach((function(i){i.et=t.qe.tu().cu(i.S).fu;}));},i.prototype.nu=function(t,i,n){return u(u({},this.lu(t,i,n)),{et:n.cu(t).fu})},i}(ui),oi=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.Fe=function(t){var i=this.v,n=t.createLinearGradient(0,0,0,i.Ee),s=st(i.Be/i.Ee,0,1);return n.addColorStop(0,i.vu),n.addColorStop(s,i._u),n.addColorStop(s,i.du),n.addColorStop(1,i.wu),n},i}(Zt),li=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.We=function(t){var i=this.v,n=t.createLinearGradient(0,0,0,i.Ee),s=st(i.Be/i.Ee,0,1);return n.addColorStop(0,i.Ve),n.addColorStop(s,i.Ve),n.addColorStop(s,i.Oe),n.addColorStop(1,i.Oe),n},i}(Gt),fi=function(t){function i(i,n){var s=t.call(this,i,n)||this;return s.Mu=new oi,s.bu=new li,s.A=new g,s.A.i([s.Mu,s.bu]),s}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.H();if(null===n)return null;var s=this.qe.ct();this.Ye();var h=this.qe.$().K(s.baseValue.price,n.X),r=this.Ue.j().Wr();return this.Mu._({m:this.Ie,vu:s.topFillColor1,_u:s.topFillColor2,du:s.bottomFillColor1,wu:s.bottomFillColor2,rt:s.lineWidth,ut:s.lineStyle,Le:0,Be:h,Ee:t,M:this.je,Te:r}),this.bu._({m:this.Ie,Ve:s.topLineColor,Oe:s.bottomLineColor,rt:s.lineWidth,ut:s.lineStyle,Le:0,Be:h,Ee:t,M:this.je,Te:r}),this.A},i.prototype.nu=function(t,i){return this.Qe(t,i)},i}(hi),ci=function(){function t(){this.tt=null,this.ru=0;}return t.prototype._=function(t){this.tt=t;},t.prototype.h=function(t,i,n,s){if(null!==this.tt&&0!==this.tt.Hi.length&&null!==this.tt.M){if(this.ru=function(t,i){if(t>=2.5&&t<=4)return Math.floor(3*i);var n=1-.2*Math.atan(Math.max(4,t)-4)/(.5*Math.PI),s=Math.floor(t*n*i),h=Math.floor(t*i),r=Math.min(s,h);return Math.max(Math.floor(i),r)}(this.tt.Wr,i),this.ru>=2)Math.floor(i)%2!=this.ru%2&&this.ru--;var h=this.tt.Hi;this.tt.mu&&this.pu(t,h,this.tt.M,i),this.tt.gu&&this.yu(t,h,this.tt.M,this.tt.Wr,i);var r=this.ku(i);(!this.tt.gu||this.ru>2*r)&&this.Cu(t,h,this.tt.M,i);}},t.prototype.pu=function(t,i,n,s){if(null!==this.tt){var h="",r=Math.min(Math.floor(s),Math.floor(this.tt.Wr*s));r=Math.max(Math.floor(s),Math.min(r,this.ru));for(var e=Math.floor(.5*r),u=null,a=n.from;a<n.to;a++){var o=i[a];o.Nu!==h&&(t.fillStyle=o.Nu,h=o.Nu);var l=Math.round(Math.min(o.Ts,o.Fs)*s),f=Math.round(Math.max(o.Ts,o.Fs)*s),c=Math.round(o.Bs*s),v=Math.round(o.Ls*s),_=Math.round(s*o.p)-e,d=_+r-1;null!==u&&(_=Math.max(u+1,_),_=Math.min(_,d));var w=d-_+1;t.fillRect(_,c,w,l-c),t.fillRect(_,f+1,w,v-f),u=d;}}},t.prototype.ku=function(t){var i=Math.floor(1*t);this.ru<=2*i&&(i=Math.floor(.5*(this.ru-1)));var n=Math.max(Math.floor(t),i);return this.ru<=2*n?Math.max(Math.floor(t),Math.floor(1*t)):n},t.prototype.yu=function(t,i,n,s,h){if(null!==this.tt)for(var r="",e=this.ku(h),u=null,a=n.from;a<n.to;a++){var o=i[a];o.Z!==r&&(t.fillStyle=o.Z,r=o.Z);var l=Math.round(o.p*h)-Math.floor(.5*this.ru),f=l+this.ru-1,c=Math.round(Math.min(o.Ts,o.Fs)*h),v=Math.round(Math.max(o.Ts,o.Fs)*h);if(null!==u&&(l=Math.max(u+1,l),l=Math.min(l,f)),this.tt.Wr*h>2*e)z(t,l,c,f-l+1,v-c+1,e);else {var _=f-l+1;t.fillRect(l,c,_,v-c+1);}u=f;}},t.prototype.Cu=function(t,i,n,s){if(null!==this.tt)for(var h="",r=this.ku(s),e=n.from;e<n.to;e++){var u=i[e],a=Math.round(Math.min(u.Ts,u.Fs)*s),o=Math.round(Math.max(u.Ts,u.Fs)*s),l=Math.round(u.p*s)-Math.floor(.5*this.ru),f=l+this.ru-1;if(u.et!==h){var c=u.et;t.fillStyle=c,h=c;}this.tt.gu&&(l+=r,a+=r,f-=r,o-=r),a>o||t.fillRect(l,a,f-l+1,o-a+1);}},t}(),vi=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.ot=new ci,i}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.ct();this.Ye();var s={Hi:this.Ie,Wr:this.Ue.j().Wr(),mu:n.wickVisible,gu:n.borderVisible,M:this.je};return this.ot._(s),this.ot},i.prototype.Xe=function(){var t=this;this.Ie.forEach((function(i){var n=t.qe.tu().cu(i.S);i.et=n.fu,i.Nu=n.xu,i.Z=n.Su;}));},i.prototype.nu=function(t,i,n){var s=n.cu(t);return u(u({},this.lu(t,i,n)),{et:s.fu,Nu:s.xu,Z:s.Su})},i}(ui),_i=function(){function t(){this.tt=null,this.Du=[];}return t.prototype._=function(t){this.tt=t,this.Du=[];},t.prototype.h=function(t,i,n,s){if(null!==this.tt&&0!==this.tt.m.length&&null!==this.tt.M){this.Du.length||this.Au(i);for(var h=Math.max(1,Math.floor(i)),r=Math.round(this.tt.Tu*i)-Math.floor(h/2),e=r+h,u=this.tt.M.from;u<this.tt.M.to;u++){var a=this.tt.m[u],o=this.Du[u-this.tt.M.from],l=Math.round(a.g*i);t.fillStyle=a.et;var f=void 0,c=void 0;l<=r?(f=l,c=e):(f=r,c=l-Math.floor(h/2)+h),t.fillRect(o.hh,f,o.rh-o.hh+1,c-f);}}},t.prototype.Au=function(t){if(null!==this.tt&&0!==this.tt.m.length&&null!==this.tt.M){var i=Math.ceil(this.tt.Wr*t)<=1?0:Math.max(1,Math.floor(t)),n=Math.round(this.tt.Wr*t)-i;this.Du=new Array(this.tt.M.to-this.tt.M.from);for(var s=this.tt.M.from;s<this.tt.M.to;s++){var h,r=this.tt.m[s],e=Math.round(r.p*t),u=void 0,a=void 0;if(n%2)u=e-(h=(n-1)/2),a=e+h;else u=e-(h=n/2),a=e+h-1;this.Du[s-this.tt.M.from]={hh:u,rh:a,Bu:e,Lu:r.p*t,S:r.S};}for(s=this.tt.M.from+1;s<this.tt.M.to;s++){var o=this.Du[s-this.tt.M.from],l=this.Du[s-this.tt.M.from-1];o.S===l.S+1&&(o.hh-l.rh!==i+1&&(l.Bu>l.Lu?l.rh=o.hh-i-1:o.hh=l.rh+i+1));}var f=Math.ceil(this.tt.Wr*t);for(s=this.tt.M.from;s<this.tt.M.to;s++){(o=this.Du[s-this.tt.M.from]).rh<o.hh&&(o.rh=o.hh);var c=o.rh-o.hh+1;f=Math.min(c,f);}if(i>0&&f<4)for(s=this.tt.M.from;s<this.tt.M.to;s++){(c=(o=this.Du[s-this.tt.M.from]).rh-o.hh+1)>f&&(o.Bu>o.Lu?o.rh-=1:o.hh+=1);}}else this.Du=[];},t}();function di(t){return {m:[],Wr:t,Tu:NaN,M:null}}function wi(t,i,n){return {S:t,D:i,p:NaN,g:NaN,et:n}}var Mi=function(t){function i(i,n){var s=t.call(this,i,n,!1)||this;return s.A=new g,s.Fu=di(0),s.ot=new _i,s}return e(i,t),i.prototype.P=function(t,i){return this.qe.U()?(this.Ye(),this.A):null},i.prototype.Ke=function(){var t=this.Ue.j().Wr();this.Fu=di(t);for(var i=0,n=0,s=this.qe.ct().color,h=0,r=this.qe.Hi().iu();h<r.length;h++){var e=r[h],u=e.X[3],a=void 0!==e.et?e.et:s,o=wi(e.Ph,u,a);++i<this.Fu.m.length?this.Fu.m[i]=o:this.Fu.m.push(o),this.Ie[n++]={S:e.Ph,p:0};}this.ot._(this.Fu),this.A.i([this.ot]);},i.prototype.Xe=function(){},i.prototype.Ze=function(){t.prototype.Ze.call(this),this.Fu.M=null;},i.prototype.Ge=function(t,i,n){if(null!==this.je){var s=i.Wr(),h=f(i.mr()),r=t.K(this.qe.ct().base,n);i.Lr(this.Fu.m),t.Ss(this.Fu.m,n),this.Fu.Tu=r,this.Fu.M=ni(this.Fu.m,h,!1),this.Fu.Wr=s,this.ot._(this.Fu);}},i}(si),bi=function(t){function i(i,n){var s=t.call(this,i,n)||this;return s.hu=new Qt,s}return e(i,t),i.prototype.P=function(t,i){if(!this.qe.U())return null;var n=this.qe.ct();this.Ye();var s={m:this.Ie,N:n.color,ut:n.lineStyle,Le:n.lineType,rt:n.lineWidth,M:this.je,Te:this.Ue.j().Wr()};return this.hu._(s),this.hu},i.prototype.nu=function(t,i){return this.Qe(t,i)},i}(hi),mi=/[2-9]/g,pi=function(){function t(t){void 0===t&&(t=50),this.kh=new Map,this.Eu=0,this.Vu=Array.from(new Array(t));}return t.prototype.Ou=function(){this.kh.clear(),this.Vu.fill(void 0);},t.prototype.Vt=function(t,i,n){var s=n||mi,h=String(i).replace(s,"0"),r=this.kh.get(h);if(void 0===r){if(0===(r=t.measureText(h).width)&&0!==i.length)return 0;var e=this.Vu[this.Eu];void 0!==e&&this.kh.delete(e),this.Vu[this.Eu]=h,this.Eu=(this.Eu+1)%this.Vu.length,this.kh.set(h,r);}return r},t}(),gi=function(){function t(t){this.Wu=null,this.oe=null,this.zu="right",this.$h=0,this.Pu=t;}return t.prototype.Ru=function(t,i,n,s){this.Wu=t,this.oe=i,this.$h=n,this.zu=s;},t.prototype.h=function(t,i){null!==this.oe&&null!==this.Wu&&this.Wu.h(t,this.oe,this.Pu,this.$h,this.zu,i);},t}(),yi=function(){function t(t,i,n){this.Iu=t,this.Pu=new pi(50),this.ju=i,this.F=n,this.fe=-1,this.ot=new gi(this.Pu);}return t.prototype.P=function(t,i){var n=this.F.qu(this.ju);if(null===n)return null;var s=n.Uu(this.ju)?n.xi():this.ju.$();if(null===s)return null;var h=n.Hu(s);if("overlay"===h)return null;var r=this.F.Yu();return r.Wt!==this.fe&&(this.fe=r.Wt,this.Pu.Ou()),this.ot.Ru(this.Iu.Zt(),r,i,h),this.ot},t}(),ki=function(){function t(){this.tt=null;}return t.prototype._=function(t){this.tt=t;},t.prototype.h=function(t,i,n,r){if(null!==this.tt&&!1!==this.tt.U){var e=Math.round(this.tt.g*i);if(!(e<0||e>Math.ceil(this.tt.Mt*i))){var u=Math.ceil(this.tt.wt*i);t.lineCap="butt",t.strokeStyle=this.tt.et,t.lineWidth=Math.floor(this.tt.rt*i),s(t,this.tt.ut),h(t,e,0,u);}}},t}(),Ci=function(){function t(t){this.Ku={wt:0,Mt:0,g:0,et:"rgba(0, 0, 0, 0)",rt:1,ut:0,U:!1},this.$u=new ki,this.L=!0,this.qe=t,this.Ue=t.vt(),this.$u._(this.Ku);}return t.prototype.O=function(){this.L=!0;},t.prototype.P=function(t,i){return this.qe.U()?(this.L&&(this.Xu(t,i),this.L=!1),this.$u):null},t}(),Ni=function(t){function i(i){return t.call(this,i)||this}return e(i,t),i.prototype.Xu=function(t,i){this.Ku.U=!1;var n=this.qe.$(),s=n.os().os;if(2===s||3===s){var h=this.qe.ct();if(h.baseLineVisible&&this.qe.U()){var r=this.qe.H();null!==r&&(this.Ku.U=!0,this.Ku.g=n.K(r.X,r.X),this.Ku.wt=i,this.Ku.Mt=t,this.Ku.et=h.baseLineColor,this.Ku.rt=h.baseLineWidth,this.Ku.ut=h.baseLineStyle);}}},i}(Ci),xi=function(){function t(){this.tt=null;}return t.prototype._=function(t){this.tt=t;},t.prototype.Zu=function(){return this.tt},t.prototype.h=function(t,i,n,s){var h=this.tt;if(null!==h){t.save();var r=Math.max(1,Math.floor(i)),e=r%2/2,u=Math.round(h.Lu.x*i)+e,a=h.Lu.y*i;t.fillStyle=h.Ju,t.beginPath();var o=Math.max(2,1.5*h.Gu)*i;t.arc(u,a,o,0,2*Math.PI,!1),t.fill(),t.fillStyle=h.Qu,t.beginPath(),t.arc(u,a,h.C*i,0,2*Math.PI,!1),t.fill(),t.lineWidth=r,t.strokeStyle=h.ta,t.beginPath(),t.arc(u,a,h.C*i+r/2,0,2*Math.PI,!1),t.stroke(),t.restore();}},t}(),Si=[{ia:0,na:.25,sa:4,ha:10,ra:.25,ea:0,ua:.4,aa:.8},{ia:.25,na:.525,sa:10,ha:14,ra:0,ea:0,ua:.8,aa:0},{ia:.525,na:1,sa:14,ha:14,ra:0,ea:0,ua:0,aa:0}];function Di(t,i,n,s){return function(t,i){if("transparent"===t)return t;var n=O(t),s=n[3];return "rgba("+n[0]+", "+n[1]+", "+n[2]+", "+i*s+")"}(t,n+(s-n)*i)}function Ai(t,i){for(var n,s=t%2600/2600,h=0,r=Si;h<r.length;h++){var e=r[h];if(s>=e.ia&&s<=e.na){n=e;break}}o(void 0!==n,"Last price animation internal logic error");var u,a,l,f=(s-n.ia)/(n.na-n.ia);return {Qu:Di(i,f,n.ra,n.ea),ta:Di(i,f,n.ua,n.aa),C:(u=f,a=n.sa,l=n.ha,a+(l-a)*u)}}var Ti=function(){function t(t){this.ot=new xi,this.L=!0,this.oa=!0,this.la=performance.now(),this.fa=this.la-1,this.ca=t;}return t.prototype.O=function(t){if(this.L=!0,"data"===t&&2===this.ca.ct().lastPriceAnimation){var i=performance.now(),n=this.fa-i;if(n>0)return void(n<650&&(this.fa+=2600));this.la=i,this.fa=i+2600;}},t.prototype.va=function(){this.oa=!0;},t.prototype.U=function(){return 0!==this.ca.ct().lastPriceAnimation},t.prototype._a=function(){switch(this.ca.ct().lastPriceAnimation){case 0:return !1;case 1:return !0;case 2:return performance.now()<=this.fa}},t.prototype.P=function(t,i){return this.L?(this.R(t,i),this.L=!1,this.oa=!1):this.oa&&(this.da(),this.oa=!1),this.ot},t.prototype.R=function(t,i){this.ot._(null);var n=this.ca.vt().j(),s=n.mr(),h=this.ca.H();if(null!==s&&null!==h){var r=this.ca.wa(!0);if(!r.Ma&&s.Eh(r.Ph)){var e={x:n.G(r.Ph),y:this.ca.$().K(r.D,h.X)},u=r.et,a=this.ca.ct().lineWidth,o=Ai(this.ba(),u);this.ot._({Ju:u,Gu:a,Qu:o.Qu,ta:o.ta,C:o.C,Lu:e});}}},t.prototype.da=function(){var t=this.ot.Zu();if(null!==t){var i=Ai(this.ba(),t.Ju);t.Qu=i.Qu,t.ta=i.ta,t.C=i.C;}},t.prototype.ba=function(){return this._a()?performance.now()-this.la:2599},t}();function Bi(t,i){return ut(Math.min(Math.max(t,12),30)*i)}function Li(t,i){switch(t){case"arrowDown":case"arrowUp":return Bi(i,1);case"circle":return Bi(i,.8);case"square":return Bi(i,.7)}}function Fi(t){return et(Bi(t,1))}function Ei(t){return Math.max(Bi(t,.1),3)}function Vi(t,i,n,s,h){var r=Li("square",n),e=(r-1)/2,u=t-e,a=i-e;return s>=u&&s<=u+r&&h>=a&&h<=a+r}function Oi(t,i,n,s,h){var r=(Li("arrowUp",h)-1)/2,e=(ut(h/2)-1)/2;i.beginPath(),t?(i.moveTo(n-r,s),i.lineTo(n,s-r),i.lineTo(n+r,s),i.lineTo(n+e,s),i.lineTo(n+e,s+r),i.lineTo(n-e,s+r),i.lineTo(n-e,s)):(i.moveTo(n-r,s),i.lineTo(n,s+r),i.lineTo(n+r,s),i.lineTo(n+e,s),i.lineTo(n+e,s-r),i.lineTo(n-e,s-r),i.lineTo(n-e,s)),i.fill();}function Wi(t,i,n,s,h,r){return Vi(i,n,s,h,r)}var zi=function(t){function i(){var i=null!==t&&t.apply(this,arguments)||this;return i.tt=null,i.Pu=new pi,i.fe=-1,i.ce="",i.ma="",i}return e(i,t),i.prototype._=function(t){this.tt=t;},i.prototype.Ru=function(t,i){this.fe===t&&this.ce===i||(this.fe=t,this.ce=i,this.ma=Ut(t,i),this.Pu.Ou());},i.prototype.pa=function(t,i){if(null===this.tt||null===this.tt.M)return null;for(var n=this.tt.M.from;n<this.tt.M.to;n++){var s=this.tt.m[n];if(Ri(s,t,i))return {ga:s.ya,ka:s.ka}}return null},i.prototype.u=function(t,i,n){if(null!==this.tt&&null!==this.tt.M){t.textBaseline="middle",t.font=this.ma;for(var s=this.tt.M.from;s<this.tt.M.to;s++){var h=this.tt.m[s];void 0!==h.Et&&(h.Et.wt=this.Pu.Vt(t,h.Et.Ca),h.Et.Mt=this.fe),Pi(h,t);}}},i}(y);function Pi(t,i){i.fillStyle=t.et,void 0!==t.Et&&function(t,i,n,s){t.fillText(i,n,s);}(i,t.Et.Ca,t.p-t.Et.wt/2,t.Et.g),function(t,i){if(0===t.Je)return;switch(t.Na){case"arrowDown":return void Oi(!1,i,t.p,t.g,t.Je);case"arrowUp":return void Oi(!0,i,t.p,t.g,t.Je);case"circle":return void function(t,i,n,s){var h=(Li("circle",s)-1)/2;t.beginPath(),t.arc(i,n,h,0,2*Math.PI,!1),t.fill();}(i,t.p,t.g,t.Je);case"square":return void function(t,i,n,s){var h=Li("square",s),r=(h-1)/2,e=i-r,u=n-r;t.fillRect(e,u,h,h);}(i,t.p,t.g,t.Je)}t.Na;}(t,i);}function Ri(t,i,n){return !(void 0===t.Et||!function(t,i,n,s,h,r){var e=s/2;return h>=t&&h<=t+n&&r>=i-e&&r<=i+e}(t.p,t.Et.g,t.Et.wt,t.Et.Mt,i,n))||function(t,i,n){if(0===t.Je)return !1;switch(t.Na){case"arrowDown":case"arrowUp":return Wi(0,t.p,t.g,t.Je,i,n);case"circle":return function(t,i,n,s,h){var r=2+Li("circle",n)/2,e=t-s,u=i-h;return Math.sqrt(e*e+u*u)<=r}(t.p,t.g,t.Je,i,n);case"square":return Vi(t.p,t.g,t.Je,i,n)}}(t,i,n)}function Ii(t,i,n,s,h,r,e,u,a){var o=_(n)?n:n.close,l=_(n)?n:n.high,f=_(n)?n:n.low,c=_(i.size)?Math.max(i.size,0):1,v=Fi(u.Wr())*c,d=v/2;switch(t.Je=v,i.position){case"inBar":return t.g=e.K(o,a),void(void 0!==t.Et&&(t.Et.g=t.g+d+r+.6*h));case"aboveBar":return t.g=e.K(l,a)-d-s.xa,void 0!==t.Et&&(t.Et.g=t.g-d-.6*h,s.xa+=1.2*h),void(s.xa+=v+r);case"belowBar":return t.g=e.K(f,a)+d+s.Sa,void 0!==t.Et&&(t.Et.g=t.g+d+r+.6*h,s.Sa+=1.2*h),void(s.Sa+=v+r)}i.position;}var ji=function(){function t(t,i){this.L=!0,this.Da=!0,this.Aa=!0,this.Ta=null,this.ot=new zi,this.ca=t,this.hi=i,this.tt={m:[],M:null};}return t.prototype.O=function(t){this.L=!0,this.Aa=!0,"data"===t&&(this.Da=!0);},t.prototype.P=function(t,i,n){if(!this.ca.U())return null;this.L&&this.Ye();var s=this.hi.ct().layout;return this.ot.Ru(s.fontSize,s.fontFamily),this.ot._(this.tt),this.ot},t.prototype.Ba=function(){if(this.Aa){if(this.ca.La().length>0){var t=this.hi.j().Wr(),i=Ei(t),n=1.5*Fi(t)+2*i;this.Ta={above:n,below:n};}else this.Ta=null;this.Aa=!1;}return this.Ta},t.prototype.Ye=function(){var t=this.ca.$(),i=this.hi.j(),n=this.ca.La();this.Da&&(this.tt.m=n.map((function(t){return {S:t.time,p:0,g:0,Je:0,Na:t.shape,et:t.color,ya:t.ya,ka:t.id,Et:void 0}})),this.Da=!1);var s=this.hi.ct().layout;this.tt.M=null;var h=i.mr();if(null!==h){var r=this.ca.H();if(null!==r&&0!==this.tt.m.length){var e=NaN,u=Ei(i.Wr()),a={xa:u,Sa:u};this.tt.M=ni(this.tt.m,h,!0);for(var o=this.tt.M.from;o<this.tt.M.to;o++){var l=n[o];l.time!==e&&(a.xa=u,a.Sa=u,e=l.time);var f=this.tt.m[o];f.p=i.G(l.time),void 0!==l.text&&l.text.length>0&&(f.Et={Ca:l.text,g:0,wt:0,Mt:0});var c=this.ca.Fa(l.time);null!==c&&Ii(f,l,c,a,s.fontSize,u,t,i,r.X);}this.L=!1;}}},t}(),qi=function(t){function i(i){return t.call(this,i)||this}return e(i,t),i.prototype.Xu=function(t,i){var n=this.Ku;n.U=!1;var s=this.qe.ct();if(s.priceLineVisible&&this.qe.U()){var h=this.qe.wa(0===s.priceLineSource);h.Ma||(n.U=!0,n.g=h.zt,n.et=this.qe.Ea(h.et),n.wt=i,n.Mt=t,n.rt=s.priceLineWidth,n.ut=s.priceLineStyle);}},i}(Ci),Ui=function(t){function i(i){var n=t.call(this)||this;return n.lt=i,n}return e(i,t),i.prototype.Jt=function(t,i,n){t.U=!1,i.U=!1;var s=this.lt;if(s.U()){var h=s.ct(),r=h.lastValueVisible,e=""!==s.Va(),u=0===h.seriesLastValueMode,a=s.wa(!1);if(!a.Ma){r&&(t.Et=this.Oa(a,r,u),t.U=0!==t.Et.length),(e||u)&&(i.Et=this.Wa(a,r,e,u),i.U=i.Et.length>0);var o=s.Ea(a.et),l=W(o);n.yt=l.yt,n.et=l.kt,n.zt=a.zt,i.Z=s.vt().J(a.zt/s.$().Mt()),t.Z=o;}}},i.prototype.Wa=function(t,i,n,s){var h="",r=this.lt.Va();return n&&0!==r.length&&(h+=r+" "),i&&s&&(h+=this.lt.$().cs()?t.za:t.Pa),h.trim()},i.prototype.Oa=function(t,i,n){return i?n?this.lt.$().cs()?t.Pa:t.za:t.Et:""},i}(U),Hi=function(){function t(t,i){this.On=t,this.Ra=i||null;}return t.prototype.Cs=function(){return this.On},t.prototype.eh=function(){return this.Ra},t.prototype.Mn=function(){return null===this.On?null:{priceRange:this.On.Mn(),margins:this.Ra||void 0}},t.bn=function(i){return null===i?null:new t(nt.bn(i.priceRange),i.margins)},t}(),Yi=function(t){function i(i,n){var s=t.call(this,i)||this;return s.Ia=n,s}return e(i,t),i.prototype.Xu=function(t,i){var n=this.Ku;if(n.U=!1,this.qe.U()){var s=this.Ia.ja();if(null!==s){var h=this.Ia.ct();n.U=!0,n.g=s,n.et=h.color,n.wt=i,n.Mt=t,n.rt=h.lineWidth,n.ut=h.lineStyle;}}},i}(Ci),Ki=function(t){function i(i,n){var s=t.call(this)||this;return s.ca=i,s.Ia=n,s}return e(i,t),i.prototype.Jt=function(t,i,n){t.U=!1,i.U=!1;var s=this.Ia.ct(),h=s.axisLabelVisible,r=""!==s.title,e=this.ca;if(h&&e.U()){var u=this.Ia.ja();if(null!==u){r&&(i.Et=s.title,i.U=!0),i.Z=e.vt().J(u/e.$().Mt()),t.Et=e.$().Zs(s.price),t.U=!0;var a=W(s.color);n.yt=a.yt,n.et=a.kt,n.zt=u;}}},i}(U),$i=function(){function t(t,i){this.ca=t,this.ki=i,this.qa=new Yi(t,this),this.Iu=new Ki(t,this),this.Ua=new yi(this.Iu,t,t.vt());}return t.prototype.rs=function(t){v(this.ki,t),this.O(),this.ca.vt().Or();},t.prototype.ct=function(){return this.ki},t.prototype.zi=function(){return [this.qa,this.Ua]},t.prototype.Ha=function(){return this.Iu},t.prototype.O=function(){this.qa.O(),this.Iu.O();},t.prototype.ja=function(){var t=this.ca,i=t.$();if(t.vt().j().ti()||i.ti())return null;var n=t.H();return null===n?null:i.K(this.ki.price,n.X)},t}(),Xi=function(t){function i(i){var n=t.call(this)||this;return n.hi=i,n}return e(i,t),i.prototype.vt=function(){return this.hi},i}(X),Zi={fu:"",Su:"",xu:""},Ji=function(){function t(t){this.ca=t;}return t.prototype.cu=function(t,i){var n=this.ca.Ya(),s=this.ca.ct();switch(n){case"Line":return this.Ka(s);case"Area":return this.$a(s);case"Baseline":return this.Xa(s,t,i);case"Bar":return this.Za(s,t,i);case"Candlestick":return this.Ja(s,t,i);case"Histogram":return this.Ga(s,t,i)}throw new Error("Unknown chart style")},t.prototype.Za=function(t,i,n){var s=u({},Zi),h=t.upColor,r=t.downColor,e=h,a=r,o=f(this.Qa(i,n)),l=c(o.X[0])<=c(o.X[3]);return s.fu=l?h:r,s.Su=l?e:a,s},t.prototype.Ja=function(t,i,n){var s=u({},Zi),h=t.upColor,r=t.downColor,e=t.borderUpColor,a=t.borderDownColor,o=t.wickUpColor,l=t.wickDownColor,v=f(this.Qa(i,n)),_=c(v.X[0])<=c(v.X[3]);return s.fu=_?h:r,s.Su=_?e:a,s.xu=_?o:l,s},t.prototype.$a=function(t){return u(u({},Zi),{fu:t.lineColor})},t.prototype.Xa=function(t,i,n){var s=f(this.Qa(i,n)).X[3]>=t.baseValue.price;return u(u({},Zi),{fu:s?t.topLineColor:t.bottomLineColor})},t.prototype.Ka=function(t){return u(u({},Zi),{fu:t.color})},t.prototype.Ga=function(t,i,n){var s=u({},Zi),h=f(this.Qa(i,n));return s.fu=void 0!==h.et?h.et:t.color,s},t.prototype.Qa=function(t,i){return void 0!==i?i.X:this.ca.Hi().io(t)},t}(),Gi=function(){function t(){this.no=[],this.so=new Map,this.ho=new Map;}return t.prototype.ro=function(){return this.Je()>0?this.no[this.no.length-1]:null},t.prototype.eo=function(){return this.Je()>0?this.uo(0):null},t.prototype.Ui=function(){return this.Je()>0?this.uo(this.no.length-1):null},t.prototype.Je=function(){return this.no.length},t.prototype.ti=function(){return 0===this.Je()},t.prototype.Eh=function(t){return null!==this.ao(t,0)},t.prototype.io=function(t){return this.oo(t)},t.prototype.oo=function(t,i){void 0===i&&(i=0);var n=this.ao(t,i);return null===n?null:u(u({},this.lo(n)),{Ph:this.uo(n)})},t.prototype.iu=function(){return this.no},t.prototype.fo=function(t,i,n){if(this.ti())return null;for(var s=null,h=0,r=n;h<r.length;h++){var e=r[h];s=Qi(s,this.co(t,i,e));}return s},t.prototype._=function(t){this.ho.clear(),this.so.clear(),this.no=t;},t.prototype.uo=function(t){return this.no[t].Ph},t.prototype.lo=function(t){return this.no[t]},t.prototype.ao=function(t,i){var n=this.vo(t);if(null===n&&0!==i)switch(i){case-1:return this._o(t);case 1:return this.do(t);default:throw new TypeError("Unknown search mode")}return n},t.prototype._o=function(t){var i=this.wo(t);return i>0&&(i-=1),i!==this.no.length&&this.uo(i)<t?i:null},t.prototype.do=function(t){var i=this.Mo(t);return i!==this.no.length&&t<this.uo(i)?i:null},t.prototype.vo=function(t){var i=this.wo(t);return i===this.no.length||t<this.no[i].Ph?null:i},t.prototype.wo=function(t){return Bt(this.no,t,(function(t,i){return t.Ph<i}))},t.prototype.Mo=function(t){return Lt(this.no,t,(function(t,i){return i.Ph>t}))},t.prototype.bo=function(t,i,n){for(var s=null,h=t;h<i;h++){var r=this.no[h].X[n];Number.isNaN(r)||(null===s?s={mo:r,po:r}:(r<s.mo&&(s.mo=r),r>s.po&&(s.po=r)));}return s},t.prototype.co=function(t,i,n){if(this.ti())return null;var s=null,h=f(this.eo()),r=f(this.Ui()),e=Math.max(t,h),u=Math.min(i,r),a=30*Math.ceil(e/30),o=Math.max(a,30*Math.floor(u/30)),l=this.wo(e),c=this.Mo(Math.min(u,a,i));s=Qi(s,this.bo(l,c,n));var v=this.so.get(n);void 0===v&&(v=new Map,this.so.set(n,v));for(var _=Math.max(a+1,e);_<o;_+=30){var d=Math.floor(_/30),w=v.get(d);if(void 0===w){var M=this.wo(30*d),b=this.Mo(30*(d+1)-1);w=this.bo(M,b,n),v.set(d,w);}s=Qi(s,w);}l=this.wo(o),c=this.Mo(u);return s=Qi(s,this.bo(l,c,n))},t}();function Qi(t,i){return null===t?i:null===i?t:{mo:Math.min(t.mo,i.mo),po:Math.max(t.po,i.po)}}var tn=function(t){function i(i,n,s){var h=t.call(this,i)||this;h.tt=new Gi,h.qa=new qi(h),h.yo=[],h.ko=new Ni(h),h.Co=null,h.No=null,h.xo=[],h.So=[],h.Do=null,h.ki=n,h.Ao=s;var r=new Ui(h);return h.Mi=[r],h.Ua=new yi(r,h,i),"Area"!==s&&"Line"!==s&&"Baseline"!==s||(h.Co=new Ti(h)),h.To(),h.Bo(),h}return e(i,t),i.prototype.en=function(){null!==this.Do&&clearTimeout(this.Do);},i.prototype.Ea=function(t){return this.ki.priceLineColor||t},i.prototype.wa=function(t){var i={Ma:!0},n=this.$();if(this.vt().j().ti()||n.ti()||this.tt.ti())return i;var s,h,r=this.vt().j().mr(),e=this.H();if(null===r||null===e)return i;if(t){var u=this.tt.ro();if(null===u)return i;s=u,h=u.Ph;}else {var a=this.tt.oo(r.rh(),-1);if(null===a)return i;if(null===(s=this.tt.io(a.Ph)))return i;h=a.Ph;}var o=s.X[3],l=this.tu().cu(h,{X:s}),f=n.K(o,e.X);return {Ma:!1,D:o,Et:n.ii(o,e.X),za:n.Zs(o),Pa:n.Gs(o,e.X),et:l.fu,zt:f,Ph:h}},i.prototype.tu=function(){return null!==this.No||(this.No=new Ji(this)),this.No},i.prototype.ct=function(){return this.ki},i.prototype.rs=function(t){var i=t.priceScaleId;void 0!==i&&i!==this.ki.priceScaleId&&this.vt().Lo(this,i),v(this.ki,t),null!==this.ui&&void 0!==t.scaleMargins&&this.ui.rs({scaleMargins:t.scaleMargins}),void 0!==t.priceFormat&&this.To(),this.vt().Fo(this),this.vt().Eo(),this.Ai.O("options");},i.prototype._=function(t){var i;this.tt._(t),this.Vo(),this.Ai.O("data"),this.Ci.O("data"),null===(i=this.Co)||void 0===i||i.O("data");var n=this.vt().qu(this);this.vt().Oo(n),this.vt().Fo(this),this.vt().Eo(),this.vt().Or();},i.prototype.Wo=function(t){this.xo=t.map((function(t){return u({},t)})),this.Vo();var i=this.vt().qu(this);this.Ci.O("data"),this.vt().Oo(i),this.vt().Fo(this),this.vt().Eo(),this.vt().Or();},i.prototype.La=function(){return this.So},i.prototype.zo=function(t){var i=new $i(this,t);return this.yo.push(i),this.vt().Fo(this),i},i.prototype.Po=function(t){var i=this.yo.indexOf(t);-1!==i&&this.yo.splice(i,1),this.vt().Fo(this);},i.prototype.Ya=function(){return this.Ao},i.prototype.H=function(){var t=this.Ro();return null===t?null:{X:t.X[3],Rs:t.S}},i.prototype.Ro=function(){var t=this.vt().j().mr();if(null===t)return null;var i=t.hh();return this.tt.oo(i,1)},i.prototype.Hi=function(){return this.tt},i.prototype.Fa=function(t){var i=this.tt.io(t);return null===i?null:"Bar"===this.Ao||"Candlestick"===this.Ao?{open:i.X[0],high:i.X[1],low:i.X[2],close:i.X[3]}:i.X[3]},i.prototype.Io=function(t){var i=this,n=this.Co;return null!==n&&n.U()?(null===this.Do&&n._a()&&(this.Do=setTimeout((function(){i.Do=null,i.vt().jo();}),0)),n.va(),[n]):[]},i.prototype.zi=function(){var t=[];this.qo()||t.push(this.ko);for(var i=0,n=this.yo;i<n.length;i++){var s=n[i];t.push.apply(t,s.zi());}return t.push(this.Ai,this.qa,this.Ua,this.Ci),t},i.prototype.Pi=function(t,i){if(i!==this.ui&&!this.qo())return [];for(var n=a([],this.Mi,!0),s=0,h=this.yo;s<h.length;s++){var r=h[s];n.push(r.Ha());}return n},i.prototype.sh=function(t,i){var n=this;if(void 0!==this.ki.autoscaleInfoProvider){var s=this.ki.autoscaleInfoProvider((function(){var s=n.Uo(t,i);return null===s?null:s.Mn()}));return Hi.bn(s)}return this.Uo(t,i)},i.prototype.ih=function(){return this.ki.priceFormat.minMove},i.prototype.$s=function(){return this.Zn},i.prototype.Ii=function(){var t;this.Ai.O(),this.Ci.O();for(var i=0,n=this.Mi;i<n.length;i++){n[i].O();}for(var s=0,h=this.yo;s<h.length;s++){h[s].O();}this.qa.O(),this.ko.O(),null===(t=this.Co)||void 0===t||t.O();},i.prototype.$=function(){return f(t.prototype.$.call(this))},i.prototype.q=function(t){if(!(("Line"===this.Ao||"Area"===this.Ao||"Baseline"===this.Ao)&&this.ki.crosshairMarkerVisible))return null;var i=this.tt.io(t);return null===i?null:{D:i.X[3],C:this.Ho(),Z:this.Yo(),Y:this.Ko(t)}},i.prototype.Va=function(){return this.ki.title},i.prototype.U=function(){return this.ki.visible},i.prototype.qo=function(){return !Yt(this.$().hs())},i.prototype.Uo=function(t,i){if(!d(t)||!d(i)||this.tt.ti())return null;var n="Line"===this.Ao||"Area"===this.Ao||"Baseline"===this.Ao||"Histogram"===this.Ao?[3]:[2,1],s=this.tt.fo(t,i,n),h=null!==s?new nt(s.mo,s.po):null;if("Histogram"===this.Ya()){var r=this.ki.base,e=new nt(r,r);h=null!==h?h._n(e):e;}return new Hi(h,this.Ci.Ba())},i.prototype.Ho=function(){switch(this.Ao){case"Line":case"Area":case"Baseline":return this.ki.crosshairMarkerRadius}return 0},i.prototype.Yo=function(){switch(this.Ao){case"Line":case"Area":case"Baseline":var t=this.ki.crosshairMarkerBorderColor;if(0!==t.length)return t}return null},i.prototype.Ko=function(t){switch(this.Ao){case"Line":case"Area":case"Baseline":var i=this.ki.crosshairMarkerBackgroundColor;if(0!==i.length)return i}return this.tu().cu(t).fu},i.prototype.To=function(){switch(this.ki.priceFormat.type){case"custom":this.Zn={format:this.ki.priceFormat.formatter};break;case"volume":this.Zn=new $t(this.ki.priceFormat.precision);break;case"percent":this.Zn=new tt(this.ki.priceFormat.precision);break;default:var t=Math.pow(10,this.ki.priceFormat.precision);this.Zn=new Q(t,this.ki.priceFormat.minMove*t);}null!==this.ui&&this.ui.es();},i.prototype.Vo=function(){var t=this,i=this.vt().j();if(i.ti()||0===this.tt.Je())this.So=[];else {var n=f(this.tt.eo());this.So=this.xo.map((function(s,h){var r=f(i.br(s.time,!0)),e=r<n?1:-1;return {time:f(t.tt.oo(r,e)).Ph,position:s.position,shape:s.shape,color:s.color,id:s.id,ya:h,text:s.text,size:s.size}}));}},i.prototype.Bo=function(){switch(this.Ci=new ji(this,this.vt()),this.Ao){case"Bar":this.Ai=new ai(this,this.vt());break;case"Candlestick":this.Ai=new vi(this,this.vt());break;case"Line":this.Ai=new bi(this,this.vt());break;case"Area":this.Ai=new ri(this,this.vt());break;case"Baseline":this.Ai=new fi(this,this.vt());break;case"Histogram":this.Ai=new Mi(this,this.vt());break;default:throw Error("Unknown chart style assigned: "+this.Ao)}},i}(Xi),nn=function(){function t(t){this.ki=t;}return t.prototype.$o=function(t,i,n){var s=t;if(0===this.ki.mode)return s;var h=n.xi(),r=h.H();if(null===r)return s;var e=h.K(t,r),u=n.Vs().filter((function(t){return t instanceof tn})).reduce((function(t,s){if(n.Uu(s)||!s.U())return t;var h=s.$(),r=s.Hi();if(h.ti()||!r.Eh(i))return t;var e=r.io(i);if(null===e)return t;var u=c(s.H());return t.concat([h.K(e.X[3],u.X)])}),[]);if(0===u.length)return s;u.sort((function(t,i){return Math.abs(t-e)-Math.abs(i-e)}));var a=u[0];return s=h.Si(a,r)},t}(),sn=function(){function t(){this.tt=null;}return t.prototype._=function(t){this.tt=t;},t.prototype.h=function(t,i,n,h){var r=this;if(null!==this.tt){var e=Math.max(1,Math.floor(i));t.lineWidth=e;var u=Math.ceil(this.tt.ht*i),a=Math.ceil(this.tt.st*i);!function(t,i){t.save(),t.lineWidth%2&&t.translate(.5,.5),i(),t.restore();}(t,(function(){var n=f(r.tt);if(n.Xo){t.strokeStyle=n.Zo,s(t,n.Jo),t.beginPath();for(var h=0,o=n.Go;h<o.length;h++){var l=o[h],c=Math.round(l.An*i);t.moveTo(c,-e),t.lineTo(c,u+e);}t.stroke();}if(n.Qo){t.strokeStyle=n.tl,s(t,n.il),t.beginPath();for(var v=0,_=n.nl;v<_.length;v++){var d=_[v],w=Math.round(d.An*i);t.moveTo(-e,w),t.lineTo(a+e,w);}t.stroke();}}));}},t}(),hn=function(){function t(t){this.ot=new sn,this.L=!0,this.vi=t;}return t.prototype.O=function(){this.L=!0;},t.prototype.P=function(t,i){if(this.L){var n=this.vi.vt().ct().grid,s={ht:t,st:i,Qo:n.horzLines.visible,Xo:n.vertLines.visible,tl:n.horzLines.color,Zo:n.vertLines.color,il:n.horzLines.style,Jo:n.vertLines.style,nl:this.vi.xi().Fn(),Go:this.vi.vt().j().Fn()||[]};this.ot._(s),this.L=!1;}return this.ot},t}(),rn=function(){function t(t){this.Ai=new hn(t);}return t.prototype.sl=function(){return this.Ai},t}(),en=function(){function t(t,i){this.Hn=[],this.hl=new Map,this.En=0,this.$h=0,this.rl=1e3,this.Yn=null,this.el=new it,this.ul=t,this.hi=i,this.al=new rn(this);var n=i.ct();this.ol=this.ll("left",n.leftPriceScale),this.fl=this.ll("right",n.rightPriceScale),this.ol.bs().Ji(this.cl.bind(this,this.ol),this),this.fl.bs().Ji(this.cl.bind(this,this.ol),this),this.vl(n);}return t.prototype.vl=function(t){if(t.leftPriceScale&&this.ol.rs(t.leftPriceScale),t.rightPriceScale&&this.fl.rs(t.rightPriceScale),t.localization&&(this.ol.es(),this.fl.es()),t.overlayPriceScales)for(var i=0,n=Array.from(this.hl.values());i<n.length;i++){var s=f(n[i][0].$());s.rs(t.overlayPriceScales),t.localization&&s.es();}},t.prototype._l=function(t){switch(t){case"left":return this.ol;case"right":return this.fl}return this.hl.has(t)?l(this.hl.get(t))[0].$():null},t.prototype.en=function(){this.vt().dl().sn(this),this.ol.bs().sn(this),this.fl.bs().sn(this),this.Hn.forEach((function(t){t.en&&t.en();})),this.el.hn();},t.prototype.wl=function(){return this.rl},t.prototype.Ml=function(t){this.rl=t;},t.prototype.vt=function(){return this.hi},t.prototype.wt=function(){return this.$h},t.prototype.Mt=function(){return this.En},t.prototype.Dr=function(t){this.$h=t,this.bl();},t.prototype.ps=function(t){var i=this;this.En=t,this.ol.ps(t),this.fl.ps(t),this.Hn.forEach((function(n){if(i.Uu(n)){var s=n.$();null!==s&&s.ps(t);}})),this.bl();},t.prototype.Vs=function(){return this.Hn},t.prototype.Uu=function(t){var i=t.$();return null===i||this.ol!==i&&this.fl!==i},t.prototype.Ws=function(t,i,n){var s=void 0!==n?n:this.pl().ml+1;this.gl(t,i,s);},t.prototype.Ps=function(t){var i=this.Hn.indexOf(t);o(-1!==i,"removeDataSource: invalid data source"),this.Hn.splice(i,1);var n=f(t.$()).hs();if(this.hl.has(n)){var s=l(this.hl.get(n)),h=s.indexOf(t);-1!==h&&(s.splice(h,1),0===s.length&&this.hl.delete(n));}var r=t.$();r&&r.Vs().indexOf(t)>=0&&r.Ps(t),null!==r&&(r.zs(),this.yl(r)),this.Yn=null;},t.prototype.Hu=function(t){return t===this.ol?"left":t===this.fl?"right":"overlay"},t.prototype.kl=function(){return this.ol},t.prototype.Cl=function(){return this.fl},t.prototype.Nl=function(t,i){t.js(i);},t.prototype.xl=function(t,i){t.qs(i),this.bl();},t.prototype.Sl=function(t){t.Us();},t.prototype.Dl=function(t,i){t.Hs(i);},t.prototype.Al=function(t,i){t.Ys(i),this.bl();},t.prototype.Tl=function(t){t.Ks();},t.prototype.bl=function(){this.Hn.forEach((function(t){t.Ii();}));},t.prototype.xi=function(){var t=null;return this.hi.ct().rightPriceScale.visible&&0!==this.fl.Vs().length?t=this.fl:this.hi.ct().leftPriceScale.visible&&0!==this.ol.Vs().length?t=this.ol:0!==this.Hn.length&&(t=this.Hn[0].$()),null===t&&(t=this.fl),t},t.prototype.yl=function(t){null!==t&&t.fs()&&this.Bl(t);},t.prototype.Ll=function(t){var i=this.ul.mr();t.us({_s:!0}),null!==i&&t.th(i),this.bl();},t.prototype.Fl=function(){this.Bl(this.ol),this.Bl(this.fl);},t.prototype.El=function(){var t=this;this.yl(this.ol),this.yl(this.fl),this.Hn.forEach((function(i){t.Uu(i)&&t.yl(i.$());})),this.bl(),this.hi.Or();},t.prototype.Os=function(){return null===this.Yn&&(this.Yn=bt(this.Hn)),this.Yn},t.prototype.Vl=function(){return this.el},t.prototype.Ol=function(){return this.al},t.prototype.Bl=function(t){var i=t.Qs();if(i&&i.length>0&&!this.ul.ti()){var n=this.ul.mr();null!==n&&t.th(n);}t.Ii();},t.prototype.pl=function(){var t=this.Os();if(0===t.length)return {Wl:0,ml:0};for(var i=0,n=0,s=0;s<t.length;s++){var h=t[s].oi();null!==h&&(h<i&&(i=h),h>n&&(n=h));}return {Wl:i,ml:n}},t.prototype.gl=function(t,i,n){var s=this._l(i);if(null===s&&(s=this.ll(i,this.hi.ct().overlayPriceScales)),this.Hn.push(t),!Yt(i)){var h=this.hl.get(i)||[];h.push(t),this.hl.set(i,h);}s.Ws(t),t.fi(s),t.li(n),this.yl(s),this.Yn=null;},t.prototype.cl=function(t,i,n){i.os!==n.os&&this.Bl(t);},t.prototype.ll=function(t,i){var n=u({visible:!0,autoScale:!0},b(i)),s=new kt(t,n,this.hi.ct().layout,this.hi.ct().localization);return s.ps(this.Mt()),s},t}(),un=function(t){function i(i){var n=t.call(this)||this;return n.zl=new Map,n.tt=i,n}return e(i,t),i.prototype.u=function(t){},i.prototype.l=function(t){if(this.tt.U){t.save();for(var i=0,n=0,s=this.tt.Pl;n<s.length;n++){if(0!==(a=s[n]).Et.length){t.font=a.Nt;var h=this.Rl(t,a.Et);h>this.tt.wt?a.Ur=this.tt.wt/h:a.Ur=1,i+=a.Il*a.Ur;}}var r=0;switch(this.tt.jl){case"top":r=0;break;case"center":r=Math.max((this.tt.Mt-i)/2,0);break;case"bottom":r=Math.max(this.tt.Mt-i,0);}t.fillStyle=this.tt.et;for(var e=0,u=this.tt.Pl;e<u.length;e++){var a=u[e];t.save();var o=0;switch(this.tt.ql){case"left":t.textAlign="left",o=a.Il/2;break;case"center":t.textAlign="center",o=this.tt.wt/2;break;case"right":t.textAlign="right",o=this.tt.wt-1-a.Il/2;}t.translate(o,r),t.textBaseline="top",t.font=a.Nt,t.scale(a.Ur,a.Ur),t.fillText(a.Et,0,a.Ul),t.restore(),r+=a.Il*a.Ur;}t.restore();}},i.prototype.Rl=function(t,i){var n=this.Hl(t.font),s=n.get(i);return void 0===s&&(s=t.measureText(i).width,n.set(i,s)),s},i.prototype.Hl=function(t){var i=this.zl.get(t);return void 0===i&&(i=new Map,this.zl.set(t,i)),i},i}(y),an=function(){function t(t){this.L=!0,this.at={U:!1,et:"",Mt:0,wt:0,Pl:[],jl:"center",ql:"center"},this.ot=new un(this.at),this.lt=t;}return t.prototype.O=function(){this.L=!0;},t.prototype.P=function(t,i){return this.L&&(this.R(t,i),this.L=!1),this.ot},t.prototype.R=function(t,i){var n=this.lt.ct(),s=this.at;s.U=n.visible,s.U&&(s.et=n.color,s.wt=i,s.Mt=t,s.ql=n.horzAlign,s.jl=n.vertAlign,s.Pl=[{Et:n.text,Nt:Ut(n.fontSize,n.fontFamily,n.fontStyle),Il:1.2*n.fontSize,Ul:0,Ur:0}]);},t}(),on=function(t){function i(i,n){var s=t.call(this)||this;return s.ki=n,s.Ai=new an(s),s}return e(i,t),i.prototype.Pi=function(){return []},i.prototype.zi=function(){return [this.Ai]},i.prototype.ct=function(){return this.ki},i.prototype.Ii=function(){this.Ai.O();},i}(X),ln=function(){function t(t,i){this.Yl=[],this.Kl=[],this.$h=0,this.$l=null,this.Xl=null,this.Zl=new it,this.Jl=new it,this.Gl=null,this.Ql=t,this.ki=i,this.tf=new Ht(this),this.ul=new Rt(this,i.timeScale,this.ki.localization),this.V=new Z(this,i.crosshair),this.if=new nn(i.crosshair),this.nf=new on(this,i.watermark),this.sf(),this.Yl[0].Ml(2e3),this.hf=this.rf(0),this.ef=this.rf(1);}return t.prototype.uf=function(){this.af(new Kt(3));},t.prototype.Or=function(){this.af(new Kt(2));},t.prototype.jo=function(){this.af(new Kt(1));},t.prototype.Fo=function(t){var i=this.lf(t);this.af(i);},t.prototype.ff=function(){return this.Xl},t.prototype.cf=function(t){var i=this.Xl;this.Xl=t,null!==i&&this.Fo(i.vf),null!==t&&this.Fo(t.vf);},t.prototype.ct=function(){return this.ki},t.prototype.rs=function(t){v(this.ki,t),this.Yl.forEach((function(i){return i.vl(t)})),void 0!==t.timeScale&&this.ul.rs(t.timeScale),void 0!==t.localization&&this.ul.cr(t.localization),(t.leftPriceScale||t.rightPriceScale)&&this.Zl.hn(),this.hf=this.rf(0),this.ef=this.rf(1),this.uf();},t.prototype._f=function(t,i){var n=this.df(t);null!==n&&(n.$.rs(i),this.Zl.hn());},t.prototype.df=function(t){for(var i=0,n=this.Yl;i<n.length;i++){var s=n[i],h=s._l(t);if(null!==h)return {ft:s,$:h}}return null},t.prototype.j=function(){return this.ul},t.prototype.wf=function(){return this.Yl},t.prototype.Mf=function(){return this.nf},t.prototype.bf=function(){return this.V},t.prototype.mf=function(){return this.Jl},t.prototype.pf=function(t,i){t.ps(i),this.Vr();},t.prototype.Dr=function(t){this.$h=t,this.ul.Dr(this.$h),this.Yl.forEach((function(i){return i.Dr(t)})),this.Vr();},t.prototype.sf=function(t){var i=new en(this.ul,this);void 0!==t?this.Yl.splice(t,0,i):this.Yl.push(i);var n=void 0===t?this.Yl.length-1:t,s=new Kt(3);return s.be(n,{me:0,_s:!0}),this.af(s),i},t.prototype.Nl=function(t,i,n){t.Nl(i,n);},t.prototype.xl=function(t,i,n){t.xl(i,n),this.Eo(),this.af(this.gf(t,2));},t.prototype.Sl=function(t,i){t.Sl(i),this.af(this.gf(t,2));},t.prototype.Dl=function(t,i,n){i.fs()||t.Dl(i,n);},t.prototype.Al=function(t,i,n){i.fs()||(t.Al(i,n),this.Eo(),this.af(this.gf(t,2)));},t.prototype.Tl=function(t,i){i.fs()||(t.Tl(i),this.af(this.gf(t,2)));},t.prototype.Ll=function(t,i){t.Ll(i),this.af(this.gf(t,2));},t.prototype.yf=function(t){this.ul.js(t);},t.prototype.kf=function(t,i){var n=this.j();if(!n.ti()&&0!==i){var s=n.wt();t=Math.max(1,Math.min(t,s)),n.Ur(t,i),this.Vr();}},t.prototype.Cf=function(t){this.Nf(0),this.xf(t),this.Sf();},t.prototype.Df=function(t){this.ul.qs(t),this.Vr();},t.prototype.Af=function(){this.ul.Us(),this.Or();},t.prototype.Nf=function(t){this.$l=t,this.ul.Hs(t);},t.prototype.xf=function(t){var i=!1;return null!==this.$l&&Math.abs(t-this.$l)>20&&(this.$l=null,i=!0),this.ul.Ys(t),this.Vr(),i},t.prototype.Sf=function(){this.ul.Ks(),this.Or(),this.$l=null;},t.prototype.W=function(){return this.Kl},t.prototype.Tf=function(t,i,n){this.V.Ti(t,i);var s=NaN,h=this.ul.Fr(t),r=this.ul.mr();null!==r&&(h=Math.min(Math.max(r.hh(),h),r.rh()));var e=n.xi(),u=e.H();null!==u&&(s=e.Si(i,u)),s=this.if.$o(s,h,n),this.V.Ei(h,s,n),this.jo(),this.Jl.hn(this.V.I(),{x:t,y:i});},t.prototype.Bf=function(){this.bf().Oi(),this.jo(),this.Jl.hn(null,null);},t.prototype.Eo=function(){var t=this.V.ft();if(null!==t){var i=this.V.Li(),n=this.V.Fi();this.Tf(i,n,t);}this.V.Ii();},t.prototype.Lf=function(t,i,n){var s=this.ul.ri(0);void 0!==i&&void 0!==n&&this.ul.O(i,n);var h=this.ul.ri(0),r=this.ul.Br(),e=this.ul.mr();if(null!==e&&null!==s&&null!==h){var u=e.Eh(r),a=s.Dh>h.Dh,o=null!==t&&t>r&&!a,l=u&&this.ul.ct().shiftVisibleRangeOnNewBar;if(o&&!l){var f=t-r;this.ul.Mr(this.ul.Pr()-f);}}this.ul.qr(t);},t.prototype.Oo=function(t){null!==t&&t.El();},t.prototype.qu=function(t){var i=this.Yl.find((function(i){return i.Os().includes(t)}));return void 0===i?null:i},t.prototype.Vr=function(){this.nf.Ii(),this.Yl.forEach((function(t){return t.El()})),this.Eo();},t.prototype.en=function(){this.Yl.forEach((function(t){return t.en()})),this.Yl.length=0,this.ki.localization.priceFormatter=void 0,this.ki.localization.timeFormatter=void 0;},t.prototype.Ff=function(){return this.tf},t.prototype.Yu=function(){return this.tf.ct()},t.prototype.dl=function(){return this.Zl},t.prototype.Ef=function(t,i){var n=this.Yl[0],s=this.Vf(i,t,n);return this.Kl.push(s),1===this.Kl.length?this.uf():this.Or(),s},t.prototype.Of=function(t){var i=this.qu(t),n=this.Kl.indexOf(t);o(-1!==n,"Series not found"),this.Kl.splice(n,1),f(i).Ps(t),t.en&&t.en();},t.prototype.Lo=function(t,i){var n=f(this.qu(t));n.Ps(t);var s=this.df(i);if(null===s){var h=t.oi();n.Ws(t,i,h);}else {h=s.ft===n?t.oi():void 0;s.ft.Ws(t,i,h);}},t.prototype.Qr=function(){var t=new Kt(2);t.ye(),this.af(t);},t.prototype.Wf=function(t){var i=new Kt(2);i.Ce(t),this.af(i);},t.prototype.Ne=function(){var t=new Kt(2);t.Ne(),this.af(t);},t.prototype.wr=function(t){var i=new Kt(2);i.wr(t),this.af(i);},t.prototype.Mr=function(t){var i=new Kt(2);i.Mr(t),this.af(i);},t.prototype.zf=function(){return this.ki.rightPriceScale.visible?"right":"left"},t.prototype.Pf=function(){return this.ef},t.prototype.Rf=function(){return this.hf},t.prototype.J=function(t){var i=this.ef,n=this.hf;if(i===n)return i;if(t=Math.max(0,Math.min(100,Math.round(100*t))),null===this.Gl||this.Gl.Ve!==n||this.Gl.Oe!==i)this.Gl={Ve:n,Oe:i,If:new Map};else {var s=this.Gl.If.get(t);if(void 0!==s)return s}var h=function(t,i,n){var s=O(t),h=s[0],r=s[1],e=s[2],u=s[3],a=O(i),o=a[0],l=a[1],f=a[2],c=a[3],v=[T(h+n*(o-h)),T(r+n*(l-r)),T(e+n*(f-e)),B(u+n*(c-u))];return "rgba("+v[0]+", "+v[1]+", "+v[2]+", "+v[3]+")"}(n,i,t/100);return this.Gl.If.set(t,h),h},t.prototype.gf=function(t,i){var n=new Kt(i);if(null!==t){var s=this.Yl.indexOf(t);n.be(s,{me:i});}return n},t.prototype.lf=function(t,i){return void 0===i&&(i=2),this.gf(this.qu(t),i)},t.prototype.af=function(t){this.Ql&&this.Ql(t),this.Yl.forEach((function(t){return t.Ol().sl().O()}));},t.prototype.Vf=function(t,i,n){var s=new tn(this,t,i),h=void 0!==t.priceScaleId?t.priceScaleId:this.zf();return n.Ws(s,h),Yt(h)||s.rs(t),s},t.prototype.rf=function(t){var i=this.ki.layout;return "gradient"===i.background.type?0===t?i.background.topColor:i.background.bottomColor:i.background.color},t}(),fn=function(){function t(t,i){this.st=t,this.ht=i;}return t.prototype.on=function(t){return this.st===t.st&&this.ht===t.ht},t}();function cn(t){return t.ownerDocument&&t.ownerDocument.defaultView&&t.ownerDocument.defaultView.devicePixelRatio||1}function vn(t){var i=f(t.getContext("2d"));return i.setTransform(1,0,0,1,0,0),i}function _n(t,i){var n=t.createElement("canvas"),s=cn(n);return n.style.width=i.st+"px",n.style.height=i.ht+"px",n.width=i.st*s,n.height=i.ht*s,n}function dn(i,n){var s=f(i.ownerDocument).createElement("canvas");i.appendChild(s);var h=bindToDevicePixelRatio(s);return h.resizeCanvas({width:n.st,height:n.ht}),h}function wn(t,i){return t.jf-i.jf}function Mn(t,i,n){var s=(t.jf-i.jf)/(t.S-i.S);return Math.sign(s)*Math.min(Math.abs(s),n)}var bn=function(){function t(t,i,n,s){this.qf=null,this.Uf=null,this.Hf=null,this.Yf=null,this.Kf=null,this.$f=0,this.Xf=0,this.Zf=!1,this.Jf=t,this.Gf=i,this.Qf=n,this.Yi=s;}return t.prototype.tc=function(t,i){if(null!==this.qf){if(this.qf.S===i)return void(this.qf.jf=t);if(Math.abs(this.qf.jf-t)<this.Yi)return}this.Yf=this.Hf,this.Hf=this.Uf,this.Uf=this.qf,this.qf={S:i,jf:t};},t.prototype.ia=function(t,i){if(null!==this.qf&&null!==this.Uf&&!(i-this.qf.S>50)){var n=0,s=Mn(this.qf,this.Uf,this.Gf),h=wn(this.qf,this.Uf),r=[s],e=[h];if(n+=h,null!==this.Hf){var u=Mn(this.Uf,this.Hf,this.Gf);if(Math.sign(u)===Math.sign(s)){var a=wn(this.Uf,this.Hf);if(r.push(u),e.push(a),n+=a,null!==this.Yf){var o=Mn(this.Hf,this.Yf,this.Gf);if(Math.sign(o)===Math.sign(s)){var l=wn(this.Hf,this.Yf);r.push(o),e.push(l),n+=l;}}}}for(var f,c,v,_=0,d=0;d<r.length;++d)_+=e[d]/n*r[d];if(!(Math.abs(_)<this.Jf))this.Kf={jf:t,S:i},this.Xf=_,this.$f=(f=Math.abs(_),c=this.Qf,v=Math.log(c),Math.log(1*v/-f)/v);}},t.prototype.ic=function(t){var i=f(this.Kf),n=t-i.S;return i.jf+this.Xf*(Math.pow(this.Qf,n)-1)/Math.log(this.Qf)},t.prototype.nc=function(t){return null===this.Kf||this.sc(t)===this.$f},t.prototype.hc=function(){return this.Zf},t.prototype.rc=function(){this.Zf=!0;},t.prototype.sc=function(t){var i=t-f(this.Kf).S;return Math.min(i,this.$f)},t}(),mn="undefined"!=typeof window;var pn=function(){if(!mn)return !1;var t=!!navigator.maxTouchPoints||!!navigator.msMaxTouchPoints||!!mn&&("ontouchstart"in window||Boolean(window.DocumentTouch&&document instanceof window.DocumentTouch));return "onorientationchange"in window&&t}();var gn=function(){if(!mn)return !1;var t=/Android/i.test(navigator.userAgent),i=/iPhone|iPad|iPod|AppleWebKit.+Mobile/i.test(navigator.userAgent);return t||i}(),yn=function(){function t(t,i,n){this.ec=0,this.uc=null,this.ac=null,this.oc=!1,this.lc=null,this.fc=!1,this.cc=!1,this.vc=null,this._c=null,this.dc=null,this.wc=null,this.Mc=0,this.bc=!1,this.mc=!1,this.gc=!1,this.yc=t,this.kc=i,this.ki=n,this.Cc();}return t.prototype.en=function(){null!==this.vc&&(this.vc(),this.vc=null),null!==this._c&&(this._c(),this._c=null),null!==this.dc&&(this.dc(),this.dc=null),this.Nc(),this.xc();},t.prototype.Sc=function(t){var i=this;this._c&&this._c();var n=this.Dc.bind(this);this._c=function(){i.yc.removeEventListener("mousemove",n);},this.yc.addEventListener("mousemove",n),Nn(t)&&this.Dc(t);var s=this.Ac(t);this.Tc(s,this.kc.Bc);},t.prototype.xc=function(){null!==this.uc&&clearTimeout(this.uc),this.ec=0,this.uc=null;},t.prototype.Dc=function(t){if(!this.gc||Nn(t)){var i=this.Ac(t);this.Tc(i,this.kc.Lc);}},t.prototype.Fc=function(t){if((!("button"in t)||0===t.button)&&null===this.wc){var i=Nn(t);if(!this.mc||!i){this.bc=!0;var n=this.Ac(t),s=c(this.lc),h=Math.abs(s.p-n.Ec),r=Math.abs(s.g-n.Vc),e=h+r>5;if(e||!i){if(e&&!this.fc&&i){var u=.5*h,a=r>=u&&!this.ki.Oc,o=u>r&&!this.ki.Wc;a||o||(this.mc=!0);}e&&(this.fc=!0,this.cc=!0,i&&this.Nc()),this.mc||(this.Tc(n,this.kc.zc),i&&xn(t));}}}},t.prototype.Pc=function(t){if(!("button"in t)||0===t.button){var i=this.Ac(t);this.Nc(),this.lc=null,this.gc=!1,this.dc&&(this.dc(),this.dc=null),Nn(t)&&this.Rc(t),this.Tc(i,this.kc.Ic),++this.ec,this.uc&&this.ec>1?(this.Tc(i,this.kc.jc),this.xc()):this.cc||this.Tc(i,this.kc.qc),Nn(t)&&(xn(t),this.Rc(t),0===t.touches.length&&(this.oc=!1));}},t.prototype.Nc=function(){null!==this.ac&&(clearTimeout(this.ac),this.ac=null);},t.prototype.Uc=function(t){if(!("button"in t)||0===t.button){var i=this.Ac(t);this.cc=!1,this.fc=!1,this.mc=!1,Nn(t)&&this.Sc(t),this.lc={p:i.Ec,g:i.Vc},this.dc&&(this.dc(),this.dc=null);var n=this.Fc.bind(this),s=this.Pc.bind(this),h=this.yc.ownerDocument.documentElement;this.dc=function(){h.removeEventListener("touchmove",n),h.removeEventListener("touchend",s),h.removeEventListener("mousemove",n),h.removeEventListener("mouseup",s);},h.addEventListener("touchmove",n,{passive:!1}),h.addEventListener("touchend",s,{passive:!1}),this.Nc(),Nn(t)&&1===t.touches.length?this.ac=setTimeout(this.Hc.bind(this,t),240):(h.addEventListener("mousemove",n),h.addEventListener("mouseup",s)),this.gc=!0,this.Tc(i,this.kc.Yc),this.uc||(this.ec=0,this.uc=setTimeout(this.xc.bind(this),500));}},t.prototype.Cc=function(){var t=this;this.yc.addEventListener("mouseenter",this.Sc.bind(this)),this.yc.addEventListener("touchcancel",this.Nc.bind(this));var i=this.yc.ownerDocument,n=function(i){t.kc.Kc&&(i.composed&&t.yc.contains(i.composedPath()[0])||i.target&&t.yc.contains(i.target)||t.kc.Kc());};this.vc=function(){i.removeEventListener("mousedown",n),i.removeEventListener("touchstart",n);},i.addEventListener("mousedown",n),i.addEventListener("touchstart",n,{passive:!0}),this.yc.addEventListener("mouseleave",this.Rc.bind(this)),this.yc.addEventListener("touchstart",this.Uc.bind(this),{passive:!0}),pn||this.yc.addEventListener("mousedown",this.Uc.bind(this)),this.$c(),this.yc.addEventListener("touchmove",(function(){}),{passive:!1});},t.prototype.$c=function(){var t=this;void 0===this.kc.Xc&&void 0===this.kc.Zc&&void 0===this.kc.Jc||(this.yc.addEventListener("touchstart",(function(i){return t.Gc(i.touches)}),{passive:!0}),this.yc.addEventListener("touchmove",(function(i){if(2===i.touches.length&&null!==t.wc&&void 0!==t.kc.Zc){var n=Cn(i.touches[0],i.touches[1])/t.Mc;t.kc.Zc(t.wc,n),xn(i);}}),{passive:!1}),this.yc.addEventListener("touchend",(function(i){t.Gc(i.touches);})));},t.prototype.Gc=function(t){1===t.length&&(this.bc=!1),2!==t.length||this.bc||this.oc?this.Qc():this.tv(t);},t.prototype.tv=function(t){var i=kn(this.yc);this.wc={p:(t[0].clientX-i.left+(t[1].clientX-i.left))/2,g:(t[0].clientY-i.top+(t[1].clientY-i.top))/2},this.Mc=Cn(t[0],t[1]),void 0!==this.kc.Xc&&this.kc.Xc(),this.Nc();},t.prototype.Qc=function(){null!==this.wc&&(this.wc=null,void 0!==this.kc.Jc&&this.kc.Jc());},t.prototype.Rc=function(t){this._c&&this._c();var i=this.Ac(t);this.Tc(i,this.kc.iv);},t.prototype.Hc=function(t){var i=this.Ac(t);this.Tc(i,this.kc.nv),this.cc=!0,this.oc=!0;},t.prototype.Tc=function(t,i){i&&i.call(this.kc,t);},t.prototype.Ac=function(t){var i;i="touches"in t&&t.touches.length?t.touches[0]:"changedTouches"in t&&t.changedTouches.length?t.changedTouches[0]:t;var n=kn(this.yc);return {sv:i.clientX,hv:i.clientY,Ec:i.pageX,Vc:i.pageY,rv:i.screenX,ev:i.screenY,uv:i.clientX-n.left,av:i.clientY-n.top,ov:t.ctrlKey,lv:t.altKey,fv:t.shiftKey,cv:t.metaKey,ke:t.type.startsWith("mouse")?"mouse":"touch",vv:t.view}},t}();function kn(t){return t.getBoundingClientRect()||{left:0,top:0}}function Cn(t,i){var n=t.clientX-i.clientX,s=t.clientY-i.clientY;return Math.sqrt(n*n+s*s)}function Nn(t){return Boolean(t.touches)}function xn(t){t.cancelable&&t.preventDefault();}var Sn=function(){function t(t,i,n,s){this.Pu=new pi(200),this.fe=0,this._v="",this.ma="",this.Vu=[],this.dv=new Map,this.fe=t,this._v=i,this.ma=Ut(t,n,s);}return t.prototype.en=function(){this.Pu.Ou(),this.Vu=[],this.dv.clear();},t.prototype.wv=function(t,i,n,s,h){var r=this.Mv(t,i);if("left"!==h){var e=cn(t.canvas);n-=Math.floor(r.bv*e);}s-=Math.floor(r.Mt/2),t.drawImage(r.mv,n,s,r.wt,r.Mt);},t.prototype.Mv=function(t,i){var n,s=this;if(this.dv.has(i))n=l(this.dv.get(i));else {if(this.Vu.length>=200){var h=l(this.Vu.shift());this.dv.delete(h);}var r=cn(t.canvas),e=Math.ceil(this.fe/4.5),u=Math.round(this.fe/10),a=Math.ceil(this.Pu.Vt(t,i)),o=et(Math.round(a+2*e)),f=et(this.fe+2*e),c=_n(document,new fn(o,f));n={Et:i,bv:Math.round(Math.max(1,a)),wt:Math.ceil(o*r),Mt:Math.ceil(f*r),mv:c},0!==a&&(this.Vu.push(n.Et),this.dv.set(n.Et,n)),P(t=vn(n.mv),r,(function(){t.font=s.ma,t.fillStyle=s._v,t.fillText(i,0,f-e-u);}));}return n},t}(),Dn=function(){function t(t,i,n,s){var h=this;this.Gt=null,this.pv=null,this.gv=null,this.yv=!1,this.kv=new pi(50),this.Cv=new Sn(11,"#000"),this._v=null,this.ma=null,this.Nv=0,this.xv=function(){h.Sv(h.tf.ct()),h.vi.Dv().vt().Or();},this.Av=function(){h.vi.Dv().vt().Or();},this.vi=t,this.ki=i,this.tf=n,this.Tv="left"===s,this.Bv=document.createElement("div"),this.Bv.style.height="100%",this.Bv.style.overflow="hidden",this.Bv.style.width="25px",this.Bv.style.left="0",this.Bv.style.position="relative",this.Lv=dn(this.Bv,new fn(16,16)),this.Lv.subscribeCanvasConfigured(this.xv);var r=this.Lv.canvas;r.style.position="absolute",r.style.zIndex="1",r.style.left="0",r.style.top="0",this.Fv=dn(this.Bv,new fn(16,16)),this.Fv.subscribeCanvasConfigured(this.Av);var e=this.Fv.canvas;e.style.position="absolute",e.style.zIndex="2",e.style.left="0",e.style.top="0";var u={Yc:this.Ev.bind(this),zc:this.Vv.bind(this),Kc:this.Ov.bind(this),Ic:this.Wv.bind(this),jc:this.zv.bind(this),Bc:this.Pv.bind(this),iv:this.Rv.bind(this)};this.Iv=new yn(this.Fv.canvas,u,{Oc:!1,Wc:!0});}return t.prototype.en=function(){this.Iv.en(),this.Fv.unsubscribeCanvasConfigured(this.Av),this.Fv.destroy(),this.Lv.unsubscribeCanvasConfigured(this.xv),this.Lv.destroy(),null!==this.Gt&&this.Gt.Is().sn(this),this.Gt=null,null!==this.gv&&(clearTimeout(this.gv),this.gv=null),this.Cv.en();},t.prototype.jv=function(){return this.Bv},t.prototype.N=function(){return f(this.Gt).ct().borderColor},t.prototype.qv=function(){return this.ki.textColor},t.prototype.Wt=function(){return this.ki.fontSize},t.prototype.Uv=function(){return Ut(this.Wt(),this.ki.fontFamily)},t.prototype.Hv=function(){var t=this.tf.ct(),i=this._v!==t.et,n=this.ma!==t.Nt;return (i||n)&&(this.Sv(t),this._v=t.et),n&&(this.kv.Ou(),this.ma=t.Nt),t},t.prototype.Yv=function(){if(null===this.Gt)return 0;var t=34,i=this.Hv(),n=vn(this.Lv.canvas),s=this.Gt.Fn();n.font=this.Uv(),s.length>0&&(t=Math.max(this.kv.Vt(n,s[0].Tn),this.kv.Vt(n,s[s.length-1].Tn)));for(var h=this.Kv(),r=h.length;r--;){var e=this.kv.Vt(n,h[r].Et());e>t&&(t=e);}var u=this.Gt.H();if(null!==u&&null!==this.pv){var a=this.Gt.Si(1,u),o=this.Gt.Si(this.pv.ht-2,u);t=Math.max(t,this.kv.Vt(n,this.Gt.ii(Math.floor(Math.min(a,o))+.11111111111111,u)),this.kv.Vt(n,this.Gt.ii(Math.ceil(Math.max(a,o))-.11111111111111,u)));}var l=Math.ceil(i.At+i.Dt+i.Lt+i.Ft+t);return l+=l%2},t.prototype.$v=function(t){if(t.st<0||t.ht<0)throw new Error("Try to set invalid size to PriceAxisWidget "+JSON.stringify(t));null!==this.pv&&this.pv.on(t)||(this.pv=t,this.Lv.resizeCanvas({width:t.st,height:t.ht}),this.Fv.resizeCanvas({width:t.st,height:t.ht}),this.Bv.style.width=t.st+"px",this.Bv.style.height=t.ht+"px",this.Bv.style.minWidth=t.st+"px");},t.prototype.Xv=function(){return f(this.pv).st},t.prototype.fi=function(t){this.Gt!==t&&(null!==this.Gt&&this.Gt.Is().sn(this),this.Gt=t,t.Is().Ji(this.qn.bind(this),this));},t.prototype.$=function(){return this.Gt},t.prototype.Ou=function(){var t=this.vi.Zv();this.vi.Dv().vt().Ll(t,f(this.$()));},t.prototype.Jv=function(t){if(null!==this.pv){if(1!==t){var i=vn(this.Lv.canvas);this.Gv(),this.Qv(i,this.Lv.pixelRatio),this.yu(i,this.Lv.pixelRatio),this.t_(i,this.Lv.pixelRatio),this.i_(i,this.Lv.pixelRatio);}var n=vn(this.Fv.canvas),s=this.pv.st,h=this.pv.ht;P(n,this.Fv.pixelRatio,(function(){n.clearRect(0,0,s,h);})),this.n_(n,this.Fv.pixelRatio);}},t.prototype.s_=function(){return this.Lv.canvas},t.prototype.Ev=function(t){if(null!==this.Gt&&!this.Gt.ti()&&this.vi.Dv().ct().handleScale.axisPressedMouseMove.price){var i=this.vi.Dv().vt(),n=this.vi.Zv();this.yv=!0,i.Nl(n,this.Gt,t.av);}},t.prototype.Vv=function(t){if(null!==this.Gt&&this.vi.Dv().ct().handleScale.axisPressedMouseMove.price){var i=this.vi.Dv().vt(),n=this.vi.Zv(),s=this.Gt;i.xl(n,s,t.av);}},t.prototype.Ov=function(){if(null!==this.Gt&&this.vi.Dv().ct().handleScale.axisPressedMouseMove.price){var t=this.vi.Dv().vt(),i=this.vi.Zv(),n=this.Gt;this.yv&&(this.yv=!1,t.Sl(i,n));}},t.prototype.Wv=function(t){if(null!==this.Gt&&this.vi.Dv().ct().handleScale.axisPressedMouseMove.price){var i=this.vi.Dv().vt(),n=this.vi.Zv();this.yv=!1,i.Sl(n,this.Gt);}},t.prototype.zv=function(t){this.vi.Dv().ct().handleScale.axisDoubleClickReset&&this.Ou();},t.prototype.Pv=function(t){null!==this.Gt&&(!this.vi.Dv().vt().ct().handleScale.axisPressedMouseMove.price||this.Gt.cs()||this.Gt.vs()||this.h_(1));},t.prototype.Rv=function(t){this.h_(0);},t.prototype.Kv=function(){var t=this,i=[],n=null===this.Gt?void 0:this.Gt;return function(s){for(var h=0;h<s.length;++h)for(var r=s[h].Pi(t.vi.Zv(),n),e=0;e<r.length;e++)i.push(r[e]);}(this.vi.Zv().Os()),i},t.prototype.Qv=function(t,i){var n=this;if(null!==this.pv){var s=this.pv.st,h=this.pv.ht;P(t,i,(function(){var i=n.vi.Zv().vt(),r=i.Rf(),e=i.Pf();r===e?R(t,0,0,s,h,r):I(t,0,0,s,h,r,e);}));}},t.prototype.yu=function(t,i){if(null!==this.pv&&null!==this.Gt&&this.Gt.ct().borderVisible){t.save(),t.fillStyle=this.N();var n,s=Math.max(1,Math.floor(this.Hv().At*i));n=this.Tv?Math.floor(this.pv.st*i)-s:0,t.fillRect(n,0,s,Math.ceil(this.pv.ht*i)),t.restore();}},t.prototype.t_=function(t,i){if(null!==this.pv&&null!==this.Gt){var n=this.Gt.Fn();t.save(),t.strokeStyle=this.N(),t.font=this.Uv(),t.fillStyle=this.N();var s=this.Hv(),h=this.Gt.ct().borderVisible&&this.Gt.ct().drawTicks,r=this.Tv?Math.floor((this.pv.st-s.Dt)*i-s.At*i):Math.floor(s.At*i),e=this.Tv?Math.round(r-s.Lt*i):Math.round(r+s.Dt*i+s.Lt*i),u=this.Tv?"right":"left",a=Math.max(1,Math.floor(i)),o=Math.floor(.5*i);if(h){var l=Math.round(s.Dt*i);t.beginPath();for(var f=0,c=n;f<c.length;f++){var v=c[f];t.rect(r,Math.round(v.An*i)-o,l,a);}t.fill();}t.fillStyle=this.qv();for(var _=0,d=n;_<d.length;_++){v=d[_];this.Cv.wv(t,v.Tn,e,Math.round(v.An*i),u);}t.restore();}},t.prototype.Gv=function(){if(null!==this.pv&&null!==this.Gt){var t=this.pv.ht/2,i=[],n=this.Gt.Os().slice(),s=this.vi.Zv(),h=this.Hv();this.Gt===s.xi()&&this.vi.Zv().Os().forEach((function(t){s.Uu(t)&&n.push(t);}));var r=this.Gt.Vs()[0],e=this.Gt;n.forEach((function(n){var h=n.Pi(s,e);h.forEach((function(t){t.Kt(null),t.$t()&&i.push(t);})),r===n&&h.length>0&&(t=h[0].zt());}));var u=i.filter((function(i){return i.zt()<=t})),a=i.filter((function(i){return i.zt()>t}));if(u.sort((function(t,i){return i.zt()-t.zt()})),u.length&&a.length&&a.push(u[0]),a.sort((function(t,i){return t.zt()-i.zt()})),i.forEach((function(t){return t.Kt(t.zt())})),this.Gt.ct().alignLabels){for(var o=1;o<u.length;o++){var l=u[o],f=(v=u[o-1]).Mt(h,!1);l.zt()>(_=v.Yt())-f&&l.Kt(_-f);}for(var c=1;c<a.length;c++){var v,_;l=a[c],f=(v=a[c-1]).Mt(h,!0);l.zt()<(_=v.Yt())+f&&l.Kt(_+f);}}}},t.prototype.i_=function(t,i){var n=this;if(null!==this.pv){t.save();var s=this.pv,h=this.Kv(),r=this.Hv(),e=this.Tv?"right":"left";h.forEach((function(h){if(h.Xt()){var u=h.P(f(n.Gt));t.save(),u.h(t,r,n.kv,s.st,e,i),t.restore();}})),t.restore();}},t.prototype.n_=function(t,i){var n=this;if(null!==this.pv&&null!==this.Gt){t.save();var s=this.pv,h=this.vi.Dv().vt(),r=[],e=this.vi.Zv(),u=h.bf().Pi(e,this.Gt);u.length&&r.push(u);var a=this.Hv(),o=this.Tv?"right":"left";r.forEach((function(h){h.forEach((function(h){t.save(),h.P(f(n.Gt)).h(t,a,n.kv,s.st,o,i),t.restore();}));})),t.restore();}},t.prototype.h_=function(t){this.Bv.style.cursor=1===t?"ns-resize":"default";},t.prototype.qn=function(){var t=this,i=this.Yv();if(this.Nv<i){var n=this.vi.Dv();null===this.gv&&(this.gv=setTimeout((function(){n&&n.vt().uf(),t.gv=null;}),100));}this.Nv=i;},t.prototype.Sv=function(t){this.Cv.en(),this.Cv=new Sn(t.Wt,t.et,t.le);},t}(),An=gn;function Tn(t,i,n,s,h){t.o&&t.o(i,n,s,h);}function Bn(t,i,n,s,h){t.h(i,n,s,h);}function Ln(t,i){return t.zi(i)}function Fn(t,i){return void 0!==t.Io?t.Io(i):[]}var En=function(){function t(t,i){var n=this;this.pv=new fn(0,0),this.r_=null,this.e_=null,this.u_=null,this.a_=!1,this.o_=new it,this.l_=0,this.f_=!1,this.c_=null,this.v_=!1,this.__=null,this.d_=null,this.xv=function(){return n.w_&&n.hi().Or()},this.Av=function(){return n.w_&&n.hi().Or()},this.M_=t,this.w_=i,this.w_.Vl().Ji(this.b_.bind(this),this,!0),this.m_=document.createElement("td"),this.m_.style.padding="0",this.m_.style.position="relative";var s=document.createElement("div");s.style.width="100%",s.style.height="100%",s.style.position="relative",s.style.overflow="hidden",this.p_=document.createElement("td"),this.p_.style.padding="0",this.g_=document.createElement("td"),this.g_.style.padding="0",this.m_.appendChild(s),this.Lv=dn(s,new fn(16,16)),this.Lv.subscribeCanvasConfigured(this.xv);var h=this.Lv.canvas;h.style.position="absolute",h.style.zIndex="1",h.style.left="0",h.style.top="0",this.Fv=dn(s,new fn(16,16)),this.Fv.subscribeCanvasConfigured(this.Av);var r=this.Fv.canvas;r.style.position="absolute",r.style.zIndex="2",r.style.left="0",r.style.top="0",this.y_=document.createElement("tr"),this.y_.appendChild(this.p_),this.y_.appendChild(this.m_),this.y_.appendChild(this.g_),this.k_();var e=this.Dv().ct().handleScroll;this.Iv=new yn(this.Fv.canvas,this,{Oc:!e.vertTouchDrag,Wc:!e.horzTouchDrag});}return t.prototype.en=function(){null!==this.r_&&this.r_.en(),null!==this.e_&&this.e_.en(),this.Fv.unsubscribeCanvasConfigured(this.Av),this.Fv.destroy(),this.Lv.unsubscribeCanvasConfigured(this.xv),this.Lv.destroy(),null!==this.w_&&this.w_.Vl().sn(this),this.Iv.en();},t.prototype.Zv=function(){return f(this.w_)},t.prototype.C_=function(i){null!==this.w_&&this.w_.Vl().sn(this),this.w_=i,null!==this.w_&&this.w_.Vl().Ji(t.prototype.b_.bind(this),this,!0),this.k_();},t.prototype.Dv=function(){return this.M_},t.prototype.jv=function(){return this.y_},t.prototype.k_=function(){if(null!==this.w_&&(this.N_(),0!==this.hi().W().length)){if(null!==this.r_){var t=this.w_.kl();this.r_.fi(f(t));}if(null!==this.e_){var i=this.w_.Cl();this.e_.fi(f(i));}}},t.prototype.wl=function(){return null!==this.w_?this.w_.wl():0},t.prototype.Ml=function(t){this.w_&&this.w_.Ml(t);},t.prototype.Bc=function(t){if(this.w_){var i=t.uv,n=t.av;pn||this.x_(i,n);}},t.prototype.Yc=function(t){if(this.f_=!1,this.v_=null!==this.c_,this.w_){if(this.S_(),document.activeElement!==document.body&&document.activeElement!==document.documentElement)f(document.activeElement).blur();else {var i=document.getSelection();null!==i&&i.removeAllRanges();}var n=this.hi();if(!this.w_.xi().ti()&&!n.j().ti()){if(null!==this.c_){var s=n.bf();this.__={x:s.bt(),y:s.gt()},this.c_={x:t.uv,y:t.av};}pn||this.x_(t.uv,t.av);}}},t.prototype.Lc=function(t){if(this.w_){var i=t.uv,n=t.av;if(this.D_()&&this.A_(),!pn){this.x_(i,n);var s=this.pa(i,n);this.hi().cf(s&&{vf:s.vf,T_:s.T_});}}},t.prototype.qc=function(t){if(null!==this.w_){var i=t.uv,n=t.av;if(this.o_.rn()){var s=this.hi().bf().I();this.o_.hn(s,{x:i,y:n});}this.B_();}},t.prototype.zc=function(t){if(null!==this.w_){var i=this.hi(),n=t.uv,s=t.av;if(null!==this.c_){this.v_=!1;var h=f(this.__),r=h.x+(n-this.c_.x),e=h.y+(s-this.c_.y);this.x_(r,e);}else this.D_()||this.x_(n,s);if(!i.j().ti()){var u=this.M_.ct(),a=u.handleScroll,o=u.kineticScroll;if(a.pressedMouseMove&&"touch"!==t.ke||(a.horzTouchDrag||a.vertTouchDrag)&&"mouse"!==t.ke){var l=this.w_.xi(),c=performance.now();null!==this.u_||this.L_()||(this.u_={x:t.sv,y:t.hv,Dh:c,uv:t.uv,av:t.av}),null!==this.d_&&this.d_.tc(t.uv,c),null===this.u_||this.a_||this.u_.x===t.sv&&this.u_.y===t.hv||(null===this.d_&&("touch"===t.ke&&o.touch||"mouse"===t.ke&&o.mouse)&&(this.d_=new bn(.2,7,.997,15),this.d_.tc(this.u_.uv,this.u_.Dh),this.d_.tc(t.uv,c)),l.ti()||i.Dl(this.w_,l,t.av),i.Nf(t.uv),this.a_=!0),this.a_&&(l.ti()||i.Al(this.w_,l,t.av),i.xf(t.uv));}}}},t.prototype.Ic=function(t){null!==this.w_&&(this.f_=!1,this.F_(t));},t.prototype.nv=function(t){if(this.f_=!0,null===this.c_&&An){var i={x:t.uv,y:t.av};this.E_(i,i);}},t.prototype.iv=function(t){null!==this.w_&&(this.w_.vt().cf(null),gn||this.A_());},t.prototype.V_=function(){return this.o_},t.prototype.Xc=function(){this.l_=1,this.S_();},t.prototype.Zc=function(t,i){if(this.M_.ct().handleScale.pinch){var n=5*(i-this.l_);this.l_=i,this.hi().kf(t.p,n);}},t.prototype.pa=function(t,i){var n=this.w_;if(null===n)return null;for(var s=0,h=n.Os();s<h.length;s++){var r=h[s],e=this.O_(r.zi(n),t,i);if(null!==e)return {vf:r,vv:e.vv,T_:e.T_}}return null},t.prototype.W_=function(t,i){f("left"===i?this.r_:this.e_).$v(new fn(t,this.pv.ht));},t.prototype.z_=function(){return this.pv},t.prototype.$v=function(t){if(t.st<0||t.ht<0)throw new Error("Try to set invalid size to PaneWidget "+JSON.stringify(t));this.pv.on(t)||(this.pv=t,this.Lv.resizeCanvas({width:t.st,height:t.ht}),this.Fv.resizeCanvas({width:t.st,height:t.ht}),this.m_.style.width=t.st+"px",this.m_.style.height=t.ht+"px");},t.prototype.P_=function(){var t=f(this.w_);t.yl(t.kl()),t.yl(t.Cl());for(var i=0,n=t.Vs();i<n.length;i++){var s=n[i];if(t.Uu(s)){var h=s.$();null!==h&&t.yl(h),s.Ii();}}},t.prototype.s_=function(){return this.Lv.canvas},t.prototype.Jv=function(t){if(0!==t&&null!==this.w_){if(t>1&&this.P_(),null!==this.r_&&this.r_.Jv(t),null!==this.e_&&this.e_.Jv(t),1!==t){var i=vn(this.Lv.canvas);i.save(),this.Qv(i,this.Lv.pixelRatio),this.w_&&(this.R_(i,this.Lv.pixelRatio),this.I_(i,this.Lv.pixelRatio),this.j_(i,this.Lv.pixelRatio,Ln)),i.restore();}var n=vn(this.Fv.canvas);n.clearRect(0,0,Math.ceil(this.pv.st*this.Fv.pixelRatio),Math.ceil(this.pv.ht*this.Fv.pixelRatio)),this.j_(n,this.Lv.pixelRatio,Fn),this.q_(n,this.Fv.pixelRatio);}},t.prototype.U_=function(){return this.r_},t.prototype.H_=function(){return this.e_},t.prototype.b_=function(){null!==this.w_&&this.w_.Vl().sn(this),this.w_=null;},t.prototype.Qv=function(t,i){var n=this;P(t,i,(function(){var i=n.hi(),s=i.Rf(),h=i.Pf();s===h?R(t,0,0,n.pv.st,n.pv.ht,h):I(t,0,0,n.pv.st,n.pv.ht,s,h);}));},t.prototype.R_=function(t,i){var n=f(this.w_),s=n.Ol().sl().P(n.Mt(),n.wt());null!==s&&(t.save(),s.h(t,i,!1),t.restore());},t.prototype.I_=function(t,i){var n=this.hi().Mf();this.Y_(t,i,Ln,Tn,n),this.Y_(t,i,Ln,Bn,n);},t.prototype.q_=function(t,i){this.Y_(t,i,Ln,Bn,this.hi().bf());},t.prototype.j_=function(t,i,n){for(var s=f(this.w_).Os(),h=0,r=s;h<r.length;h++){var e=r[h];this.Y_(t,i,n,Tn,e);}for(var u=0,a=s;u<a.length;u++){e=a[u];this.Y_(t,i,n,Bn,e);}},t.prototype.Y_=function(t,i,n,s,h){for(var r=f(this.w_),e=n(h,r),u=r.Mt(),a=r.wt(),o=r.vt().ff(),l=null!==o&&o.vf===h,c=null!==o&&l&&void 0!==o.T_?o.T_.ga:void 0,v=0,_=e;v<_.length;v++){var d=_[v].P(u,a);null!==d&&(t.save(),s(d,t,i,l,c),t.restore());}},t.prototype.O_=function(t,i,n){for(var s=0,h=t;s<h.length;s++){var r=h[s],e=r.P(this.pv.ht,this.pv.st);if(null!==e&&e.pa){var u=e.pa(i,n);if(null!==u)return {vv:r,T_:u}}}return null},t.prototype.N_=function(){if(null!==this.w_){var t=this.M_,i=this.w_.kl().ct().visible,n=this.w_.Cl().ct().visible;i||null===this.r_||(this.p_.removeChild(this.r_.jv()),this.r_.en(),this.r_=null),n||null===this.e_||(this.g_.removeChild(this.e_.jv()),this.e_.en(),this.e_=null);var s=t.vt().Ff();i&&null===this.r_&&(this.r_=new Dn(this,t.ct().layout,s,"left"),this.p_.appendChild(this.r_.jv())),n&&null===this.e_&&(this.e_=new Dn(this,t.ct().layout,s,"right"),this.g_.appendChild(this.e_.jv()));}},t.prototype.D_=function(){return An&&null===this.c_},t.prototype.L_=function(){return An&&this.f_||null!==this.c_},t.prototype.K_=function(t){return Math.max(0,Math.min(t,this.pv.st-1))},t.prototype.X_=function(t){return Math.max(0,Math.min(t,this.pv.ht-1))},t.prototype.x_=function(t,i){this.hi().Tf(this.K_(t),this.X_(i),f(this.w_));},t.prototype.A_=function(){this.hi().Bf();},t.prototype.B_=function(){this.v_&&(this.c_=null,this.A_());},t.prototype.E_=function(t,i){this.c_=t,this.v_=!1,this.x_(i.x,i.y);var n=this.hi().bf();this.__={x:n.bt(),y:n.gt()};},t.prototype.hi=function(){return this.M_.vt()},t.prototype.Z_=function(){var t=this.hi(),i=this.Zv(),n=i.xi();t.Tl(i,n),t.Sf(),this.u_=null,this.a_=!1;},t.prototype.F_=function(t){var i=this;if(this.a_){var n=performance.now();if(null!==this.d_&&this.d_.ia(t.uv,n),null===this.d_||this.d_.nc(n))this.Z_();else {var s=this.hi(),h=s.j(),r=this.d_,e=function(){if(!r.hc()){var t=performance.now(),n=r.nc(t);if(!r.hc()){var u=h.Pr();s.xf(r.ic(t)),u===h.Pr()&&(n=!0,i.d_=null);}n?i.Z_():requestAnimationFrame(e);}};requestAnimationFrame(e);}}},t.prototype.S_=function(){var t=performance.now(),i=null===this.d_||this.d_.nc(t);null!==this.d_&&(i||this.Z_()),null!==this.d_&&(this.d_.rc(),this.d_=null);},t}(),Vn=function(){function t(t,i,n,s,h){var r=this;this.L=!0,this.pv=new fn(0,0),this.xv=function(){return r.Jv(3)},this.Tv="left"===t,this.tf=n.Ff,this.ki=i,this.J_=s,this.G_=h,this.Bv=document.createElement("div"),this.Bv.style.width="25px",this.Bv.style.height="100%",this.Bv.style.overflow="hidden",this.Lv=dn(this.Bv,new fn(16,16)),this.Lv.subscribeCanvasConfigured(this.xv);}return t.prototype.en=function(){this.Lv.unsubscribeCanvasConfigured(this.xv),this.Lv.destroy();},t.prototype.jv=function(){return this.Bv},t.prototype.z_=function(){return this.pv},t.prototype.$v=function(t){if(t.st<0||t.ht<0)throw new Error("Try to set invalid size to PriceAxisStub "+JSON.stringify(t));this.pv.on(t)||(this.pv=t,this.Lv.resizeCanvas({width:t.st,height:t.ht}),this.Bv.style.width=t.st+"px",this.Bv.style.minWidth=t.st+"px",this.Bv.style.height=t.ht+"px",this.L=!0);},t.prototype.Jv=function(t){if((!(t<3)||this.L)&&0!==this.pv.st&&0!==this.pv.ht){this.L=!1;var i=vn(this.Lv.canvas);this.Qv(i,this.Lv.pixelRatio),this.yu(i,this.Lv.pixelRatio);}},t.prototype.s_=function(){return this.Lv.canvas},t.prototype.yu=function(t,i){if(this.J_()){var n=this.pv.st;t.save(),t.fillStyle=this.ki.timeScale.borderColor;var s=Math.floor(this.tf.ct().At*i),h=this.Tv?Math.round(n*i)-s:0;t.fillRect(h,0,s,s),t.restore();}},t.prototype.Qv=function(t,i){var n=this;P(t,i,(function(){R(t,0,0,n.pv.st,n.pv.ht,n.G_());}));},t}();function On(t,i){return t.Rh>i.Rh?t:i}var Wn=function(){function t(t){var i=this;this.Q_=null,this.td=null,this.oe=null,this.nd=!1,this.pv=new fn(0,0),this.sd=new it,this.kv=new pi(5),this.xv=function(){return i.M_.vt().Or()},this.Av=function(){return i.M_.vt().Or()},this.M_=t,this.ki=t.ct().layout,this.hd=document.createElement("tr"),this.rd=document.createElement("td"),this.rd.style.padding="0",this.ed=document.createElement("td"),this.ed.style.padding="0",this.Bv=document.createElement("td"),this.Bv.style.height="25px",this.Bv.style.padding="0",this.ud=document.createElement("div"),this.ud.style.width="100%",this.ud.style.height="100%",this.ud.style.position="relative",this.ud.style.overflow="hidden",this.Bv.appendChild(this.ud),this.Lv=dn(this.ud,new fn(16,16)),this.Lv.subscribeCanvasConfigured(this.xv);var n=this.Lv.canvas;n.style.position="absolute",n.style.zIndex="1",n.style.left="0",n.style.top="0",this.Fv=dn(this.ud,new fn(16,16)),this.Fv.subscribeCanvasConfigured(this.Av);var s=this.Fv.canvas;s.style.position="absolute",s.style.zIndex="2",s.style.left="0",s.style.top="0",this.hd.appendChild(this.rd),this.hd.appendChild(this.Bv),this.hd.appendChild(this.ed),this.ad(),this.M_.vt().dl().Ji(this.ad.bind(this),this),this.Iv=new yn(this.Fv.canvas,this,{Oc:!0,Wc:!1});}return t.prototype.en=function(){this.Iv.en(),null!==this.Q_&&this.Q_.en(),null!==this.td&&this.td.en(),this.Fv.unsubscribeCanvasConfigured(this.Av),this.Fv.destroy(),this.Lv.unsubscribeCanvasConfigured(this.xv),this.Lv.destroy();},t.prototype.jv=function(){return this.hd},t.prototype.od=function(){return this.Q_},t.prototype.ld=function(){return this.td},t.prototype.Yc=function(t){if(!this.nd){this.nd=!0;var i=this.M_.vt();!i.j().ti()&&this.M_.ct().handleScale.axisPressedMouseMove.time&&i.yf(t.uv);}},t.prototype.Kc=function(){var t=this.M_.vt();!t.j().ti()&&this.nd&&(this.nd=!1,this.M_.ct().handleScale.axisPressedMouseMove.time&&t.Af());},t.prototype.zc=function(t){var i=this.M_.vt();!i.j().ti()&&this.M_.ct().handleScale.axisPressedMouseMove.time&&i.Df(t.uv);},t.prototype.Ic=function(t){this.nd=!1;var i=this.M_.vt();i.j().ti()&&!this.M_.ct().handleScale.axisPressedMouseMove.time||i.Af();},t.prototype.jc=function(){this.M_.ct().handleScale.axisDoubleClickReset&&this.M_.vt().Ne();},t.prototype.Bc=function(t){this.M_.vt().ct().handleScale.axisPressedMouseMove.time&&this.h_(1);},t.prototype.iv=function(t){this.h_(0);},t.prototype.z_=function(){return this.pv},t.prototype.fd=function(){return this.sd},t.prototype.vd=function(t,i,n){this.pv&&this.pv.on(t)||(this.pv=t,this.Lv.resizeCanvas({width:t.st,height:t.ht}),this.Fv.resizeCanvas({width:t.st,height:t.ht}),this.Bv.style.width=t.st+"px",this.Bv.style.height=t.ht+"px",this.sd.hn(t)),null!==this.Q_&&this.Q_.$v(new fn(i,t.ht)),null!==this.td&&this.td.$v(new fn(n,t.ht));},t.prototype._d=function(){var t=this.dd();return Math.ceil(t.At+t.Dt+t.Wt+t.Tt+t.Bt)},t.prototype.O=function(){this.M_.vt().j().Fn();},t.prototype.s_=function(){return this.Lv.canvas},t.prototype.Jv=function(t){if(0!==t){if(1!==t){var i=vn(this.Lv.canvas);this.Qv(i,this.Lv.pixelRatio),this.yu(i,this.Lv.pixelRatio),this.t_(i,this.Lv.pixelRatio),null!==this.Q_&&this.Q_.Jv(t),null!==this.td&&this.td.Jv(t);}var n=vn(this.Fv.canvas),s=this.Fv.pixelRatio;n.clearRect(0,0,Math.ceil(this.pv.st*s),Math.ceil(this.pv.ht*s)),this.wd([this.M_.vt().bf()],n,s);}},t.prototype.Qv=function(t,i){var n=this;P(t,i,(function(){R(t,0,0,n.pv.st,n.pv.ht,n.M_.vt().Pf());}));},t.prototype.yu=function(t,i){if(this.M_.ct().timeScale.borderVisible){t.save(),t.fillStyle=this.Md();var n=Math.max(1,Math.floor(this.dd().At*i));t.fillRect(0,0,Math.ceil(this.pv.st*i),n),t.restore();}},t.prototype.t_=function(t,i){var n=this,s=this.M_.vt().j().Fn();if(s&&0!==s.length){var h=s.reduce(On,s[0]).Rh;h>30&&h<50&&(h=30),t.save(),t.strokeStyle=this.Md();var r=this.dd(),e=r.At+r.Dt+r.Tt+r.Wt-r.Ot;t.textAlign="center",t.fillStyle=this.Md();var u=Math.floor(this.dd().At*i),a=Math.max(1,Math.floor(i)),o=Math.floor(.5*i);if(this.M_.vt().j().ct().borderVisible){t.beginPath();for(var l=Math.round(r.Dt*i),f=s.length;f--;){var c=Math.round(s[f].An*i);t.rect(c-o,u,a,l);}t.fill();}t.fillStyle=this.ve(),P(t,i,(function(){t.font=n.bd();for(var i=0,r=s;i<r.length;i++){if((l=r[i]).Rh<h){var u=l.Ir?n.md(t,l.An,l.Tn):l.An;t.fillText(l.Tn,u,e);}}t.font=n.pd();for(var a=0,o=s;a<o.length;a++){var l;if((l=o[a]).Rh>=h){u=l.Ir?n.md(t,l.An,l.Tn):l.An;t.fillText(l.Tn,u,e);}}}));}},t.prototype.md=function(t,i,n){var s=this.kv.Vt(t,n),h=s/2,r=Math.floor(i-h)+.5;return r<0?i+=Math.abs(0-r):r+s>this.pv.st&&(i-=Math.abs(this.pv.st-(r+s))),i},t.prototype.wd=function(t,i,n){for(var s=this.dd(),h=0,r=t;h<r.length;h++)for(var e=0,u=r[h].ci();e<u.length;e++){var a=u[e];i.save(),a.P().h(i,s,n),i.restore();}},t.prototype.Md=function(){return this.M_.ct().timeScale.borderColor},t.prototype.ve=function(){return this.ki.textColor},t.prototype.fe=function(){return this.ki.fontSize},t.prototype.bd=function(){return Ut(this.fe(),this.ki.fontFamily)},t.prototype.pd=function(){return Ut(this.fe(),this.ki.fontFamily,"bold")},t.prototype.dd=function(){null===this.oe&&(this.oe={At:1,Ot:NaN,Tt:NaN,Bt:NaN,si:NaN,Dt:3,Wt:NaN,Nt:"",ni:new pi});var t=this.oe,i=this.bd();if(t.Nt!==i){var n=this.fe();t.Wt=n,t.Nt=i,t.Tt=Math.ceil(n/2.5),t.Bt=t.Tt,t.si=Math.ceil(n/2),t.Ot=Math.round(this.fe()/5),t.ni.Ou();}return this.oe},t.prototype.h_=function(t){this.Bv.style.cursor=1===t?"ew-resize":"default";},t.prototype.ad=function(){var t=this.M_.vt(),i=t.ct();i.leftPriceScale.visible||null===this.Q_||(this.rd.removeChild(this.Q_.jv()),this.Q_.en(),this.Q_=null),i.rightPriceScale.visible||null===this.td||(this.ed.removeChild(this.td.jv()),this.td.en(),this.td=null);var n={Ff:this.M_.vt().Ff()},s=function(){return i.leftPriceScale.borderVisible&&t.j().ct().borderVisible},h=function(){return t.Pf()};i.leftPriceScale.visible&&null===this.Q_&&(this.Q_=new Vn("left",i,n,s,h),this.rd.appendChild(this.Q_.jv())),i.rightPriceScale.visible&&null===this.td&&(this.td=new Vn("right",i,n,s,h),this.ed.appendChild(this.td.jv()));},t}(),zn=function(){function t(t,i){var n;this.gd=[],this.yd=0,this.En=0,this.$h=0,this.kd=0,this.Cd=0,this.Nd=null,this.xd=!1,this.o_=new it,this.Jl=new it,this.ki=i,this.hd=document.createElement("div"),this.hd.classList.add("tv-lightweight-charts"),this.hd.style.overflow="hidden",this.hd.style.width="100%",this.hd.style.height="100%",(n=this.hd).style.userSelect="none",n.style.webkitUserSelect="none",n.style.msUserSelect="none",n.style.MozUserSelect="none",n.style.webkitTapHighlightColor="transparent",this.Sd=document.createElement("table"),this.Sd.setAttribute("cellspacing","0"),this.hd.appendChild(this.Sd),this.Dd=this.Ad.bind(this),this.hd.addEventListener("wheel",this.Dd,{passive:!1}),this.hi=new ln(this.Ql.bind(this),this.ki),this.vt().mf().Ji(this.Td.bind(this),this),this.Bd=new Wn(this),this.Sd.appendChild(this.Bd.jv());var s=this.ki.width,h=this.ki.height;if(0===s||0===h){var r=t.getBoundingClientRect();0===s&&(s=Math.floor(r.width),s-=s%2),0===h&&(h=Math.floor(r.height),h-=h%2);}this.Ld(s,h),this.Fd(),t.appendChild(this.hd),this.Ed(),this.hi.j().Jr().Ji(this.hi.uf.bind(this.hi),this),this.hi.dl().Ji(this.hi.uf.bind(this.hi),this);}return t.prototype.vt=function(){return this.hi},t.prototype.ct=function(){return this.ki},t.prototype.Vd=function(){return this.gd},t.prototype.Od=function(){return this.Bd},t.prototype.en=function(){this.hd.removeEventListener("wheel",this.Dd),0!==this.yd&&window.cancelAnimationFrame(this.yd),this.hi.mf().sn(this),this.hi.j().Jr().sn(this),this.hi.dl().sn(this),this.hi.en();for(var t=0,i=this.gd;t<i.length;t++){var n=i[t];this.Sd.removeChild(n.jv()),n.V_().sn(this),n.en();}this.gd=[],f(this.Bd).en(),null!==this.hd.parentElement&&this.hd.parentElement.removeChild(this.hd),this.Jl.en(),this.o_.en();},t.prototype.Ld=function(t,i,n){if(void 0===n&&(n=!1),this.En!==i||this.$h!==t){this.En=i,this.$h=t;var s=i+"px",h=t+"px";f(this.hd).style.height=s,f(this.hd).style.width=h,this.Sd.style.height=s,this.Sd.style.width=h,n?this.Wd(new Kt(3)):this.hi.uf();}},t.prototype.Jv=function(t){void 0===t&&(t=new Kt(3));for(var i=0;i<this.gd.length;i++)this.gd[i].Jv(t.ge(i).me);this.ki.timeScale.visible&&this.Bd.Jv(t.pe());},t.prototype.rs=function(t){this.hi.rs(t),this.Ed();var i=t.width||this.$h,n=t.height||this.En;this.Ld(i,n);},t.prototype.V_=function(){return this.o_},t.prototype.mf=function(){return this.Jl},t.prototype.zd=function(){var t=this;null!==this.Nd&&(this.Wd(this.Nd),this.Nd=null);var i=this.gd[0],n=_n(document,new fn(this.$h,this.En)),s=vn(n),h=cn(n);return P(s,h,(function(){var n=0,h=0,r=function(i){for(var r=0;r<t.gd.length;r++){var e=t.gd[r],u=e.z_().ht,a=f("left"===i?e.U_():e.H_()),o=a.s_();s.drawImage(o,n,h,a.Xv(),u),h+=u;}};t.Pd()&&(r("left"),n=f(i.U_()).Xv()),h=0;for(var e=0;e<t.gd.length;e++){var u=t.gd[e],a=u.z_(),o=u.s_();s.drawImage(o,n,h,a.st,a.ht),h+=a.ht;}n+=i.z_().st,t.Rd()&&(h=0,r("right"));var l=function(i){var r=f("left"===i?t.Bd.od():t.Bd.ld()),e=r.z_(),u=r.s_();s.drawImage(u,n,h,e.st,e.ht);};if(t.ki.timeScale.visible){n=0,t.Pd()&&(l("left"),n=f(i.U_()).Xv());var c=t.Bd.z_();o=t.Bd.s_();s.drawImage(o,n,h,c.st,c.ht),t.Rd()&&(n+=i.z_().st,l("right"),s.restore());}})),n},t.prototype.Id=function(t){return "none"===t?0:("left"!==t||this.Pd())&&("right"!==t||this.Rd())?0===this.gd.length?0:f("left"===t?this.gd[0].U_():this.gd[0].H_()).Xv():0},t.prototype.jd=function(){for(var t=0,i=0,n=0,s=0,h=this.gd;s<h.length;s++){var r=h[s];this.Pd()&&(i=Math.max(i,f(r.U_()).Yv())),this.Rd()&&(n=Math.max(n,f(r.H_()).Yv())),t+=r.wl();}var e=this.$h,u=this.En,a=Math.max(e-i-n,0),o=this.ki.timeScale.visible,l=o?this.Bd._d():0;l%2&&(l+=1);for(var c=0+l,v=u<c?0:u-c,_=v/t,d=0,w=0;w<this.gd.length;++w){(r=this.gd[w]).C_(this.hi.wf()[w]);var M,b=0;b=w===this.gd.length-1?v-d:Math.round(r.wl()*_),d+=M=Math.max(b,2),r.$v(new fn(a,M)),this.Pd()&&r.W_(i,"left"),this.Rd()&&r.W_(n,"right"),r.Zv()&&this.hi.pf(r.Zv(),M);}this.Bd.vd(new fn(o?a:0,l),o?i:0,o?n:0),this.hi.Dr(a),this.kd!==i&&(this.kd=i),this.Cd!==n&&(this.Cd=n);},t.prototype.Ad=function(t){var i=t.deltaX/100,n=-t.deltaY/100;if(0!==i&&this.ki.handleScroll.mouseWheel||0!==n&&this.ki.handleScale.mouseWheel){switch(t.cancelable&&t.preventDefault(),t.deltaMode){case t.DOM_DELTA_PAGE:i*=120,n*=120;break;case t.DOM_DELTA_LINE:i*=32,n*=32;}if(0!==n&&this.ki.handleScale.mouseWheel){var s=Math.sign(n)*Math.min(1,Math.abs(n)),h=t.clientX-this.hd.getBoundingClientRect().left;this.vt().kf(h,s);}0!==i&&this.ki.handleScroll.mouseWheel&&this.vt().Cf(-80*i);}},t.prototype.Wd=function(t){var i=t.pe();if(3===i&&this.qd(),3===i||2===i){for(var n=this.hi.wf(),s=0;s<n.length;s++)t.ge(s)._s&&n[s].Fl();for(var h=t.xe(),r=0,e=h;r<e.length;r++){var u=e[r];this.Se(u);}h.length>0&&(this.hi.Vr(),this.hi.Eo(),this.hi.Or()),this.Bd.O();}this.Jv(t);},t.prototype.Se=function(t){var i=this.hi.j();switch(t.ke){case 0:i.Qr();break;case 1:i.te(t.X);break;case 2:i.wr(t.X);break;case 3:i.Mr(t.X);break;case 4:i.jr();}},t.prototype.Ql=function(t){var i=this;null!==this.Nd?this.Nd._n(t):this.Nd=t,this.xd||(this.xd=!0,this.yd=window.requestAnimationFrame((function(){i.xd=!1,i.yd=0,null!==i.Nd&&(i.Wd(i.Nd),i.Nd=null);})));},t.prototype.qd=function(){this.Fd();},t.prototype.Fd=function(){for(var t=this.hi.wf(),i=t.length,n=this.gd.length,s=i;s<n;s++){var h=l(this.gd.pop());this.Sd.removeChild(h.jv()),h.V_().sn(this),h.en();}for(s=n;s<i;s++){(h=new En(this,t[s])).V_().Ji(this.Ud.bind(this),this),this.gd.push(h),this.Sd.insertBefore(h.jv(),this.Bd.jv());}for(s=0;s<i;s++){var r=t[s];(h=this.gd[s]).Zv()!==r?h.C_(r):h.k_();}this.Ed(),this.jd();},t.prototype.Hd=function(t,i){var n,s=new Map;null!==t&&this.hi.W().forEach((function(i){var n=i.Fa(t);null!==n&&s.set(i,n);}));if(null!==t){var h=this.hi.j().ri(t);null!==h&&(n=h);}var r=this.vt().ff(),e=null!==r&&r.vf instanceof tn?r.vf:void 0,u=null!==r&&void 0!==r.T_?r.T_.ka:void 0;return {S:n,Yd:i||void 0,Kd:e,$d:s,Xd:u}},t.prototype.Ud=function(t,i){var n=this;this.o_.hn((function(){return n.Hd(t,i)}));},t.prototype.Td=function(t,i){var n=this;this.Jl.hn((function(){return n.Hd(t,i)}));},t.prototype.Ed=function(){var t=this.ki.timeScale.visible?"":"none";this.Bd.jv().style.display=t;},t.prototype.Pd=function(){return this.gd[0].Zv().kl().ct().visible},t.prototype.Rd=function(){return this.gd[0].Zv().Cl().ct().visible},t}();function Pn(t,i,n){var s=n.value,h={Ph:i,S:t,X:[s,s,s,s]};return "color"in n&&void 0!==n.color&&(h.et=n.color),h}function Rn(t,i,n){return {Ph:i,S:t,X:[n.open,n.high,n.low,n.close]}}function In(t){return void 0!==t.X}function jn(t){return function(i,n,s){return void 0===(h=s).open&&void 0===h.value?{S:i,Ph:n}:t(i,n,s);var h;}}var qn={Candlestick:jn(Rn),Bar:jn(Rn),Area:jn(Pn),Baseline:jn(Pn),Histogram:jn(Pn),Line:jn(Pn)};function Un(t){return qn[t]}function Hn(t){return 60*t*60*1e3}function Yn(t){return 60*t*1e3}var Kn,$n=[{Zd:(Kn=1,1e3*Kn),Rh:10},{Zd:Yn(1),Rh:20},{Zd:Yn(5),Rh:21},{Zd:Yn(30),Rh:22},{Zd:Hn(1),Rh:30},{Zd:Hn(3),Rh:31},{Zd:Hn(6),Rh:32},{Zd:Hn(12),Rh:33}];function Xn(t,i){if(t.getUTCFullYear()!==i.getUTCFullYear())return 70;if(t.getUTCMonth()!==i.getUTCMonth())return 60;if(t.getUTCDate()!==i.getUTCDate())return 50;for(var n=$n.length-1;n>=0;--n)if(Math.floor(i.getTime()/$n[n].Zd)!==Math.floor(t.getTime()/$n[n].Zd))return $n[n].Rh;return 0}function Zn(t,i){if(void 0===i&&(i=0),0!==t.length){for(var n=0===i?null:t[i-1].S.Dh,s=null!==n?new Date(1e3*n):null,h=0,r=i;r<t.length;++r){var e=t[r],u=new Date(1e3*e.S.Dh);null!==s&&(e.zh=Xn(u,s)),h+=e.S.Dh-(n||e.S.Dh),n=e.S.Dh,s=u;}if(0===i&&t.length>1){var a=Math.ceil(h/(t.length-1)),o=new Date(1e3*(t[0].S.Dh-a));t[0].zh=Xn(new Date(1e3*t[0].S.Dh),o);}}}function Jn(t){if(!It(t))throw new Error("time must be of type BusinessDay");var i=new Date(Date.UTC(t.year,t.month-1,t.day,0,0,0,0));return {Dh:Math.round(i.getTime()/1e3),Sh:t}}function Gn(t){if(!jt(t))throw new Error("time must be of type isUTCTimestamp");return {Dh:t}}function Qn(t){return 0===t.length?null:It(t[0].time)?Jn:Gn}function ts(t){return jt(t)?Gn(t):It(t)?Jn(t):Jn(is(t))}function is(t){var i=new Date(t);if(isNaN(i.getTime()))throw new Error("Invalid date string="+t+", expected format=yyyy-mm-dd");return {day:i.getUTCDate(),month:i.getUTCMonth()+1,year:i.getUTCFullYear()}}function ns(t){w(t.time)&&(t.time=is(t.time));}function ss(t){return {Ph:0,Jd:new Map,Rs:t}}var hs=function(){function t(){this.Gd=new Map,this.Qd=new Map,this.tw=new Map,this.iw=[];}return t.prototype.en=function(){this.Gd.clear(),this.Qd.clear(),this.tw.clear(),this.iw=[];},t.prototype.nw=function(t,i){var n=this,s=0!==this.Gd.size,h=!1;if(this.Qd.has(t))if(1===this.Qd.size)s=!1,h=!0,this.Gd.clear();else for(var r=0,e=this.iw;r<e.length;r++){e[r].pointData.Jd.delete(t)&&(h=!0);}var u=[];if(0!==i.length){!function(t){t.forEach(ns);}(i);var a=f(Qn(i)),o=Un(t.Ya());u=i.map((function(i){var s=a(i.time),r=n.Gd.get(s.Dh);void 0===r&&(r=ss(s),n.Gd.set(s.Dh,r),h=!0);var e=o(s,r.Ph,i);return r.Jd.set(t,e),e}));}s&&this.sw(),this.hw(t,u);var l=-1;if(h){var c=[];this.Gd.forEach((function(t){c.push({zh:0,S:t.Rs,pointData:t});})),c.sort((function(t,i){return t.S.Dh-i.S.Dh})),l=this.rw(c);}return this.ew(t,l)},t.prototype.Of=function(t){return this.nw(t,[])},t.prototype.uw=function(t,i){ns(i);var n=f(Qn([i]))(i.time),s=this.tw.get(t);if(void 0!==s&&n.Dh<s.Dh)throw new Error("Cannot update oldest data, last time="+s.Dh+", new time="+n.Dh);var h=this.Gd.get(n.Dh),r=void 0===h;void 0===h&&(h=ss(n),this.Gd.set(n.Dh,h));var e=Un(t.Ya())(n,h.Ph,i);if(h.Jd.set(t,e),this.aw(t,e),!r)return this.ew(t,-1);var u={zh:0,S:h.Rs,pointData:h},a=Bt(this.iw,u.S.Dh,(function(t,i){return t.S.Dh<i}));this.iw.splice(a,0,u);for(var o=a;o<this.iw.length;++o)rs(this.iw[o].pointData,o);return Zn(this.iw,a),this.ew(t,a)},t.prototype.aw=function(t,i){var n=this.Qd.get(t);void 0===n&&(n=[],this.Qd.set(t,n));var s=0!==n.length?n[n.length-1]:null;null===s||i.S.Dh>s.S.Dh?In(i)&&n.push(i):In(i)?n[n.length-1]=i:n.splice(-1,1),this.tw.set(t,i.S);},t.prototype.hw=function(t,i){0!==i.length?(this.Qd.set(t,i.filter(In)),this.tw.set(t,i[i.length-1].S)):(this.Qd.delete(t),this.tw.delete(t));},t.prototype.sw=function(){for(var t=0,i=this.iw;t<i.length;t++){var n=i[t];0===n.pointData.Jd.size&&this.Gd.delete(n.S.Dh);}},t.prototype.rw=function(t){for(var i=-1,n=0;n<this.iw.length&&n<t.length;++n){var s=this.iw[n],h=t[n];if(s.S.Dh!==h.S.Dh){i=n;break}h.zh=s.zh,rs(h.pointData,n);}if(-1===i&&this.iw.length!==t.length&&(i=Math.min(this.iw.length,t.length)),-1===i)return -1;for(n=i;n<t.length;++n)rs(t[n].pointData,n);return Zn(t,i),this.iw=t,i},t.prototype.ow=function(){if(0===this.Qd.size)return null;var t=0;return this.Qd.forEach((function(i){0!==i.length&&(t=Math.max(t,i[i.length-1].Ph));})),t},t.prototype.ew=function(t,i){var n={lw:new Map,j:{Br:this.ow()}};if(-1!==i)this.Qd.forEach((function(t,i){n.lw.set(i,{Zu:t});})),this.Qd.has(t)||n.lw.set(t,{Zu:[]}),n.j.fw=this.iw,n.j.cw=i;else {var s=this.Qd.get(t);n.lw.set(t,{Zu:s||[]});}return n},t}();function rs(t,i){t.Ph=i,t.Jd.forEach((function(t){t.Ph=i;}));}var es={color:"#FF0000",price:0,lineStyle:2,lineWidth:1,axisLabelVisible:!0,title:""},us=function(){function t(t){this.Ia=t;}return t.prototype.applyOptions=function(t){this.Ia.rs(t);},t.prototype.options=function(){return this.Ia.ct()},t.prototype._w=function(){return this.Ia},t}();function as(t){var i=t.overlay,n=function(t,i){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&i.indexOf(s)<0&&(n[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var h=0;for(s=Object.getOwnPropertySymbols(t);h<s.length;h++)i.indexOf(s[h])<0&&Object.prototype.propertyIsEnumerable.call(t,s[h])&&(n[s[h]]=t[s[h]]);}return n}(t,["overlay"]);return i&&(n.priceScaleId=""),n}var os=function(){function t(t,i,n){this.qe=t,this.dw=i,this.ww=n;}return t.prototype.priceFormatter=function(){return this.qe.$s()},t.prototype.priceToCoordinate=function(t){var i=this.qe.H();return null===i?null:this.qe.$().K(t,i.X)},t.prototype.coordinateToPrice=function(t){var i=this.qe.H();return null===i?null:this.qe.$().Si(t,i.X)},t.prototype.barsInLogicalRange=function(t){if(null===t)return null;var i=new zt(new Et(t.from,t.to)).Hh(),n=this.qe.Hi();if(n.ti())return null;var s=n.oo(i.hh(),1),h=n.oo(i.rh(),-1),r=f(n.eo()),e=f(n.Ui());if(null!==s&&null!==h&&s.Ph>h.Ph)return {barsBefore:t.from-r,barsAfter:e-t.to};var u={barsBefore:null===s||s.Ph===r?t.from-r:s.Ph-r,barsAfter:null===h||h.Ph===e?e-t.to:e-h.Ph};return null!==s&&null!==h&&(u.from=s.S.Sh||s.S.Dh,u.to=h.S.Sh||h.S.Dh),u},t.prototype.setData=function(t){this.qe.Ya(),this.dw.Mw(this.qe,t);},t.prototype.update=function(t){this.qe.Ya(),this.dw.bw(this.qe,t);},t.prototype.setMarkers=function(t){var i=t.map((function(t){return u(u({},t),{time:ts(t.time)})}));this.qe.Wo(i);},t.prototype.applyOptions=function(t){var i=as(t);this.qe.rs(i);},t.prototype.options=function(){return b(this.qe.ct())},t.prototype.priceScale=function(){return this.ww.priceScale(this.qe.$().hs())},t.prototype.createPriceLine=function(t){var i=v(b(es),t),n=this.qe.zo(i);return new us(n)},t.prototype.removePriceLine=function(t){this.qe.Po(t._w());},t.prototype.seriesType=function(){return this.qe.Ya()},t}(),ls=function(t){function i(){return null!==t&&t.apply(this,arguments)||this}return e(i,t),i.prototype.applyOptions=function(i){Ct(i),t.prototype.applyOptions.call(this,i);},i}(os),fs={autoScale:!0,mode:0,invertScale:!1,alignLabels:!0,borderVisible:!0,borderColor:"#2B2B43",entireTextOnly:!1,visible:!1,drawTicks:!0,scaleMargins:{bottom:.1,top:.2}},cs={color:"rgba(0, 0, 0, 0)",visible:!1,fontSize:48,fontFamily:qt,fontStyle:"",text:"",horzAlign:"center",vertAlign:"center"},vs={width:0,height:0,layout:{background:{type:"solid",color:"#FFFFFF"},textColor:"#191919",fontSize:11,fontFamily:qt},crosshair:{vertLine:{color:"#758696",width:1,style:3,visible:!0,labelVisible:!0,labelBackgroundColor:"#4c525e"},horzLine:{color:"#758696",width:1,style:3,visible:!0,labelVisible:!0,labelBackgroundColor:"#4c525e"},mode:1},grid:{vertLines:{color:"#D6DCDE",style:0,visible:!0},horzLines:{color:"#D6DCDE",style:0,visible:!0}},overlayPriceScales:u({},fs),leftPriceScale:u(u({},fs),{visible:!1}),rightPriceScale:u(u({},fs),{visible:!0}),timeScale:{rightOffset:0,barSpacing:6,minBarSpacing:.5,fixLeftEdge:!1,fixRightEdge:!1,lockVisibleTimeRangeOnResize:!1,rightBarStaysOnScroll:!1,borderVisible:!0,borderColor:"#2B2B43",visible:!0,timeVisible:!1,secondsVisible:!0,shiftVisibleRangeOnNewBar:!0},watermark:cs,localization:{locale:mn?navigator.language:"",dateFormat:"dd MMM 'yy"},handleScroll:{mouseWheel:!0,pressedMouseMove:!0,horzTouchDrag:!0,vertTouchDrag:!0},handleScale:{axisPressedMouseMove:{time:!0,price:!0},axisDoubleClickReset:!0,mouseWheel:!0,pinch:!0},kineticScroll:{mouse:!1,touch:!0}},_s={upColor:"#26a69a",downColor:"#ef5350",wickVisible:!0,borderVisible:!0,borderColor:"#378658",borderUpColor:"#26a69a",borderDownColor:"#ef5350",wickColor:"#737375",wickUpColor:"#26a69a",wickDownColor:"#ef5350"},ds={upColor:"#26a69a",downColor:"#ef5350",openVisible:!0,thinBars:!0},ws={color:"#2196f3",lineStyle:0,lineWidth:3,lineType:0,crosshairMarkerVisible:!0,crosshairMarkerRadius:4,crosshairMarkerBorderColor:"",crosshairMarkerBackgroundColor:"",lastPriceAnimation:0},Ms={topColor:"rgba( 46, 220, 135, 0.4)",bottomColor:"rgba( 40, 221, 100, 0)",lineColor:"#33D778",lineStyle:0,lineWidth:3,lineType:0,crosshairMarkerVisible:!0,crosshairMarkerRadius:4,crosshairMarkerBorderColor:"",crosshairMarkerBackgroundColor:"",lastPriceAnimation:0},bs={baseValue:{type:"price",price:0},topFillColor1:"rgba(38, 166, 154, 0.28)",topFillColor2:"rgba(38, 166, 154, 0.05)",topLineColor:"rgba(38, 166, 154, 1)",bottomFillColor1:"rgba(239, 83, 80, 0.05)",bottomFillColor2:"rgba(239, 83, 80, 0.28)",bottomLineColor:"rgba(239, 83, 80, 1)",lineWidth:3,lineStyle:0,crosshairMarkerVisible:!0,crosshairMarkerRadius:4,crosshairMarkerBorderColor:"",crosshairMarkerBackgroundColor:"",lastPriceAnimation:0},ms={color:"#26a69a",base:0},ps={title:"",visible:!0,lastValueVisible:!0,priceLineVisible:!0,priceLineSource:0,priceLineWidth:1,priceLineColor:"",priceLineStyle:2,baseLineVisible:!0,baseLineWidth:1,baseLineColor:"#B2B5BE",baseLineStyle:0,priceFormat:{type:"price",precision:2,minMove:.01}},gs=function(){function t(t,i){this.mw=t,this.pw=i;}return t.prototype.applyOptions=function(t){this.mw.vt()._f(this.pw,t);},t.prototype.options=function(){return this.Gt().ct()},t.prototype.width=function(){return Yt(this.pw)?this.mw.Id("left"===this.pw?"left":"right"):0},t.prototype.Gt=function(){return f(this.mw.vt().df(this.pw)).$},t}(),ys=function(){function t(t,i){this.gw=new it,this.nr=new it,this.sd=new it,this.hi=t,this.ul=t.j(),this.Bd=i,this.ul.Xr().Ji(this.yw.bind(this)),this.ul.Zr().Ji(this.kw.bind(this)),this.Bd.fd().Ji(this.Cw.bind(this));}return t.prototype.en=function(){this.ul.Xr().sn(this),this.ul.Zr().sn(this),this.Bd.fd().sn(this),this.gw.en(),this.nr.en(),this.sd.en();},t.prototype.scrollPosition=function(){return this.ul.Pr()},t.prototype.scrollToPosition=function(t,i){i?this.ul.$r(t,1e3):this.hi.Mr(t);},t.prototype.scrollToRealTime=function(){this.ul.Kr();},t.prototype.getVisibleRange=function(){var t,i,n=this.ul.yr();return null===n?null:{from:null!==(t=n.from.Sh)&&void 0!==t?t:n.from.Dh,to:null!==(i=n.to.Sh)&&void 0!==i?i:n.to.Dh}},t.prototype.setVisibleRange=function(t){var i={from:ts(t.from),to:ts(t.to)},n=this.ul.Sr(i);this.hi.Wf(n);},t.prototype.getVisibleLogicalRange=function(){var t=this.ul.gr();return null===t?null:{from:t.hh(),to:t.rh()}},t.prototype.setVisibleLogicalRange=function(t){o(t.from<=t.to,"The from index cannot be after the to index."),this.hi.Wf(t);},t.prototype.resetTimeScale=function(){this.hi.Ne();},t.prototype.fitContent=function(){this.hi.Qr();},t.prototype.logicalToCoordinate=function(t){var i=this.hi.j();return i.ti()?null:i.G(t)},t.prototype.coordinateToLogical=function(t){return this.ul.ti()?null:this.ul.Fr(t)},t.prototype.timeToCoordinate=function(t){var i=ts(t),n=this.ul.br(i,!1);return null===n?null:this.ul.G(n)},t.prototype.coordinateToTime=function(t){var i,n=this.hi.j(),s=n.Fr(t),h=n.ri(s);return null===h?null:null!==(i=h.Sh)&&void 0!==i?i:h.Dh},t.prototype.width=function(){return this.Bd.z_().st},t.prototype.height=function(){return this.Bd.z_().ht},t.prototype.subscribeVisibleTimeRangeChange=function(t){this.gw.Ji(t);},t.prototype.unsubscribeVisibleTimeRangeChange=function(t){this.gw.nn(t);},t.prototype.subscribeVisibleLogicalRangeChange=function(t){this.nr.Ji(t);},t.prototype.unsubscribeVisibleLogicalRangeChange=function(t){this.nr.nn(t);},t.prototype.subscribeSizeChange=function(t){this.sd.Ji(t);},t.prototype.unsubscribeSizeChange=function(t){this.sd.nn(t);},t.prototype.applyOptions=function(t){this.ul.rs(t);},t.prototype.options=function(){return b(this.ul.ct())},t.prototype.yw=function(){this.gw.rn()&&this.gw.hn(this.getVisibleRange());},t.prototype.kw=function(){this.nr.rn()&&this.nr.hn(this.getVisibleLogicalRange());},t.prototype.Cw=function(t){this.sd.hn(t.st,t.ht);},t}();function ks(t){if(void 0!==t&&"custom"!==t.type){var i=t;void 0!==i.minMove&&void 0===i.precision&&(i.precision=function(t){if(t>=1)return 0;for(var i=0;i<8;i++){var n=Math.round(t);if(Math.abs(n-t)<1e-8)return i;t*=10;}return i}(i.minMove));}}function Cs(t){return function(t){if(M(t.handleScale)){var i=t.handleScale;t.handleScale={axisDoubleClickReset:i,axisPressedMouseMove:{time:i,price:i},mouseWheel:i,pinch:i};}else if(void 0!==t.handleScale&&M(t.handleScale.axisPressedMouseMove)){var n=t.handleScale.axisPressedMouseMove;t.handleScale.axisPressedMouseMove={time:n,price:n};}var s=t.handleScroll;M(s)&&(t.handleScroll={horzTouchDrag:s,vertTouchDrag:s,mouseWheel:s,pressedMouseMove:s});}(t),function(t){if(t.priceScale){t.leftPriceScale=t.leftPriceScale||{},t.rightPriceScale=t.rightPriceScale||{};var i=t.priceScale.position;delete t.priceScale.position,t.leftPriceScale=v(t.leftPriceScale,t.priceScale),t.rightPriceScale=v(t.rightPriceScale,t.priceScale),"left"===i&&(t.leftPriceScale.visible=!0,t.rightPriceScale.visible=!1),"right"===i&&(t.leftPriceScale.visible=!1,t.rightPriceScale.visible=!0),"none"===i&&(t.leftPriceScale.visible=!1,t.rightPriceScale.visible=!1),t.overlayPriceScales=t.overlayPriceScales||{},void 0!==t.priceScale.invertScale&&(t.overlayPriceScales.invertScale=t.priceScale.invertScale),void 0!==t.priceScale.scaleMargins&&(t.overlayPriceScales.scaleMargins=t.priceScale.scaleMargins);}}(t),function(t){t.layout&&t.layout.backgroundColor&&!t.layout.background&&(t.layout.background={type:"solid",color:t.layout.backgroundColor});}(t),t}var Ns=function(){function t(t,i){var n=this;this.Nw=new hs,this.xw=new Map,this.Sw=new Map,this.Dw=new it,this.Aw=new it;var s=void 0===i?b(vs):v(b(vs),Cs(i));this.mw=new zn(t,s),this.mw.V_().Ji((function(t){n.Dw.rn()&&n.Dw.hn(n.Tw(t()));}),this),this.mw.mf().Ji((function(t){n.Aw.rn()&&n.Aw.hn(n.Tw(t()));}),this);var h=this.mw.vt();this.Bw=new ys(h,this.mw.Od());}return t.prototype.remove=function(){this.mw.V_().sn(this),this.mw.mf().sn(this),this.Bw.en(),this.mw.en(),this.xw.clear(),this.Sw.clear(),this.Dw.en(),this.Aw.en(),this.Nw.en();},t.prototype.resize=function(t,i,n){this.mw.Ld(t,i,n);},t.prototype.addAreaSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),Ms,t),n=this.mw.vt().Ef("Area",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addBaselineSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),bs,t),n=this.mw.vt().Ef("Baseline",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addBarSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),ds,t),n=this.mw.vt().Ef("Bar",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addCandlestickSeries=function(t){void 0===t&&(t={}),Ct(t=as(t)),ks(t.priceFormat);var i=v(b(ps),_s,t),n=this.mw.vt().Ef("Candlestick",i),s=new ls(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addHistogramSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),ms,t),n=this.mw.vt().Ef("Histogram",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.addLineSeries=function(t){void 0===t&&(t={}),ks((t=as(t)).priceFormat);var i=v(b(ps),ws,t),n=this.mw.vt().Ef("Line",i),s=new os(n,this,this);return this.xw.set(s,n),this.Sw.set(n,s),s},t.prototype.removeSeries=function(t){var i=l(this.xw.get(t)),n=this.Nw.Of(i);this.mw.vt().Of(i),this.Lw(n),this.xw.delete(t),this.Sw.delete(i);},t.prototype.Mw=function(t,i){this.Lw(this.Nw.nw(t,i));},t.prototype.bw=function(t,i){this.Lw(this.Nw.uw(t,i));},t.prototype.subscribeClick=function(t){this.Dw.Ji(t);},t.prototype.unsubscribeClick=function(t){this.Dw.nn(t);},t.prototype.subscribeCrosshairMove=function(t){this.Aw.Ji(t);},t.prototype.unsubscribeCrosshairMove=function(t){this.Aw.nn(t);},t.prototype.priceScale=function(t){return void 0===t&&(t=this.mw.vt().zf()),new gs(this.mw,t)},t.prototype.timeScale=function(){return this.Bw},t.prototype.applyOptions=function(t){this.mw.rs(Cs(t));},t.prototype.options=function(){return this.mw.ct()},t.prototype.takeScreenshot=function(){return this.mw.zd()},t.prototype.Lw=function(t){var i=this.mw.vt();i.Lf(t.j.Br,t.j.fw,t.j.cw),t.lw.forEach((function(t,i){return i._(t.Zu)})),i.Vr();},t.prototype.Fw=function(t){return l(this.Sw.get(t))},t.prototype.Tw=function(t){var i=this,n=new Map;t.$d.forEach((function(t,s){n.set(i.Fw(s),t);}));var s=void 0===t.Kd?void 0:this.Fw(t.Kd);return {time:t.S&&(t.S.Sh||t.S.Dh),point:t.Yd,hoveredSeries:s,hoveredMarkerId:t.Xd,seriesPrices:n}},t}();function xs(t,i){var n;if(w(t)){var s=document.getElementById(t);o(null!==s,"Cannot find element in DOM with id="+t),n=s;}else n=t;return new Ns(n,i)}

    function ensure(value) {
        if (value === null || value === undefined) {
            throw new Error('no value');
        }
        return value;
    }

    function collection(target, params = [], factory, reference) {
        const collection = new Map();
        for (const current of params) {
            const result = factory(target, current);
            result.updateReference(reference(current));
            collection.set(current.id, result);
        }
        return {
            update(nextParams = []) {
                const existing = new Set(collection.keys());
                const next = new Map(nextParams.map((item) => [item.id, item]));
                for (const id of existing) {
                    if (!next.has(id)) {
                        const entry = ensure(collection.get(id));
                        entry.destroy();
                        collection.delete(id);
                    }
                }
                for (const [id, options] of next.entries()) {
                    const entry = collection.get(id);
                    if (entry === undefined) {
                        const created = factory(target, options);
                        created.updateReference(reference(options));
                        collection.set(id, created);
                    }
                    else {
                        entry.update(options);
                        entry.updateReference(reference(options));
                    }
                }
            },
            destroy() {
                for (const current of collection.values()) {
                    current.destroy();
                }
            }
        };
    }

    function linesCollection(target, params = []) {
        return collection(target, params, line, (p) => p.reference);
    }
    function line(target, params) {
        const subject = target.createPriceLine(params.options);
        let reference;
        return {
            update(nextParams) {
                if (nextParams.options) {
                    subject.applyOptions(nextParams.options);
                }
            },
            updateReference(nextReference) {
                if (nextReference !== reference) {
                    reference === null || reference === void 0 ? void 0 : reference(null);
                    reference = nextReference;
                    reference === null || reference === void 0 ? void 0 : reference(subject);
                }
            },
            destroy() {
                reference === null || reference === void 0 ? void 0 : reference(null);
                target.removePriceLine(subject);
            }
        };
    }

    function seriesCollection(target, params = []) {
        return collection(target, params, series, (p) => p.reference);
    }
    function series(target, params) {
        let subject = createSeries(target, params);
        let reference;
        let lines = linesCollection(subject, params.priceLines);
        return {
            update(nextParams) {
                if (nextParams.type !== subject.seriesType()) {
                    lines.destroy();
                    target.removeSeries(subject);
                    // TODO: where is reference update?
                    subject = createSeries(target, nextParams);
                    lines = linesCollection(subject, params.priceLines);
                    return;
                }
                if (nextParams.options) {
                    subject.applyOptions(nextParams.options);
                }
                lines.update(nextParams.priceLines);
            },
            updateReference(nextReference) {
                if (nextReference !== reference) {
                    reference === null || reference === void 0 ? void 0 : reference(null);
                    reference = nextReference;
                    reference === null || reference === void 0 ? void 0 : reference(subject);
                }
            },
            destroy() {
                reference === null || reference === void 0 ? void 0 : reference(null);
                target.removeSeries(subject);
            }
        };
    }
    function createSeries(chart, params) {
        switch (params.type) {
            case 'Area': {
                const series = chart.addAreaSeries(params.options);
                series.setData(params.data);
                return series;
            }
            case 'Bar': {
                const series = chart.addBarSeries(params.options);
                series.setData(params.data);
                return series;
            }
            case 'Candlestick': {
                const series = chart.addCandlestickSeries(params.options);
                series.setData(params.data);
                return series;
            }
            case 'Histogram': {
                const series = chart.addHistogramSeries(params.options);
                series.setData(params.data);
                return series;
            }
            case 'Line': {
                const series = chart.addLineSeries(params.options);
                series.setData(params.data);
                return series;
            }
        }
    }

    function context(value) {
        if (typeof value !== 'undefined') {
            setContext('lightweight-chart-context', value);
        }
        else {
            return getContext('lightweight-chart-context');
        }
    }
    function useSeriesEffect(callback) {
        let subject = null;
        const api = context();
        onMount(() => {
            const [params] = callback();
            subject = series(api, params);
            return () => {
                subject === null || subject === void 0 ? void 0 : subject.destroy();
                subject = null;
            };
        });
        afterUpdate(() => {
            const [params, ref] = callback();
            subject === null || subject === void 0 ? void 0 : subject.update(params);
            subject === null || subject === void 0 ? void 0 : subject.updateReference(ref);
        });
    }

    /* node_modules\svelte-lightweight-charts\components\internal\context-provider.svelte generated by Svelte v3.46.3 */

    function create_fragment$h(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Context_provider', slots, ['default']);
    	let { value } = $$props;
    	const writable_props = ['value'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Context_provider> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ context, value });

    	$$self.$inject_state = $$props => {
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 1) {
    			context(value);
    		}
    	};

    	return [value, $$scope, slots];
    }

    class Context_provider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { value: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Context_provider",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !('value' in props)) {
    			console.warn("<Context_provider> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<Context_provider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Context_provider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function chart(node, params) {
        var _a, _b;
        let { options, reference, onClick, onCrosshairMove, } = params;
        let width = (_a = options === null || options === void 0 ? void 0 : options.width) !== null && _a !== void 0 ? _a : 0;
        let height = (_b = options === null || options === void 0 ? void 0 : options.height) !== null && _b !== void 0 ? _b : 0;
        const chart = xs(node, options);
        reference === null || reference === void 0 ? void 0 : reference(chart);
        const series = seriesCollection(chart, params.series);
        if (onClick) {
            chart.subscribeClick(onClick);
        }
        if (onCrosshairMove) {
            chart.subscribeCrosshairMove(onCrosshairMove);
        }
        return {
            update(nextParams) {
                var _a, _b;
                const { options: nextOptions, reference: nextReference, onClick: nextOnClick, onCrosshairMove: nextOnCrosshairMove, } = nextParams;
                if (nextReference !== reference) {
                    reference === null || reference === void 0 ? void 0 : reference(null);
                    reference = nextReference;
                    reference === null || reference === void 0 ? void 0 : reference(chart);
                }
                if (nextOptions) {
                    chart.applyOptions(nextOptions);
                    if (nextOptions.width !== undefined && nextOptions.width !== width
                        || nextOptions.height !== undefined && nextOptions.height !== height) {
                        width = (_a = nextOptions.width) !== null && _a !== void 0 ? _a : width;
                        height = (_b = nextOptions.height) !== null && _b !== void 0 ? _b : height;
                        chart.resize(width, height, true);
                    }
                    options = nextOptions;
                }
                series.update(nextParams.series);
                if (nextOnClick !== onClick) {
                    if (onClick) {
                        chart.unsubscribeCrosshairMove(onClick);
                    }
                    onClick = nextOnClick;
                    if (onClick) {
                        chart.subscribeCrosshairMove(onClick);
                    }
                }
                if (nextOnCrosshairMove !== onCrosshairMove) {
                    if (onCrosshairMove) {
                        chart.unsubscribeCrosshairMove(onCrosshairMove);
                    }
                    onCrosshairMove = nextOnCrosshairMove;
                    if (onCrosshairMove) {
                        chart.subscribeCrosshairMove(onCrosshairMove);
                    }
                }
            },
            destroy() {
                series.destroy();
                if (onClick) {
                    chart.unsubscribeCrosshairMove(onClick);
                }
                if (onCrosshairMove) {
                    chart.unsubscribeCrosshairMove(onCrosshairMove);
                }
                chart.remove();
                reference === null || reference === void 0 ? void 0 : reference(null);
            }
        };
    }

    /* node_modules\svelte-lightweight-charts\components\chart.svelte generated by Svelte v3.46.3 */
    const file$f = "node_modules\\svelte-lightweight-charts\\components\\chart.svelte";

    // (75:4) {#if reference !== null}
    function create_if_block$9(ctx) {
    	let contextprovider;
    	let current;

    	contextprovider = new Context_provider({
    			props: {
    				value: /*reference*/ ctx[1],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contextprovider.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contextprovider, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contextprovider_changes = {};
    			if (dirty & /*reference*/ 2) contextprovider_changes.value = /*reference*/ ctx[1];

    			if (dirty & /*$$scope*/ 1048576) {
    				contextprovider_changes.$$scope = { dirty, ctx };
    			}

    			contextprovider.$set(contextprovider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contextprovider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contextprovider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contextprovider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(75:4) {#if reference !== null}",
    		ctx
    	});

    	return block;
    }

    // (76:8) <ContextProvider value={reference}>
    function create_default_slot$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[20],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(76:8) <ContextProvider value={reference}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div;
    	let chart_action;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*reference*/ ctx[1] !== null && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(div, file$f, 68, 0, 1984);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(chart_action = chart.call(null, div, {
    					options: /*options*/ ctx[0],
    					onCrosshairMove: /*handleCrosshairMove*/ ctx[3],
    					onClick: /*handleClick*/ ctx[4],
    					reference: /*handleReference*/ ctx[2]
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*reference*/ ctx[1] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*reference*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (chart_action && is_function(chart_action.update) && dirty & /*options, handleReference*/ 5) chart_action.update.call(null, {
    				options: /*options*/ ctx[0],
    				onCrosshairMove: /*handleCrosshairMove*/ ctx[3],
    				onClick: /*handleClick*/ ctx[4],
    				reference: /*handleReference*/ ctx[2]
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Chart', slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { width = 0 } = $$props;
    	let { height = 0 } = $$props;
    	let { watermark = undefined } = $$props;
    	let { layout = undefined } = $$props;
    	let { leftPriceScale = undefined } = $$props;
    	let { rightPriceScale = undefined } = $$props;
    	let { overlayPriceScales = undefined } = $$props;
    	let { timeScale = undefined } = $$props;
    	let { crosshair = undefined } = $$props;
    	let { grid = undefined } = $$props;
    	let { localization = undefined } = $$props;
    	let { handleScroll = undefined } = $$props;
    	let { handleScale = undefined } = $$props;
    	let { ref = undefined } = $$props;
    	let options = undefined;
    	let reference = null;
    	let handleReference = undefined;

    	function handleCrosshairMove(params) {
    		dispatch('crosshairMove', params);
    	}

    	function handleClick(params) {
    		dispatch('click', params);
    	}

    	const writable_props = [
    		'width',
    		'height',
    		'watermark',
    		'layout',
    		'leftPriceScale',
    		'rightPriceScale',
    		'overlayPriceScales',
    		'timeScale',
    		'crosshair',
    		'grid',
    		'localization',
    		'handleScroll',
    		'handleScale',
    		'ref'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Chart> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('width' in $$props) $$invalidate(5, width = $$props.width);
    		if ('height' in $$props) $$invalidate(6, height = $$props.height);
    		if ('watermark' in $$props) $$invalidate(7, watermark = $$props.watermark);
    		if ('layout' in $$props) $$invalidate(8, layout = $$props.layout);
    		if ('leftPriceScale' in $$props) $$invalidate(9, leftPriceScale = $$props.leftPriceScale);
    		if ('rightPriceScale' in $$props) $$invalidate(10, rightPriceScale = $$props.rightPriceScale);
    		if ('overlayPriceScales' in $$props) $$invalidate(11, overlayPriceScales = $$props.overlayPriceScales);
    		if ('timeScale' in $$props) $$invalidate(12, timeScale = $$props.timeScale);
    		if ('crosshair' in $$props) $$invalidate(13, crosshair = $$props.crosshair);
    		if ('grid' in $$props) $$invalidate(14, grid = $$props.grid);
    		if ('localization' in $$props) $$invalidate(15, localization = $$props.localization);
    		if ('handleScroll' in $$props) $$invalidate(16, handleScroll = $$props.handleScroll);
    		if ('handleScale' in $$props) $$invalidate(17, handleScale = $$props.handleScale);
    		if ('ref' in $$props) $$invalidate(18, ref = $$props.ref);
    		if ('$$scope' in $$props) $$invalidate(20, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		ContextProvider: Context_provider,
    		chart,
    		dispatch,
    		width,
    		height,
    		watermark,
    		layout,
    		leftPriceScale,
    		rightPriceScale,
    		overlayPriceScales,
    		timeScale,
    		crosshair,
    		grid,
    		localization,
    		handleScroll,
    		handleScale,
    		ref,
    		options,
    		reference,
    		handleReference,
    		handleCrosshairMove,
    		handleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ('width' in $$props) $$invalidate(5, width = $$props.width);
    		if ('height' in $$props) $$invalidate(6, height = $$props.height);
    		if ('watermark' in $$props) $$invalidate(7, watermark = $$props.watermark);
    		if ('layout' in $$props) $$invalidate(8, layout = $$props.layout);
    		if ('leftPriceScale' in $$props) $$invalidate(9, leftPriceScale = $$props.leftPriceScale);
    		if ('rightPriceScale' in $$props) $$invalidate(10, rightPriceScale = $$props.rightPriceScale);
    		if ('overlayPriceScales' in $$props) $$invalidate(11, overlayPriceScales = $$props.overlayPriceScales);
    		if ('timeScale' in $$props) $$invalidate(12, timeScale = $$props.timeScale);
    		if ('crosshair' in $$props) $$invalidate(13, crosshair = $$props.crosshair);
    		if ('grid' in $$props) $$invalidate(14, grid = $$props.grid);
    		if ('localization' in $$props) $$invalidate(15, localization = $$props.localization);
    		if ('handleScroll' in $$props) $$invalidate(16, handleScroll = $$props.handleScroll);
    		if ('handleScale' in $$props) $$invalidate(17, handleScale = $$props.handleScale);
    		if ('ref' in $$props) $$invalidate(18, ref = $$props.ref);
    		if ('options' in $$props) $$invalidate(0, options = $$props.options);
    		if ('reference' in $$props) $$invalidate(1, reference = $$props.reference);
    		if ('handleReference' in $$props) $$invalidate(2, handleReference = $$props.handleReference);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*width, height, watermark, layout, leftPriceScale, rightPriceScale, overlayPriceScales, timeScale, crosshair, grid, localization, handleScroll, handleScale*/ 262112) {
    			$$invalidate(0, options = {
    				width,
    				height,
    				watermark,
    				layout,
    				leftPriceScale,
    				rightPriceScale,
    				overlayPriceScales,
    				timeScale,
    				crosshair,
    				grid,
    				localization,
    				handleScroll,
    				handleScale
    			});
    		}

    		if ($$self.$$.dirty & /*ref*/ 262144) {
    			$$invalidate(2, handleReference = chart => {
    				$$invalidate(1, reference = chart);

    				if (ref !== undefined) {
    					ref(chart);
    				}
    			});
    		}
    	};

    	return [
    		options,
    		reference,
    		handleReference,
    		handleCrosshairMove,
    		handleClick,
    		width,
    		height,
    		watermark,
    		layout,
    		leftPriceScale,
    		rightPriceScale,
    		overlayPriceScales,
    		timeScale,
    		crosshair,
    		grid,
    		localization,
    		handleScroll,
    		handleScale,
    		ref,
    		slots,
    		$$scope
    	];
    }

    class Chart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, not_equal, {
    			width: 5,
    			height: 6,
    			watermark: 7,
    			layout: 8,
    			leftPriceScale: 9,
    			rightPriceScale: 10,
    			overlayPriceScales: 11,
    			timeScale: 12,
    			crosshair: 13,
    			grid: 14,
    			localization: 15,
    			handleScroll: 16,
    			handleScale: 17,
    			ref: 18
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Chart",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get width() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get watermark() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set watermark(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layout(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get leftPriceScale() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set leftPriceScale(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rightPriceScale() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rightPriceScale(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get overlayPriceScales() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set overlayPriceScales(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get timeScale() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set timeScale(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get crosshair() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set crosshair(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grid() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grid(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get localization() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set localization(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleScroll() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set handleScroll(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleScale() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set handleScale(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<Chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<Chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-lightweight-charts\components\line-series.svelte generated by Svelte v3.46.3 */

    // (95:0) {#if reference !== null}
    function create_if_block$8(ctx) {
    	let contextprovider;
    	let current;

    	contextprovider = new Context_provider({
    			props: {
    				value: /*reference*/ ctx[0],
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(contextprovider.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contextprovider, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const contextprovider_changes = {};
    			if (dirty[0] & /*reference*/ 1) contextprovider_changes.value = /*reference*/ ctx[0];

    			if (dirty[0] & /*$$scope*/ 268435456) {
    				contextprovider_changes.$$scope = { dirty, ctx };
    			}

    			contextprovider.$set(contextprovider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contextprovider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contextprovider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contextprovider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(95:0) {#if reference !== null}",
    		ctx
    	});

    	return block;
    }

    // (96:4) <ContextProvider value={reference}>
    function create_default_slot$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[27].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[28],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[28])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(96:4) <ContextProvider value={reference}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*reference*/ ctx[0] !== null && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*reference*/ ctx[0] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*reference*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Line_series', slots, ['default']);
    	let { lastValueVisible = undefined } = $$props;
    	let { title = undefined } = $$props;
    	let { priceScaleId = undefined } = $$props;
    	let { visible = undefined } = $$props;
    	let { priceLineVisible = undefined } = $$props;
    	let { priceLineSource = undefined } = $$props;
    	let { priceLineWidth = undefined } = $$props;
    	let { priceLineColor = undefined } = $$props;
    	let { priceLineStyle = undefined } = $$props;
    	let { priceFormat = undefined } = $$props;
    	let { baseLineVisible = undefined } = $$props;
    	let { baseLineColor = undefined } = $$props;
    	let { baseLineWidth = undefined } = $$props;
    	let { baseLineStyle = undefined } = $$props;
    	let { autoscaleInfoProvider = undefined } = $$props;
    	let { scaleMargins = undefined } = $$props;
    	let { color = undefined } = $$props;
    	let { lineStyle = undefined } = $$props;
    	let { lineWidth = undefined } = $$props;
    	let { lineType = undefined } = $$props;
    	let { crosshairMarkerVisible = undefined } = $$props;
    	let { crosshairMarkerRadius = undefined } = $$props;
    	let { crosshairMarkerBorderColor = undefined } = $$props;
    	let { crosshairMarkerBackgroundColor = undefined } = $$props;
    	let { ref = undefined } = $$props;
    	let { data = [] } = $$props;
    	let options;
    	let reference = null;
    	let handleReference = undefined;
    	const id = performance.now().toString();
    	useSeriesEffect(() => [{ id, type: 'Line', options, data }, handleReference]);

    	const writable_props = [
    		'lastValueVisible',
    		'title',
    		'priceScaleId',
    		'visible',
    		'priceLineVisible',
    		'priceLineSource',
    		'priceLineWidth',
    		'priceLineColor',
    		'priceLineStyle',
    		'priceFormat',
    		'baseLineVisible',
    		'baseLineColor',
    		'baseLineWidth',
    		'baseLineStyle',
    		'autoscaleInfoProvider',
    		'scaleMargins',
    		'color',
    		'lineStyle',
    		'lineWidth',
    		'lineType',
    		'crosshairMarkerVisible',
    		'crosshairMarkerRadius',
    		'crosshairMarkerBorderColor',
    		'crosshairMarkerBackgroundColor',
    		'ref',
    		'data'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Line_series> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('lastValueVisible' in $$props) $$invalidate(1, lastValueVisible = $$props.lastValueVisible);
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('priceScaleId' in $$props) $$invalidate(3, priceScaleId = $$props.priceScaleId);
    		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
    		if ('priceLineVisible' in $$props) $$invalidate(5, priceLineVisible = $$props.priceLineVisible);
    		if ('priceLineSource' in $$props) $$invalidate(6, priceLineSource = $$props.priceLineSource);
    		if ('priceLineWidth' in $$props) $$invalidate(7, priceLineWidth = $$props.priceLineWidth);
    		if ('priceLineColor' in $$props) $$invalidate(8, priceLineColor = $$props.priceLineColor);
    		if ('priceLineStyle' in $$props) $$invalidate(9, priceLineStyle = $$props.priceLineStyle);
    		if ('priceFormat' in $$props) $$invalidate(10, priceFormat = $$props.priceFormat);
    		if ('baseLineVisible' in $$props) $$invalidate(11, baseLineVisible = $$props.baseLineVisible);
    		if ('baseLineColor' in $$props) $$invalidate(12, baseLineColor = $$props.baseLineColor);
    		if ('baseLineWidth' in $$props) $$invalidate(13, baseLineWidth = $$props.baseLineWidth);
    		if ('baseLineStyle' in $$props) $$invalidate(14, baseLineStyle = $$props.baseLineStyle);
    		if ('autoscaleInfoProvider' in $$props) $$invalidate(15, autoscaleInfoProvider = $$props.autoscaleInfoProvider);
    		if ('scaleMargins' in $$props) $$invalidate(16, scaleMargins = $$props.scaleMargins);
    		if ('color' in $$props) $$invalidate(17, color = $$props.color);
    		if ('lineStyle' in $$props) $$invalidate(18, lineStyle = $$props.lineStyle);
    		if ('lineWidth' in $$props) $$invalidate(19, lineWidth = $$props.lineWidth);
    		if ('lineType' in $$props) $$invalidate(20, lineType = $$props.lineType);
    		if ('crosshairMarkerVisible' in $$props) $$invalidate(21, crosshairMarkerVisible = $$props.crosshairMarkerVisible);
    		if ('crosshairMarkerRadius' in $$props) $$invalidate(22, crosshairMarkerRadius = $$props.crosshairMarkerRadius);
    		if ('crosshairMarkerBorderColor' in $$props) $$invalidate(23, crosshairMarkerBorderColor = $$props.crosshairMarkerBorderColor);
    		if ('crosshairMarkerBackgroundColor' in $$props) $$invalidate(24, crosshairMarkerBackgroundColor = $$props.crosshairMarkerBackgroundColor);
    		if ('ref' in $$props) $$invalidate(25, ref = $$props.ref);
    		if ('data' in $$props) $$invalidate(26, data = $$props.data);
    		if ('$$scope' in $$props) $$invalidate(28, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ContextProvider: Context_provider,
    		useSeriesEffect,
    		lastValueVisible,
    		title,
    		priceScaleId,
    		visible,
    		priceLineVisible,
    		priceLineSource,
    		priceLineWidth,
    		priceLineColor,
    		priceLineStyle,
    		priceFormat,
    		baseLineVisible,
    		baseLineColor,
    		baseLineWidth,
    		baseLineStyle,
    		autoscaleInfoProvider,
    		scaleMargins,
    		color,
    		lineStyle,
    		lineWidth,
    		lineType,
    		crosshairMarkerVisible,
    		crosshairMarkerRadius,
    		crosshairMarkerBorderColor,
    		crosshairMarkerBackgroundColor,
    		ref,
    		data,
    		options,
    		reference,
    		handleReference,
    		id
    	});

    	$$self.$inject_state = $$props => {
    		if ('lastValueVisible' in $$props) $$invalidate(1, lastValueVisible = $$props.lastValueVisible);
    		if ('title' in $$props) $$invalidate(2, title = $$props.title);
    		if ('priceScaleId' in $$props) $$invalidate(3, priceScaleId = $$props.priceScaleId);
    		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
    		if ('priceLineVisible' in $$props) $$invalidate(5, priceLineVisible = $$props.priceLineVisible);
    		if ('priceLineSource' in $$props) $$invalidate(6, priceLineSource = $$props.priceLineSource);
    		if ('priceLineWidth' in $$props) $$invalidate(7, priceLineWidth = $$props.priceLineWidth);
    		if ('priceLineColor' in $$props) $$invalidate(8, priceLineColor = $$props.priceLineColor);
    		if ('priceLineStyle' in $$props) $$invalidate(9, priceLineStyle = $$props.priceLineStyle);
    		if ('priceFormat' in $$props) $$invalidate(10, priceFormat = $$props.priceFormat);
    		if ('baseLineVisible' in $$props) $$invalidate(11, baseLineVisible = $$props.baseLineVisible);
    		if ('baseLineColor' in $$props) $$invalidate(12, baseLineColor = $$props.baseLineColor);
    		if ('baseLineWidth' in $$props) $$invalidate(13, baseLineWidth = $$props.baseLineWidth);
    		if ('baseLineStyle' in $$props) $$invalidate(14, baseLineStyle = $$props.baseLineStyle);
    		if ('autoscaleInfoProvider' in $$props) $$invalidate(15, autoscaleInfoProvider = $$props.autoscaleInfoProvider);
    		if ('scaleMargins' in $$props) $$invalidate(16, scaleMargins = $$props.scaleMargins);
    		if ('color' in $$props) $$invalidate(17, color = $$props.color);
    		if ('lineStyle' in $$props) $$invalidate(18, lineStyle = $$props.lineStyle);
    		if ('lineWidth' in $$props) $$invalidate(19, lineWidth = $$props.lineWidth);
    		if ('lineType' in $$props) $$invalidate(20, lineType = $$props.lineType);
    		if ('crosshairMarkerVisible' in $$props) $$invalidate(21, crosshairMarkerVisible = $$props.crosshairMarkerVisible);
    		if ('crosshairMarkerRadius' in $$props) $$invalidate(22, crosshairMarkerRadius = $$props.crosshairMarkerRadius);
    		if ('crosshairMarkerBorderColor' in $$props) $$invalidate(23, crosshairMarkerBorderColor = $$props.crosshairMarkerBorderColor);
    		if ('crosshairMarkerBackgroundColor' in $$props) $$invalidate(24, crosshairMarkerBackgroundColor = $$props.crosshairMarkerBackgroundColor);
    		if ('ref' in $$props) $$invalidate(25, ref = $$props.ref);
    		if ('data' in $$props) $$invalidate(26, data = $$props.data);
    		if ('options' in $$props) options = $$props.options;
    		if ('reference' in $$props) $$invalidate(0, reference = $$props.reference);
    		if ('handleReference' in $$props) handleReference = $$props.handleReference;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*lastValueVisible, title, priceScaleId, visible, priceLineVisible, priceLineSource, priceLineWidth, priceLineColor, priceLineStyle, priceFormat, baseLineVisible, baseLineColor, baseLineWidth, baseLineStyle, autoscaleInfoProvider, scaleMargins, color, lineStyle, lineWidth, lineType, crosshairMarkerBackgroundColor, crosshairMarkerBorderColor, crosshairMarkerRadius, crosshairMarkerVisible*/ 33554430) {
    			options = {
    				lastValueVisible,
    				title,
    				priceScaleId,
    				visible,
    				priceLineVisible,
    				priceLineSource,
    				priceLineWidth,
    				priceLineColor,
    				priceLineStyle,
    				priceFormat,
    				baseLineVisible,
    				baseLineColor,
    				baseLineWidth,
    				baseLineStyle,
    				autoscaleInfoProvider,
    				scaleMargins,
    				color,
    				lineStyle,
    				lineWidth,
    				lineType,
    				crosshairMarkerBackgroundColor,
    				crosshairMarkerBorderColor,
    				crosshairMarkerRadius,
    				crosshairMarkerVisible
    			};
    		}

    		if ($$self.$$.dirty[0] & /*ref*/ 33554432) {
    			handleReference = series => {
    				$$invalidate(0, reference = series);

    				if (ref !== undefined) {
    					ref(series);
    				}
    			};
    		}
    	};

    	return [
    		reference,
    		lastValueVisible,
    		title,
    		priceScaleId,
    		visible,
    		priceLineVisible,
    		priceLineSource,
    		priceLineWidth,
    		priceLineColor,
    		priceLineStyle,
    		priceFormat,
    		baseLineVisible,
    		baseLineColor,
    		baseLineWidth,
    		baseLineStyle,
    		autoscaleInfoProvider,
    		scaleMargins,
    		color,
    		lineStyle,
    		lineWidth,
    		lineType,
    		crosshairMarkerVisible,
    		crosshairMarkerRadius,
    		crosshairMarkerBorderColor,
    		crosshairMarkerBackgroundColor,
    		ref,
    		data,
    		slots,
    		$$scope
    	];
    }

    class Line_series extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$f,
    			create_fragment$f,
    			not_equal,
    			{
    				lastValueVisible: 1,
    				title: 2,
    				priceScaleId: 3,
    				visible: 4,
    				priceLineVisible: 5,
    				priceLineSource: 6,
    				priceLineWidth: 7,
    				priceLineColor: 8,
    				priceLineStyle: 9,
    				priceFormat: 10,
    				baseLineVisible: 11,
    				baseLineColor: 12,
    				baseLineWidth: 13,
    				baseLineStyle: 14,
    				autoscaleInfoProvider: 15,
    				scaleMargins: 16,
    				color: 17,
    				lineStyle: 18,
    				lineWidth: 19,
    				lineType: 20,
    				crosshairMarkerVisible: 21,
    				crosshairMarkerRadius: 22,
    				crosshairMarkerBorderColor: 23,
    				crosshairMarkerBackgroundColor: 24,
    				ref: 25,
    				data: 26
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Line_series",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get lastValueVisible() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lastValueVisible(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceScaleId() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceScaleId(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceLineVisible() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceLineVisible(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceLineSource() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceLineSource(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceLineWidth() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceLineWidth(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceLineColor() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceLineColor(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceLineStyle() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceLineStyle(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceFormat() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceFormat(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineVisible() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineVisible(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineColor() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineColor(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineWidth() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineWidth(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseLineStyle() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseLineStyle(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoscaleInfoProvider() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoscaleInfoProvider(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scaleMargins() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scaleMargins(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineStyle() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineStyle(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineWidth() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineWidth(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineType() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineType(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get crosshairMarkerVisible() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set crosshairMarkerVisible(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get crosshairMarkerRadius() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set crosshairMarkerRadius(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get crosshairMarkerBorderColor() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set crosshairMarkerBorderColor(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get crosshairMarkerBackgroundColor() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set crosshairMarkerBackgroundColor(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<Line_series>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Line_series>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Trade-chart.svelte generated by Svelte v3.46.3 */

    const file$e = "src\\components\\Trade-chart.svelte";

    // (73:0) {#if tradeData && tradeData.length}
    function create_if_block$7(ctx) {
    	let previous_key = /*tradeData*/ ctx[2];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tradeData*/ 4 && safe_not_equal(previous_key, previous_key = /*tradeData*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(73:0) {#if tradeData && tradeData.length}",
    		ctx
    	});

    	return block;
    }

    // (76:12) <Chart {...options}>
    function create_default_slot$1(ctx) {
    	let lineseries;
    	let current;
    	const lineseries_spread_levels = [/*lineOptions*/ ctx[3], { data: /*tradeData*/ ctx[2] }];
    	let lineseries_props = {};

    	for (let i = 0; i < lineseries_spread_levels.length; i += 1) {
    		lineseries_props = assign(lineseries_props, lineseries_spread_levels[i]);
    	}

    	lineseries = new Line_series({ props: lineseries_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(lineseries.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lineseries, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lineseries_changes = (dirty & /*lineOptions, tradeData*/ 12)
    			? get_spread_update(lineseries_spread_levels, [
    					dirty & /*lineOptions*/ 8 && get_spread_object(/*lineOptions*/ ctx[3]),
    					dirty & /*tradeData*/ 4 && { data: /*tradeData*/ ctx[2] }
    				])
    			: {};

    			lineseries.$set(lineseries_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lineseries.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lineseries.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lineseries, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(76:12) <Chart {...options}>",
    		ctx
    	});

    	return block;
    }

    // (74:4) {#key tradeData}
    function create_key_block(ctx) {
    	let div1;
    	let chart;
    	let t0;
    	let div0;
    	let t1;
    	let current;
    	const chart_spread_levels = [/*options*/ ctx[1]];

    	let chart_props = {
    		$$slots: { default: [create_default_slot$1] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < chart_spread_levels.length; i += 1) {
    		chart_props = assign(chart_props, chart_spread_levels[i]);
    	}

    	chart = new Chart({ props: chart_props, $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(chart.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			t1 = text(/*quotePair*/ ctx[0]);
    			attr_dev(div0, "class", "legend svelte-1uj9tp0");
    			add_location(div0, file$e, 79, 12, 2354);
    			attr_dev(div1, "class", "trade-chart-wrapper svelte-1uj9tp0");
    			add_location(div1, file$e, 74, 8, 2164);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(chart, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chart_changes = (dirty & /*options*/ 2)
    			? get_spread_update(chart_spread_levels, [get_spread_object(/*options*/ ctx[1])])
    			: {};

    			if (dirty & /*$$scope, tradeData*/ 1028) {
    				chart_changes.$$scope = { dirty, ctx };
    			}

    			chart.$set(chart_changes);
    			if (!current || dirty & /*quotePair*/ 1) set_data_dev(t1, /*quotePair*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(chart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(74:4) {#key tradeData}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*tradeData*/ ctx[2] && /*tradeData*/ ctx[2].length && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*tradeData*/ ctx[2] && /*tradeData*/ ctx[2].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*tradeData*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let trades;
    	let tradeData;
    	let options;
    	let $shipTrades;
    	validate_store(shipTrades, 'shipTrades');
    	component_subscribe($$self, shipTrades, $$value => $$invalidate(8, $shipTrades = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Trade_chart', slots, []);

    	const baseOptions = {
    		width: 280,
    		height: 280,
    		layout: {
    			backgroundColor: '#faf9f8',
    			textColor: 'rgba(80, 80, 80, 1)'
    		},
    		crosshair: { mode: j.Normal },
    		rightPriceScale: { borderColor: 'rgba(197, 203, 206, 1)' },
    		timeScale: {
    			borderColor: 'rgba(197, 203, 206, 1)',
    			barSpacing: 4,
    			rightOffset: 1,
    			timeVisible: true
    		}
    	};

    	const lineOptions = { color: 'rgb(230, 120, 0)', lineWidth: 2 };
    	let { ship } = $$props;
    	let { quotePair } = $$props;
    	let { width = 280 } = $$props;
    	let { height = 280 } = $$props;
    	const writable_props = ['ship', 'quotePair', 'width', 'height'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Trade_chart> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ship' in $$props) $$invalidate(4, ship = $$props.ship);
    		if ('quotePair' in $$props) $$invalidate(0, quotePair = $$props.quotePair);
    		if ('width' in $$props) $$invalidate(5, width = $$props.width);
    		if ('height' in $$props) $$invalidate(6, height = $$props.height);
    	};

    	$$self.$capture_state = () => ({
    		_cloneDeep: cloneDeep_1,
    		CrosshairMode: j,
    		Chart,
    		LineSeries: Line_series,
    		shipTrades,
    		baseOptions,
    		lineOptions,
    		ship,
    		quotePair,
    		width,
    		height,
    		options,
    		trades,
    		tradeData,
    		$shipTrades
    	});

    	$$self.$inject_state = $$props => {
    		if ('ship' in $$props) $$invalidate(4, ship = $$props.ship);
    		if ('quotePair' in $$props) $$invalidate(0, quotePair = $$props.quotePair);
    		if ('width' in $$props) $$invalidate(5, width = $$props.width);
    		if ('height' in $$props) $$invalidate(6, height = $$props.height);
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('trades' in $$props) $$invalidate(7, trades = $$props.trades);
    		if ('tradeData' in $$props) $$invalidate(2, tradeData = $$props.tradeData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$shipTrades, ship*/ 272) {
    			$$invalidate(7, trades = $shipTrades[ship.id]);
    		}

    		if ($$self.$$.dirty & /*trades, quotePair*/ 129) {
    			$$invalidate(2, tradeData = trades ? cloneDeep_1(trades[quotePair]) : []);
    		}

    		if ($$self.$$.dirty & /*width, height*/ 96) {
    			$$invalidate(1, options = { ...baseOptions, width, height });
    		}
    	};

    	return [
    		quotePair,
    		options,
    		tradeData,
    		lineOptions,
    		ship,
    		width,
    		height,
    		trades,
    		$shipTrades
    	];
    }

    class Trade_chart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			ship: 4,
    			quotePair: 0,
    			width: 5,
    			height: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Trade_chart",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ship*/ ctx[4] === undefined && !('ship' in props)) {
    			console.warn("<Trade_chart> was created without expected prop 'ship'");
    		}

    		if (/*quotePair*/ ctx[0] === undefined && !('quotePair' in props)) {
    			console.warn("<Trade_chart> was created without expected prop 'quotePair'");
    		}
    	}

    	get ship() {
    		throw new Error("<Trade_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ship(value) {
    		throw new Error("<Trade_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quotePair() {
    		throw new Error("<Trade_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quotePair(value) {
    		throw new Error("<Trade_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Trade_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Trade_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Trade_chart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Trade_chart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\percent-display.svelte generated by Svelte v3.46.3 */

    const file$d = "src\\components\\percent-display.svelte";

    function create_fragment$d(ctx) {
    	let div;
    	let span0;
    	let t0;
    	let t1;
    	let span1;
    	let t2;
    	let t3;
    	let span2;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			t0 = text(/*sign*/ ctx[2]);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*displayNum*/ ctx[1]);
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "%";
    			attr_dev(span0, "class", "sign svelte-1qbm6mv");
    			add_location(span0, file$d, 13, 4, 461);
    			attr_dev(span1, "class", "number svelte-1qbm6mv");
    			add_location(span1, file$d, 14, 4, 499);
    			attr_dev(span2, "class", "percent-mark svelte-1qbm6mv");
    			add_location(span2, file$d, 15, 4, 545);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*workingClass*/ ctx[4] + /*percentClass*/ ctx[3]) + " svelte-1qbm6mv"));
    			attr_dev(div, "style", /*style*/ ctx[0]);
    			add_location(div, file$d, 12, 0, 400);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(span0, t0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			append_dev(div, span2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sign*/ 4) set_data_dev(t0, /*sign*/ ctx[2]);
    			if (dirty & /*displayNum*/ 2) set_data_dev(t2, /*displayNum*/ ctx[1]);

    			if (dirty & /*workingClass, percentClass*/ 24 && div_class_value !== (div_class_value = "" + (null_to_empty(/*workingClass*/ ctx[4] + /*percentClass*/ ctx[3]) + " svelte-1qbm6mv"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*style*/ 1) {
    				attr_dev(div, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let workingClass;
    	let percentClass;
    	let sign;
    	let displayNum;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Percent_display', slots, []);
    	let { num = 0 } = $$props;
    	let { decimals = 1 } = $$props;
    	let { style = '' } = $$props;
    	let { className = '' } = $$props;
    	const writable_props = ['num', 'decimals', 'style', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Percent_display> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('num' in $$props) $$invalidate(5, num = $$props.num);
    		if ('decimals' in $$props) $$invalidate(6, decimals = $$props.decimals);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		num,
    		decimals,
    		style,
    		className,
    		displayNum,
    		sign,
    		percentClass,
    		workingClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('num' in $$props) $$invalidate(5, num = $$props.num);
    		if ('decimals' in $$props) $$invalidate(6, decimals = $$props.decimals);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('displayNum' in $$props) $$invalidate(1, displayNum = $$props.displayNum);
    		if ('sign' in $$props) $$invalidate(2, sign = $$props.sign);
    		if ('percentClass' in $$props) $$invalidate(3, percentClass = $$props.percentClass);
    		if ('workingClass' in $$props) $$invalidate(4, workingClass = $$props.workingClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 128) {
    			$$invalidate(4, workingClass = className ? className + ' ' : '');
    		}

    		if ($$self.$$.dirty & /*num*/ 32) {
    			$$invalidate(3, percentClass = num < 0
    			? 'percent-display negative'
    			: 'percent-display positive');
    		}

    		if ($$self.$$.dirty & /*num*/ 32) {
    			$$invalidate(2, sign = num === 0 ? '' : num < 0 ? '—' : '+');
    		}

    		if ($$self.$$.dirty & /*num, decimals*/ 96) {
    			$$invalidate(1, displayNum = Math.abs(num * 100).toFixed(decimals));
    		}
    	};

    	return [style, displayNum, sign, percentClass, workingClass, num, decimals, className];
    }

    class Percent_display extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			num: 5,
    			decimals: 6,
    			style: 0,
    			className: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Percent_display",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get num() {
    		throw new Error("<Percent_display>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set num(value) {
    		throw new Error("<Percent_display>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get decimals() {
    		throw new Error("<Percent_display>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set decimals(value) {
    		throw new Error("<Percent_display>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Percent_display>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Percent_display>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Percent_display>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Percent_display>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Vwap.svelte generated by Svelte v3.46.3 */
    const file$c = "src\\components\\Vwap.svelte";

    // (28:8) {#if lastTrade}
    function create_if_block_1$3(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let percentdisplay;
    	let current;

    	percentdisplay = new Percent_display({
    			props: { num: /*diff*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*premimum*/ ctx[3]);
    			t1 = space();
    			create_component(percentdisplay.$$.fragment);
    			attr_dev(div0, "class", "label svelte-nih7pe");
    			add_location(div0, file$c, 29, 16, 1022);
    			attr_dev(div1, "class", "premium svelte-nih7pe");
    			add_location(div1, file$c, 28, 12, 983);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			mount_component(percentdisplay, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*premimum*/ 8) set_data_dev(t0, /*premimum*/ ctx[3]);
    			const percentdisplay_changes = {};
    			if (dirty & /*diff*/ 1) percentdisplay_changes.num = /*diff*/ ctx[0];
    			percentdisplay.$set(percentdisplay_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(percentdisplay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(percentdisplay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(percentdisplay);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(28:8) {#if lastTrade}",
    		ctx
    	});

    	return block;
    }

    // (41:8) {#if lastTrade}
    function create_if_block$6(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let t2_value = formatUSDC(/*lastTrade*/ ctx[2]) + "";
    	let t2;
    	let t3;
    	let span;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Latest Trade";
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			span = element("span");
    			span.textContent = "USDC";
    			attr_dev(div0, "class", "label svelte-nih7pe");
    			add_location(div0, file$c, 43, 20, 1569);
    			attr_dev(div1, "class", "value svelte-nih7pe");
    			add_location(div1, file$c, 44, 20, 1628);
    			attr_dev(span, "class", "currency-mark svelte-nih7pe");
    			add_location(span, file$c, 45, 20, 1698);
    			attr_dev(div2, "class", "last-trade svelte-nih7pe");
    			add_location(div2, file$c, 42, 16, 1523);
    			attr_dev(div3, "class", "column two svelte-nih7pe");
    			add_location(div3, file$c, 41, 12, 1481);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div2, t3);
    			append_dev(div2, span);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lastTrade*/ 4 && t2_value !== (t2_value = formatUSDC(/*lastTrade*/ ctx[2]) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(41:8) {#if lastTrade}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div4;
    	let t0;
    	let div3;
    	let div2;
    	let div0;
    	let t1;
    	let span0;
    	let t3;
    	let t4;
    	let div1;
    	let t5_value = formatUSDC(/*vwap*/ ctx[1]) + "";
    	let t5;
    	let t6;
    	let span1;
    	let t8;
    	let div4_class_value;
    	let current;
    	let if_block0 = /*lastTrade*/ ctx[2] && create_if_block_1$3(ctx);
    	let if_block1 = /*lastTrade*/ ctx[2] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t1 = text("Retail (");
    			span0 = element("span");
    			span0.textContent = "VWAP";
    			t3 = text(")");
    			t4 = space();
    			div1 = element("div");
    			t5 = text(t5_value);
    			t6 = space();
    			span1 = element("span");
    			span1.textContent = "USDC";
    			t8 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(span0, "class", "small svelte-nih7pe");
    			add_location(span0, file$c, 35, 43, 1250);
    			attr_dev(div0, "class", "label svelte-nih7pe");
    			add_location(div0, file$c, 35, 16, 1223);
    			attr_dev(div1, "class", "value svelte-nih7pe");
    			add_location(div1, file$c, 36, 16, 1306);
    			attr_dev(span1, "class", "currency-mark svelte-nih7pe");
    			add_location(span1, file$c, 37, 16, 1367);
    			attr_dev(div2, "class", "vwap svelte-nih7pe");
    			add_location(div2, file$c, 34, 12, 1187);
    			attr_dev(div3, "class", "column one svelte-nih7pe");
    			add_location(div3, file$c, 33, 8, 1149);
    			attr_dev(div4, "class", div4_class_value = "" + (null_to_empty(/*vwapClass*/ ctx[4]) + " svelte-nih7pe"));
    			add_location(div4, file$c, 25, 4, 919);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			if (if_block0) if_block0.m(div4, null);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t1);
    			append_dev(div0, span0);
    			append_dev(div0, t3);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, t5);
    			append_dev(div2, t6);
    			append_dev(div2, span1);
    			append_dev(div4, t8);
    			if (if_block1) if_block1.m(div4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*lastTrade*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*lastTrade*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div4, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*vwap*/ 2) && t5_value !== (t5_value = formatUSDC(/*vwap*/ ctx[1]) + "")) set_data_dev(t5, t5_value);

    			if (/*lastTrade*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					if_block1.m(div4, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*vwapClass*/ 16 && div4_class_value !== (div4_class_value = "" + (null_to_empty(/*vwapClass*/ ctx[4]) + " svelte-nih7pe"))) {
    				attr_dev(div4, "class", div4_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let vwapClass;
    	let trades;
    	let tradeData;
    	let lastTrade;
    	let vwap;
    	let diff;
    	let premimum;
    	let $shipTrades;
    	validate_store(shipTrades, 'shipTrades');
    	component_subscribe($$self, shipTrades, $$value => $$invalidate(9, $shipTrades = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Vwap', slots, []);
    	let { ship } = $$props;
    	let { className = '' } = $$props;
    	const writable_props = ['ship', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Vwap> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ship' in $$props) $$invalidate(5, ship = $$props.ship);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		formatUSDC,
    		tokenPrices,
    		shipTrades,
    		PercentDisplay: Percent_display,
    		ship,
    		className,
    		diff,
    		premimum,
    		vwap,
    		lastTrade,
    		tradeData,
    		trades,
    		vwapClass,
    		$shipTrades
    	});

    	$$self.$inject_state = $$props => {
    		if ('ship' in $$props) $$invalidate(5, ship = $$props.ship);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('diff' in $$props) $$invalidate(0, diff = $$props.diff);
    		if ('premimum' in $$props) $$invalidate(3, premimum = $$props.premimum);
    		if ('vwap' in $$props) $$invalidate(1, vwap = $$props.vwap);
    		if ('lastTrade' in $$props) $$invalidate(2, lastTrade = $$props.lastTrade);
    		if ('tradeData' in $$props) $$invalidate(7, tradeData = $$props.tradeData);
    		if ('trades' in $$props) $$invalidate(8, trades = $$props.trades);
    		if ('vwapClass' in $$props) $$invalidate(4, vwapClass = $$props.vwapClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 64) {
    			$$invalidate(4, vwapClass = 'vwap-wrapper' + (className ? ' ' + className : ''));
    		}

    		if ($$self.$$.dirty & /*$shipTrades, ship*/ 544) {
    			$$invalidate(8, trades = $shipTrades[ship.id]);
    		}

    		if ($$self.$$.dirty & /*trades*/ 256) {
    			$$invalidate(7, tradeData = trades && trades.USDC ? trades.USDC : []);
    		}

    		if ($$self.$$.dirty & /*tradeData*/ 128) {
    			$$invalidate(2, lastTrade = tradeData[tradeData.length - 1]
    			? tradeData[tradeData.length - 1].value
    			: 0);
    		}

    		if ($$self.$$.dirty & /*ship*/ 32) {
    			$$invalidate(1, vwap = ship.tradeSettings.vwap);
    		}

    		if ($$self.$$.dirty & /*lastTrade, vwap*/ 6) {
    			$$invalidate(0, diff = (Number(lastTrade) - vwap) / vwap);
    		}

    		if ($$self.$$.dirty & /*diff*/ 1) {
    			$$invalidate(3, premimum = diff < 0 ? 'Discount vs Retail' : 'Premium to Retail');
    		}
    	};

    	return [
    		diff,
    		vwap,
    		lastTrade,
    		premimum,
    		vwapClass,
    		ship,
    		className,
    		tradeData,
    		trades,
    		$shipTrades
    	];
    }

    class Vwap extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { ship: 5, className: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Vwap",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ship*/ ctx[5] === undefined && !('ship' in props)) {
    			console.warn("<Vwap> was created without expected prop 'ship'");
    		}
    	}

    	get ship() {
    		throw new Error("<Vwap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ship(value) {
    		throw new Error("<Vwap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Vwap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Vwap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Slots.svelte generated by Svelte v3.46.3 */

    const file$b = "src\\components\\Slots.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	child_ctx[4] = i;
    	return child_ctx;
    }

    // (14:4) {#each slots as slot, i}
    function create_each_block$2(ctx) {
    	let div3;
    	let div0;
    	let t0_value = /*slot*/ ctx[2].type + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = (/*title*/ ctx[1] === 'Crew' ? '' : /*slot*/ ctx[2].size) + "";
    	let t2;
    	let t3;
    	let div2;
    	let t4_value = /*slot*/ ctx[2].quantity + "";
    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(div0, "class", "column type svelte-b6hs27");
    			add_location(div0, file$b, 15, 12, 410);
    			attr_dev(div1, "class", "column size svelte-b6hs27");
    			add_location(div1, file$b, 16, 12, 470);
    			attr_dev(div2, "class", "column count svelte-b6hs27");
    			add_location(div2, file$b, 17, 12, 554);
    			attr_dev(div3, "class", "" + (null_to_empty(/*i*/ ctx[4] % 2 ? 'row' : 'row odd') + " svelte-b6hs27"));
    			add_location(div3, file$b, 14, 8, 357);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, t4);
    			append_dev(div3, t5);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*slots*/ 1 && t0_value !== (t0_value = /*slot*/ ctx[2].type + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*title, slots*/ 3 && t2_value !== (t2_value = (/*title*/ ctx[1] === 'Crew' ? '' : /*slot*/ ctx[2].size) + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*slots*/ 1 && t4_value !== (t4_value = /*slot*/ ctx[2].quantity + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(14:4) {#each slots as slot, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div4;
    	let div3;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = (/*title*/ ctx[1] === 'Crew' ? '' : 'Size') + "";
    	let t2;
    	let t3;
    	let div2;
    	let t5;
    	let each_value = /*slots*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text(/*title*/ ctx[1]);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "#";
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "column type svelte-b6hs27");
    			add_location(div0, file$b, 8, 8, 137);
    			attr_dev(div1, "class", "column size svelte-b6hs27");
    			add_location(div1, file$b, 9, 8, 189);
    			attr_dev(div2, "class", "column count svelte-b6hs27");
    			add_location(div2, file$b, 10, 8, 266);
    			attr_dev(div3, "class", "row header svelte-b6hs27");
    			add_location(div3, file$b, 7, 4, 103);
    			attr_dev(div4, "class", "grid-wrapper svelte-b6hs27");
    			add_location(div4, file$b, 5, 0, 69);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div4, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div4, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*title*/ 2) set_data_dev(t0, /*title*/ ctx[1]);
    			if (dirty & /*title*/ 2 && t2_value !== (t2_value = (/*title*/ ctx[1] === 'Crew' ? '' : 'Size') + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*slots, title*/ 3) {
    				each_value = /*slots*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div4, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots$1 = {}, $$scope } = $$props;
    	validate_slots('Slots', slots$1, []);
    	let { slots } = $$props;
    	let { title } = $$props;
    	const writable_props = ['slots', 'title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Slots> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('slots' in $$props) $$invalidate(0, slots = $$props.slots);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    	};

    	$$self.$capture_state = () => ({ slots, title });

    	$$self.$inject_state = $$props => {
    		if ('slots' in $$props) $$invalidate(0, slots = $$props.slots);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [slots, title];
    }

    class Slots extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { slots: 0, title: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Slots",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*slots*/ ctx[0] === undefined && !('slots' in props)) {
    			console.warn("<Slots> was created without expected prop 'slots'");
    		}

    		if (/*title*/ ctx[1] === undefined && !('title' in props)) {
    			console.warn("<Slots> was created without expected prop 'title'");
    		}
    	}

    	get slots() {
    		throw new Error("<Slots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slots(value) {
    		throw new Error("<Slots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Slots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Slots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\layouts\Feature-ship.svelte generated by Svelte v3.46.3 */
    const file$a = "src\\layouts\\Feature-ship.svelte";

    // (100:0) {:else}
    function create_else_block$3(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			add_location(p, file$a, 100, 4, 3748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(100:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (46:0) {#if ship}
    function create_if_block$5(ctx) {
    	let div16;
    	let div4;
    	let div3;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let faexpand;
    	let t2;
    	let div7;
    	let div6;
    	let div5;
    	let t3_value = /*ship*/ ctx[1].name + "";
    	let t3;
    	let t4;
    	let metatags;
    	let t5;
    	let div15;
    	let div14;
    	let div9;
    	let div8;
    	let t6_value = /*ship*/ ctx[1].description + "";
    	let t6;
    	let t7;
    	let tradechart0;
    	let t8;
    	let tradechart1;
    	let div9_resize_listener;
    	let t9;
    	let div13;
    	let vwap;
    	let t10;
    	let div10;
    	let a;
    	let span0;
    	let t12;
    	let span1;
    	let t14;
    	let div11;
    	let priceaskbid;
    	let t15;
    	let div12;
    	let slots0;
    	let t16;
    	let slots1;
    	let t17;
    	let slots2;
    	let current;
    	let mounted;
    	let dispose;
    	faexpand = new FaExpand({ $$inline: true });

    	metatags = new Meta_tags({
    			props: {
    				ship: /*ship*/ ctx[1],
    				includeSymbol: true,
    				className: "large"
    			},
    			$$inline: true
    		});

    	tradechart0 = new Trade_chart({
    			props: {
    				ship: /*ship*/ ctx[1],
    				quotePair: "USDC",
    				width: /*chartWidth*/ ctx[2],
    				height: /*chartHeight*/ ctx[3]
    			},
    			$$inline: true
    		});

    	tradechart1 = new Trade_chart({
    			props: {
    				ship: /*ship*/ ctx[1],
    				quotePair: "ATLAS",
    				width: /*chartWidth*/ ctx[2],
    				height: /*chartHeight*/ ctx[3]
    			},
    			$$inline: true
    		});

    	vwap = new Vwap({
    			props: { ship: /*ship*/ ctx[1] },
    			$$inline: true
    		});

    	priceaskbid = new Price_ask_bid({
    			props: { ship: /*ship*/ ctx[1] },
    			$$inline: true
    		});

    	slots0 = new Slots({
    			props: {
    				slots: /*ship*/ ctx[1].slots.crewSlots,
    				title: "Crew"
    			},
    			$$inline: true
    		});

    	slots1 = new Slots({
    			props: {
    				slots: /*ship*/ ctx[1].slots.componentSlots,
    				title: "Components"
    			},
    			$$inline: true
    		});

    	slots2 = new Slots({
    			props: {
    				slots: /*ship*/ ctx[1].slots.moduleSlots,
    				title: "Modules"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div16 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Gallery";
    			t1 = space();
    			div1 = element("div");
    			create_component(faexpand.$$.fragment);
    			t2 = space();
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(metatags.$$.fragment);
    			t5 = space();
    			div15 = element("div");
    			div14 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			create_component(tradechart0.$$.fragment);
    			t8 = space();
    			create_component(tradechart1.$$.fragment);
    			t9 = space();
    			div13 = element("div");
    			create_component(vwap.$$.fragment);
    			t10 = space();
    			div10 = element("div");
    			a = element("a");
    			span0 = element("span");
    			span0.textContent = "»";
    			t12 = text(" \r\n                            To Market Page\r\n                            ");
    			span1 = element("span");
    			span1.textContent = "»";
    			t14 = space();
    			div11 = element("div");
    			create_component(priceaskbid.$$.fragment);
    			t15 = space();
    			div12 = element("div");
    			create_component(slots0.$$.fragment);
    			t16 = space();
    			create_component(slots1.$$.fragment);
    			t17 = space();
    			create_component(slots2.$$.fragment);
    			attr_dev(div0, "class", "message svelte-110u2r3");
    			add_location(div0, file$a, 50, 20, 1849);
    			attr_dev(div1, "class", "icon svelte-110u2r3");
    			add_location(div1, file$a, 51, 20, 1905);
    			attr_dev(div2, "class", "icon-message svelte-110u2r3");
    			add_location(div2, file$a, 49, 16, 1801);
    			attr_dev(div3, "class", "image svelte-110u2r3");
    			attr_dev(div3, "style", /*imageStyle*/ ctx[6]);
    			add_location(div3, file$a, 48, 12, 1745);
    			attr_dev(div4, "class", "image-box svelte-110u2r3");
    			add_location(div4, file$a, 47, 8, 1685);
    			attr_dev(div5, "class", "ship-title-text svelte-110u2r3");
    			add_location(div5, file$a, 57, 16, 2094);
    			attr_dev(div6, "class", "ship-title-box svelte-110u2r3");
    			add_location(div6, file$a, 56, 12, 2048);
    			attr_dev(div7, "class", "title-box svelte-110u2r3");
    			add_location(div7, file$a, 55, 8, 2011);
    			attr_dev(div8, "class", "ship-description svelte-110u2r3");
    			add_location(div8, file$a, 65, 20, 2419);
    			attr_dev(div9, "class", "column-box-left svelte-110u2r3");
    			add_render_callback(() => /*div9_elementresize_handler*/ ctx[13].call(div9));
    			add_location(div9, file$a, 64, 16, 2347);
    			attr_dev(span0, "class", "arrow svelte-110u2r3");
    			add_location(span0, file$a, 78, 28, 2996);
    			attr_dev(span1, "class", "arrow svelte-110u2r3");
    			add_location(span1, file$a, 80, 28, 3105);
    			attr_dev(a, "title", /*linkText*/ ctx[4]);
    			attr_dev(a, "href", /*marketURL*/ ctx[5]);
    			attr_dev(a, "class", "svelte-110u2r3");
    			add_location(a, file$a, 77, 24, 2929);
    			attr_dev(div10, "class", "market-link svelte-110u2r3");
    			add_location(div10, file$a, 76, 20, 2878);
    			attr_dev(div11, "class", "ship-price-box svelte-110u2r3");
    			add_location(div11, file$a, 84, 20, 3222);
    			attr_dev(div12, "class", "slots-wrapper svelte-110u2r3");
    			add_location(div12, file$a, 88, 20, 3355);
    			attr_dev(div13, "class", "column-box-right svelte-110u2r3");
    			add_location(div13, file$a, 72, 16, 2780);
    			attr_dev(div14, "class", "content svelte-110u2r3");
    			add_location(div14, file$a, 62, 12, 2306);
    			attr_dev(div15, "class", "content-box svelte-110u2r3");
    			add_location(div15, file$a, 61, 8, 2267);
    			attr_dev(div16, "class", "feature-ship svelte-110u2r3");
    			add_location(div16, file$a, 46, 4, 1649);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div16, anchor);
    			append_dev(div16, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(faexpand, div1, null);
    			append_dev(div16, t2);
    			append_dev(div16, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, t3);
    			append_dev(div6, t4);
    			mount_component(metatags, div6, null);
    			append_dev(div16, t5);
    			append_dev(div16, div15);
    			append_dev(div15, div14);
    			append_dev(div14, div9);
    			append_dev(div9, div8);
    			append_dev(div8, t6);
    			append_dev(div9, t7);
    			mount_component(tradechart0, div9, null);
    			append_dev(div9, t8);
    			mount_component(tradechart1, div9, null);
    			div9_resize_listener = add_resize_listener(div9, /*div9_elementresize_handler*/ ctx[13].bind(div9));
    			append_dev(div14, t9);
    			append_dev(div14, div13);
    			mount_component(vwap, div13, null);
    			append_dev(div13, t10);
    			append_dev(div13, div10);
    			append_dev(div10, a);
    			append_dev(a, span0);
    			append_dev(a, t12);
    			append_dev(a, span1);
    			append_dev(div13, t14);
    			append_dev(div13, div11);
    			mount_component(priceaskbid, div11, null);
    			append_dev(div13, t15);
    			append_dev(div13, div12);
    			mount_component(slots0, div12, null);
    			append_dev(div12, t16);
    			mount_component(slots1, div12, null);
    			append_dev(div12, t17);
    			mount_component(slots2, div12, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div4, "click", /*openGallery*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*imageStyle*/ 64) {
    				attr_dev(div3, "style", /*imageStyle*/ ctx[6]);
    			}

    			if ((!current || dirty & /*ship*/ 2) && t3_value !== (t3_value = /*ship*/ ctx[1].name + "")) set_data_dev(t3, t3_value);
    			const metatags_changes = {};
    			if (dirty & /*ship*/ 2) metatags_changes.ship = /*ship*/ ctx[1];
    			metatags.$set(metatags_changes);
    			if ((!current || dirty & /*ship*/ 2) && t6_value !== (t6_value = /*ship*/ ctx[1].description + "")) set_data_dev(t6, t6_value);
    			const tradechart0_changes = {};
    			if (dirty & /*ship*/ 2) tradechart0_changes.ship = /*ship*/ ctx[1];
    			if (dirty & /*chartWidth*/ 4) tradechart0_changes.width = /*chartWidth*/ ctx[2];
    			if (dirty & /*chartHeight*/ 8) tradechart0_changes.height = /*chartHeight*/ ctx[3];
    			tradechart0.$set(tradechart0_changes);
    			const tradechart1_changes = {};
    			if (dirty & /*ship*/ 2) tradechart1_changes.ship = /*ship*/ ctx[1];
    			if (dirty & /*chartWidth*/ 4) tradechart1_changes.width = /*chartWidth*/ ctx[2];
    			if (dirty & /*chartHeight*/ 8) tradechart1_changes.height = /*chartHeight*/ ctx[3];
    			tradechart1.$set(tradechart1_changes);
    			const vwap_changes = {};
    			if (dirty & /*ship*/ 2) vwap_changes.ship = /*ship*/ ctx[1];
    			vwap.$set(vwap_changes);

    			if (!current || dirty & /*linkText*/ 16) {
    				attr_dev(a, "title", /*linkText*/ ctx[4]);
    			}

    			if (!current || dirty & /*marketURL*/ 32) {
    				attr_dev(a, "href", /*marketURL*/ ctx[5]);
    			}

    			const priceaskbid_changes = {};
    			if (dirty & /*ship*/ 2) priceaskbid_changes.ship = /*ship*/ ctx[1];
    			priceaskbid.$set(priceaskbid_changes);
    			const slots0_changes = {};
    			if (dirty & /*ship*/ 2) slots0_changes.slots = /*ship*/ ctx[1].slots.crewSlots;
    			slots0.$set(slots0_changes);
    			const slots1_changes = {};
    			if (dirty & /*ship*/ 2) slots1_changes.slots = /*ship*/ ctx[1].slots.componentSlots;
    			slots1.$set(slots1_changes);
    			const slots2_changes = {};
    			if (dirty & /*ship*/ 2) slots2_changes.slots = /*ship*/ ctx[1].slots.moduleSlots;
    			slots2.$set(slots2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(faexpand.$$.fragment, local);
    			transition_in(metatags.$$.fragment, local);
    			transition_in(tradechart0.$$.fragment, local);
    			transition_in(tradechart1.$$.fragment, local);
    			transition_in(vwap.$$.fragment, local);
    			transition_in(priceaskbid.$$.fragment, local);
    			transition_in(slots0.$$.fragment, local);
    			transition_in(slots1.$$.fragment, local);
    			transition_in(slots2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(faexpand.$$.fragment, local);
    			transition_out(metatags.$$.fragment, local);
    			transition_out(tradechart0.$$.fragment, local);
    			transition_out(tradechart1.$$.fragment, local);
    			transition_out(vwap.$$.fragment, local);
    			transition_out(priceaskbid.$$.fragment, local);
    			transition_out(slots0.$$.fragment, local);
    			transition_out(slots1.$$.fragment, local);
    			transition_out(slots2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div16);
    			destroy_component(faexpand);
    			destroy_component(metatags);
    			destroy_component(tradechart0);
    			destroy_component(tradechart1);
    			div9_resize_listener();
    			destroy_component(vwap);
    			destroy_component(priceaskbid);
    			destroy_component(slots0);
    			destroy_component(slots1);
    			destroy_component(slots2);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(46:0) {#if ship}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$5, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*ship*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let ship;
    	let imageName;
    	let imageURL;
    	let imageStyle;
    	let atlasMarket;
    	let marketURL;
    	let linkText;
    	let chartWidth;
    	let chartHeight;
    	let $ships;
    	validate_store(ships, 'ships');
    	component_subscribe($$self, ships, $$value => $$invalidate(12, $ships = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Feature_ship', slots, []);
    	const medium = assets.images['med-720'];
    	let { message = 'Ship!' } = $$props;
    	let w;

    	const openGallery = () => {
    		gallery.update(gal => ({ ...gal, ship }));
    	};

    	// $: { console.log('Featured Ship', ship); }
    	const resetGallery = () => {
    		gallery.update(gal => ({ ...gal, currentIndex: 0 }));
    	};

    	onMount(() => {
    		resetGallery();
    		getTrades(ship);
    	});

    	const writable_props = ['message'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Feature_ship> was created with unknown prop '${key}'`);
    	});

    	function div9_elementresize_handler() {
    		w = this.clientWidth;
    		$$invalidate(0, w);
    	}

    	$$self.$$set = $$props => {
    		if ('message' in $$props) $$invalidate(8, message = $$props.message);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		gallery,
    		ships,
    		assets,
    		FaExpand,
    		getTrades,
    		PriceAskBid: Price_ask_bid,
    		MetaTags: Meta_tags,
    		TradeChart: Trade_chart,
    		Vwap,
    		Slots,
    		medium,
    		message,
    		w,
    		openGallery,
    		resetGallery,
    		ship,
    		chartWidth,
    		chartHeight,
    		linkText,
    		atlasMarket,
    		marketURL,
    		imageURL,
    		imageStyle,
    		imageName,
    		$ships
    	});

    	$$self.$inject_state = $$props => {
    		if ('message' in $$props) $$invalidate(8, message = $$props.message);
    		if ('w' in $$props) $$invalidate(0, w = $$props.w);
    		if ('ship' in $$props) $$invalidate(1, ship = $$props.ship);
    		if ('chartWidth' in $$props) $$invalidate(2, chartWidth = $$props.chartWidth);
    		if ('chartHeight' in $$props) $$invalidate(3, chartHeight = $$props.chartHeight);
    		if ('linkText' in $$props) $$invalidate(4, linkText = $$props.linkText);
    		if ('atlasMarket' in $$props) $$invalidate(9, atlasMarket = $$props.atlasMarket);
    		if ('marketURL' in $$props) $$invalidate(5, marketURL = $$props.marketURL);
    		if ('imageURL' in $$props) $$invalidate(10, imageURL = $$props.imageURL);
    		if ('imageStyle' in $$props) $$invalidate(6, imageStyle = $$props.imageStyle);
    		if ('imageName' in $$props) $$invalidate(11, imageName = $$props.imageName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$ships, message*/ 4352) {
    			$$invalidate(1, ship = $ships.find(next => next.id === message));
    		}

    		if ($$self.$$.dirty & /*ship*/ 2) {
    			$$invalidate(11, imageName = ship.image ? ship.image.split('/').pop() : '');
    		}

    		if ($$self.$$.dirty & /*imageName, ship*/ 2050) {
    			$$invalidate(10, imageURL = medium[imageName]
    			? 'images/med-720/' + imageName
    			: ship.image);
    		}

    		if ($$self.$$.dirty & /*imageURL*/ 1024) {
    			$$invalidate(6, imageStyle = 'background-image: url("' + imageURL + '");');
    		}

    		if ($$self.$$.dirty & /*ship*/ 2) {
    			$$invalidate(9, atlasMarket = ship.markets.find(next => next.quotePair === 'ATLAS'));
    		}

    		if ($$self.$$.dirty & /*atlasMarket*/ 512) {
    			$$invalidate(5, marketURL = 'https://play.staratlas.com/market/' + atlasMarket.id);
    		}

    		if ($$self.$$.dirty & /*ship*/ 2) {
    			$$invalidate(4, linkText = 'Official Star Atlas page for ' + ship.name);
    		}

    		if ($$self.$$.dirty & /*w*/ 1) {
    			$$invalidate(2, chartWidth = w - 48);
    		}

    		if ($$self.$$.dirty & /*chartWidth*/ 4) {
    			$$invalidate(3, chartHeight = Math.round(chartWidth / 1.6));
    		}
    	};

    	return [
    		w,
    		ship,
    		chartWidth,
    		chartHeight,
    		linkText,
    		marketURL,
    		imageStyle,
    		openGallery,
    		message,
    		atlasMarket,
    		imageURL,
    		imageName,
    		$ships,
    		div9_elementresize_handler
    	];
    }

    class Feature_ship extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { message: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Feature_ship",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get message() {
    		throw new Error("<Feature_ship>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<Feature_ship>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\table\Cell-highlight.svelte generated by Svelte v3.46.3 */
    const file$9 = "src\\table\\Cell-highlight.svelte";

    // (27:0) {:else}
    function create_else_block$2(ctx) {
    	let div;
    	let t;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*val*/ ctx[3]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-3ficm9"));
    			add_location(div, file$9, 27, 0, 850);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*clickHandler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*val*/ 8) set_data_dev(t, /*val*/ ctx[3]);

    			if (dirty & /*cellClass*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-3ficm9"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(27:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (22:0) {#if column.dataName === 'name'}
    function create_if_block$4(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let div2_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(/*val*/ ctx[3]);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(/*symbol*/ ctx[1]);
    			attr_dev(div0, "class", "title svelte-3ficm9");
    			add_location(div0, file$9, 23, 4, 761);
    			attr_dev(div1, "class", "symbol svelte-3ficm9");
    			add_location(div1, file$9, 24, 4, 797);
    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-3ficm9"));
    			add_location(div2, file$9, 22, 0, 708);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", /*clickHandler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*val*/ 8) set_data_dev(t0, /*val*/ ctx[3]);
    			if (dirty & /*symbol*/ 2) set_data_dev(t2, /*symbol*/ ctx[1]);

    			if (dirty & /*cellClass*/ 4 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*cellClass*/ ctx[2]) + " svelte-3ficm9"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(22:0) {#if column.dataName === 'name'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*column*/ ctx[0].dataName === 'name') return create_if_block$4;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let val;
    	let odd;
    	let cellClass;
    	let symbol;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell_highlight', slots, []);
    	let { column } = $$props;
    	let { rowNumber } = $$props;
    	let { row } = $$props;

    	const clickHandler = () => {
    		modalStatus.set(bind(Feature_ship, { message: row.data.id }));
    	};

    	const writable_props = ['column', 'rowNumber', 'row'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cell_highlight> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(5, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(6, row = $$props.row);
    	};

    	$$self.$capture_state = () => ({
    		bind,
    		modalStatus,
    		FeatureShip: Feature_ship,
    		column,
    		rowNumber,
    		row,
    		clickHandler,
    		symbol,
    		odd,
    		cellClass,
    		val
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(0, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(5, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(6, row = $$props.row);
    		if ('symbol' in $$props) $$invalidate(1, symbol = $$props.symbol);
    		if ('odd' in $$props) $$invalidate(7, odd = $$props.odd);
    		if ('cellClass' in $$props) $$invalidate(2, cellClass = $$props.cellClass);
    		if ('val' in $$props) $$invalidate(3, val = $$props.val);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*row, column*/ 65) {
    			$$invalidate(3, val = row.data[column.dataName]);
    		}

    		if ($$self.$$.dirty & /*rowNumber*/ 32) {
    			$$invalidate(7, odd = Boolean(rowNumber % 2));
    		}

    		if ($$self.$$.dirty & /*odd, column*/ 129) {
    			$$invalidate(2, cellClass = 'cell-highlight ' + (odd ? 'odd' : 'even') + (column.sortDirection ? ' sorted' : '') + (column.capitalize ? ' capitalize' : ''));
    		}

    		if ($$self.$$.dirty & /*row*/ 64) {
    			$$invalidate(1, symbol = row.data.symbol);
    		}
    	};

    	return [column, symbol, cellClass, val, clickHandler, rowNumber, row, odd];
    }

    class Cell_highlight extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { column: 0, rowNumber: 5, row: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell_highlight",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[0] === undefined && !('column' in props)) {
    			console.warn("<Cell_highlight> was created without expected prop 'column'");
    		}

    		if (/*rowNumber*/ ctx[5] === undefined && !('rowNumber' in props)) {
    			console.warn("<Cell_highlight> was created without expected prop 'rowNumber'");
    		}

    		if (/*row*/ ctx[6] === undefined && !('row' in props)) {
    			console.warn("<Cell_highlight> was created without expected prop 'row'");
    		}
    	}

    	get column() {
    		throw new Error("<Cell_highlight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Cell_highlight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowNumber() {
    		throw new Error("<Cell_highlight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowNumber(value) {
    		throw new Error("<Cell_highlight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<Cell_highlight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<Cell_highlight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\table\Cell-image.svelte generated by Svelte v3.46.3 */
    const file$8 = "src\\table\\Cell-image.svelte";

    function create_fragment$8(ctx) {
    	let div1;
    	let div0;
    	let div1_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "image svelte-1t4sk06");
    			attr_dev(div0, "style", /*imageStyle*/ ctx[0]);
    			add_location(div0, file$8, 28, 4, 882);
    			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*cellClass*/ ctx[1]) + " svelte-1t4sk06"));
    			add_location(div1, file$8, 27, 0, 829);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*clickHandler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*imageStyle*/ 1) {
    				attr_dev(div0, "style", /*imageStyle*/ ctx[0]);
    			}

    			if (dirty & /*cellClass*/ 2 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*cellClass*/ ctx[1]) + " svelte-1t4sk06"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let val;
    	let odd;
    	let cellClass;
    	let imageName;
    	let imageURL;
    	let imageStyle;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell_image', slots, []);
    	let { column } = $$props;
    	let { rowNumber } = $$props;
    	let { row } = $$props;

    	const clickHandler = () => {
    		modalStatus.set(bind(Feature_ship, { message: row.data.id }));
    	};

    	const writable_props = ['column', 'rowNumber', 'row'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cell_image> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(3, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(4, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(5, row = $$props.row);
    	};

    	$$self.$capture_state = () => ({
    		assets,
    		bind,
    		modalStatus,
    		FeatureShip: Feature_ship,
    		column,
    		rowNumber,
    		row,
    		clickHandler,
    		imageURL,
    		imageStyle,
    		val,
    		imageName,
    		odd,
    		cellClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(3, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(4, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(5, row = $$props.row);
    		if ('imageURL' in $$props) $$invalidate(6, imageURL = $$props.imageURL);
    		if ('imageStyle' in $$props) $$invalidate(0, imageStyle = $$props.imageStyle);
    		if ('val' in $$props) $$invalidate(7, val = $$props.val);
    		if ('imageName' in $$props) $$invalidate(8, imageName = $$props.imageName);
    		if ('odd' in $$props) $$invalidate(9, odd = $$props.odd);
    		if ('cellClass' in $$props) $$invalidate(1, cellClass = $$props.cellClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*row, column*/ 40) {
    			$$invalidate(7, val = row.data[column.dataName]);
    		}

    		if ($$self.$$.dirty & /*rowNumber*/ 16) {
    			$$invalidate(9, odd = Boolean(rowNumber % 2));
    		}

    		if ($$self.$$.dirty & /*odd*/ 512) {
    			$$invalidate(1, cellClass = 'cell-image ' + (odd ? 'odd' : 'even'));
    		}

    		if ($$self.$$.dirty & /*val*/ 128) {
    			$$invalidate(8, imageName = val ? val.split('/').pop() : '');
    		}

    		if ($$self.$$.dirty & /*imageName, val*/ 384) {
    			$$invalidate(6, imageURL = assets.images['thumb-220'][imageName]
    			? 'images/thumb-220/' + imageName
    			: val);
    		}

    		if ($$self.$$.dirty & /*imageURL*/ 64) {
    			$$invalidate(0, imageStyle = 'background-image: url("' + imageURL + '");');
    		}
    	};

    	return [
    		imageStyle,
    		cellClass,
    		clickHandler,
    		column,
    		rowNumber,
    		row,
    		imageURL,
    		val,
    		imageName,
    		odd
    	];
    }

    class Cell_image extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { column: 3, rowNumber: 4, row: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell_image",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[3] === undefined && !('column' in props)) {
    			console.warn("<Cell_image> was created without expected prop 'column'");
    		}

    		if (/*rowNumber*/ ctx[4] === undefined && !('rowNumber' in props)) {
    			console.warn("<Cell_image> was created without expected prop 'rowNumber'");
    		}

    		if (/*row*/ ctx[5] === undefined && !('row' in props)) {
    			console.warn("<Cell_image> was created without expected prop 'row'");
    		}
    	}

    	get column() {
    		throw new Error("<Cell_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Cell_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowNumber() {
    		throw new Error("<Cell_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowNumber(value) {
    		throw new Error("<Cell_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<Cell_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<Cell_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\table\Cell-usdc.svelte generated by Svelte v3.46.3 */
    const file$7 = "src\\table\\Cell-usdc.svelte";

    function create_fragment$7(ctx) {
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let t2_value = formatUSDC(/*val*/ ctx[1]) + "";
    	let t2;
    	let div2_class_value;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "$";
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			attr_dev(div0, "class", "currency-mark svelte-1abidoq");
    			add_location(div0, file$7, 20, 4, 598);
    			attr_dev(div1, "class", "number svelte-1abidoq");
    			add_location(div1, file$7, 21, 4, 638);
    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(/*cellClass*/ ctx[0]) + " svelte-1abidoq"));
    			add_location(div2, file$7, 19, 0, 569);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*val*/ 2 && t2_value !== (t2_value = formatUSDC(/*val*/ ctx[1]) + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*cellClass*/ 1 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*cellClass*/ ctx[0]) + " svelte-1abidoq"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let val;
    	let odd;
    	let cellClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cell_usdc', slots, []);
    	let { column } = $$props;
    	let { rowNumber } = $$props;
    	let { row } = $$props;
    	const writable_props = ['column', 'rowNumber', 'row'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cell_usdc> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('column' in $$props) $$invalidate(2, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(3, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(4, row = $$props.row);
    	};

    	$$self.$capture_state = () => ({
    		IoLogoUsd,
    		formatUSDC,
    		column,
    		rowNumber,
    		row,
    		odd,
    		cellClass,
    		val
    	});

    	$$self.$inject_state = $$props => {
    		if ('column' in $$props) $$invalidate(2, column = $$props.column);
    		if ('rowNumber' in $$props) $$invalidate(3, rowNumber = $$props.rowNumber);
    		if ('row' in $$props) $$invalidate(4, row = $$props.row);
    		if ('odd' in $$props) $$invalidate(5, odd = $$props.odd);
    		if ('cellClass' in $$props) $$invalidate(0, cellClass = $$props.cellClass);
    		if ('val' in $$props) $$invalidate(1, val = $$props.val);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*row, column*/ 20) {
    			$$invalidate(1, val = row.data[column.dataName]);
    		}

    		if ($$self.$$.dirty & /*rowNumber*/ 8) {
    			$$invalidate(5, odd = Boolean(rowNumber % 2));
    		}

    		if ($$self.$$.dirty & /*odd, column*/ 36) {
    			$$invalidate(0, cellClass = 'market-number ' + (odd ? 'odd' : 'even') + (column.sortDirection ? ' sorted' : '') + (column.parent ? ' parent' : '') + (column.child ? ' child' : '') + (column.dataName === 'vwap' ? ' vwap' : ''));
    		}
    	};

    	return [cellClass, val, column, rowNumber, row, odd];
    }

    class Cell_usdc extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { column: 2, rowNumber: 3, row: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cell_usdc",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*column*/ ctx[2] === undefined && !('column' in props)) {
    			console.warn("<Cell_usdc> was created without expected prop 'column'");
    		}

    		if (/*rowNumber*/ ctx[3] === undefined && !('rowNumber' in props)) {
    			console.warn("<Cell_usdc> was created without expected prop 'rowNumber'");
    		}

    		if (/*row*/ ctx[4] === undefined && !('row' in props)) {
    			console.warn("<Cell_usdc> was created without expected prop 'row'");
    		}
    	}

    	get column() {
    		throw new Error("<Cell_usdc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set column(value) {
    		throw new Error("<Cell_usdc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowNumber() {
    		throw new Error("<Cell_usdc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowNumber(value) {
    		throw new Error("<Cell_usdc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<Cell_usdc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<Cell_usdc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const dummyObject = {};

    const columnSettings = [
        { dataName: 'image',display: ' ', 
            width:  64, noSort: () => true, cellComponent: Cell_image },

        { dataName: 'name', display: 'Ship', 
            width: 190, cellComponent: Cell_highlight },

        { dataName: 'askATLAS', display: 'Ask -Bid Atlas', 
            width: 200, displayText: ' ', currency: 'atlas', cellComponent: Cell_ask_bid, headerComponent: Table_header_atlas, child: true },

        { dataName: 'askUSDC', display: 'Ask-Bid USDC', displayText: ' ', 
            width: 134, currency: 'usdc', cellComponent: Cell_ask_bid, headerComponent: Table_header_usdc, child: true },

        { dataName: 'vwap', display: 'Retail (VWAP)', displayText: 'Retail',
            width: 104, alignRight: true, cellComponent: Cell_usdc },

        { dataName: 'diff', display: 'USDC - Ask vs. Retail', displayText: 'Ask vs Retail', 
            width: 84, doubleLine:true, usePercent: true },

        { dataName: 'aprAskUSDC', display: 'APR vs Ask (USDC)', displayText: 'APR Ask',
            width: 92, capitalize: true, usePercent: true },

        { dataName: 'aprVWAP', display: 'APR vs Retail (VWAP)', displayText: 'APR Retail',
            width: 104, capitalize: true, usePercent: true },

        { dataName: 'spec', display: 'Role',
            width: 110, capitalize: true },

        { dataName: 'shipClass', display: 'Size',
            width: 100, capitalize: true },

        { dataName: 'rarity', display: 'Rarity',
            width: 100, capitalize: true },

        { dataName: 'supply', display: 'Total Supply',
            width: 86, doubleLine:true, alignRight: true, capitalize: true, cellComponent: Cell_atlas }
    ];


    const composeColumns = (composeClickHandler, sortData) => columnSettings.map(column => ({
        ...column,
        headerComponent: column.headerComponent || Table_header,
        cellComponent: column.cellComponent || Cell_basic,
        clickHandler: composeClickHandler(column.dataName),
        sortDirection: sortData[column.dataName]
    }));

    const composeShipData = (ships, columns, sortData, tokenPrices) => {
        const rows = [];
        const conversion = (tokenPrices && tokenPrices['ATLAS/USDC']) || 0;

        for (const ship of ships) {
            const { airdrops, id, image, name, attributes, symbol, primarySales, prices, tradeSettings } = ship;
            const { askATLAS, askUSDC, bidATLAS, bidUSDC } = prices || dummyObject;
            const { rarity, spec, class: shipClass } = attributes;
            const { vwap } = tradeSettings;

            const diff = !askUSDC ? 0 : (Number(askUSDC) - vwap)/vwap;      

            const askAtlasEq = Number(askATLAS) * conversion;
            const bidAtlasEq = Number(bidATLAS) * conversion;

            const imageName = ship.image ?  ship.image.split('/').pop() : '';
            const imageURL = assets.images['thumb-220'][imageName] 
                ? ('images/thumb-220/' + imageName) 
                : ship.image;

            let supply = 0;
            for (const drop of airdrops) {
                supply += drop.supply;
            }
            for (const sale of primarySales) {
                supply += sale.supply;
            }

            rows.push({
                id,
                image,
                imageURL,
                name, 
                symbol, 
                askATLAS,
                askAtlasEq,
                bidATLAS,
                bidAtlasEq,
                askUSDC, 
                bidUSDC, 
                vwap, 
                diff,
                aprVWAP: calc.apr('VWAP', ship, tokenPrices),
                aprAskUSDC: calc.apr('askUSDC', ship, tokenPrices),
                spec: spec.toLowerCase(), 
                shipClass: shipClass.toLowerCase(), 
                supply,
                rarity: rarity.toLowerCase()
            });
        }

        for (const sortField of Object.keys(sortData)) {
            if (sortData[sortField] === DESCEND) {
                rows.sort(sortBy(sortField, CUSTOM_SORTS[sortField])).reverse();
            } else if (sortData[sortField] === ASCEND) {
                rows.sort(sortBy(sortField, CUSTOM_SORTS[sortField]));
            }
        }

        return rows;
    };

    const buildSortData = () => {
        const delivery = {};
        for (const column of columnSettings) {
            delivery[column.dataName] = '';
        }
        return delivery;
    };

    /* src\components\meta-tags-2.svelte generated by Svelte v3.46.3 */

    const file$6 = "src\\components\\meta-tags-2.svelte";

    // (10:0) {#if ship}
    function create_if_block$3(ctx) {
    	let div;
    	let span0;
    	let t0_value = /*ship*/ ctx[2].spec + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2_value = /*ship*/ ctx[2].shipClass + "";
    	let t2;
    	let t3;
    	let div_class_value;
    	let if_block = /*includeSymbol*/ ctx[0] && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			attr_dev(span0, "class", "capitalize svelte-1pw61jn");
    			add_location(span0, file$6, 11, 8, 279);
    			attr_dev(span1, "class", "subtitle svelte-1pw61jn");
    			add_location(span1, file$6, 12, 8, 332);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*metaClass*/ ctx[3]) + " svelte-1pw61jn"));
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			add_location(div, file$6, 10, 4, 232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(span0, t0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			append_dev(div, t3);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ship*/ 4 && t0_value !== (t0_value = /*ship*/ ctx[2].spec + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*ship*/ 4 && t2_value !== (t2_value = /*ship*/ ctx[2].shipClass + "")) set_data_dev(t2, t2_value);

    			if (/*includeSymbol*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*metaClass*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*metaClass*/ ctx[3]) + " svelte-1pw61jn"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(10:0) {#if ship}",
    		ctx
    	});

    	return block;
    }

    // (14:8) {#if includeSymbol}
    function create_if_block_1$2(ctx) {
    	let span;
    	let t0;
    	let t1_value = /*ship*/ ctx[2].symbol + "";
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("Symbol: ");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "ship-symbol svelte-1pw61jn");
    			add_location(span, file$6, 13, 27, 407);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*ship*/ 4 && t1_value !== (t1_value = /*ship*/ ctx[2].symbol + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(14:8) {#if includeSymbol}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let if_block_anchor;
    	let if_block = /*ship*/ ctx[2] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*ship*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let metaClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Meta_tags_2', slots, []);
    	let { includeSymbol = false } = $$props;
    	let { style = '' } = $$props;
    	let { className = '' } = $$props;
    	let { ship } = $$props;
    	const writable_props = ['includeSymbol', 'style', 'className', 'ship'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Meta_tags_2> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('includeSymbol' in $$props) $$invalidate(0, includeSymbol = $$props.includeSymbol);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('ship' in $$props) $$invalidate(2, ship = $$props.ship);
    	};

    	$$self.$capture_state = () => ({
    		includeSymbol,
    		style,
    		className,
    		ship,
    		metaClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('includeSymbol' in $$props) $$invalidate(0, includeSymbol = $$props.includeSymbol);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('ship' in $$props) $$invalidate(2, ship = $$props.ship);
    		if ('metaClass' in $$props) $$invalidate(3, metaClass = $$props.metaClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 16) {
    			$$invalidate(3, metaClass = 'ship-meta' + (className ? ' ' + className : ''));
    		}
    	};

    	return [includeSymbol, style, ship, metaClass, className];
    }

    class Meta_tags_2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			includeSymbol: 0,
    			style: 1,
    			className: 4,
    			ship: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Meta_tags_2",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ship*/ ctx[2] === undefined && !('ship' in props)) {
    			console.warn("<Meta_tags_2> was created without expected prop 'ship'");
    		}
    	}

    	get includeSymbol() {
    		throw new Error("<Meta_tags_2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set includeSymbol(value) {
    		throw new Error("<Meta_tags_2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Meta_tags_2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Meta_tags_2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Meta_tags_2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Meta_tags_2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ship() {
    		throw new Error("<Meta_tags_2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ship(value) {
    		throw new Error("<Meta_tags_2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Price-ask-bid-2.svelte generated by Svelte v3.46.3 */
    const file$5 = "src\\components\\Price-ask-bid-2.svelte";

    function create_fragment$5(ctx) {
    	let div;
    	let cellaskbid0;
    	let t;
    	let cellaskbid1;
    	let div_class_value;
    	let current;

    	cellaskbid0 = new Cell_ask_bid({
    			props: {
    				row: { data: /*ship*/ ctx[0] },
    				customClass: "ship-card",
    				column: /*columnAskATLAS*/ ctx[2]
    			},
    			$$inline: true
    		});

    	cellaskbid1 = new Cell_ask_bid({
    			props: {
    				row: { data: /*ship*/ ctx[0] },
    				customClass: "ship-card",
    				column: /*columnAskUSDC*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(cellaskbid0.$$.fragment);
    			t = space();
    			create_component(cellaskbid1.$$.fragment);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*priceClass*/ ctx[1]) + " svelte-l0wbob"));
    			add_location(div, file$5, 11, 0, 398);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(cellaskbid0, div, null);
    			append_dev(div, t);
    			mount_component(cellaskbid1, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const cellaskbid0_changes = {};
    			if (dirty & /*ship*/ 1) cellaskbid0_changes.row = { data: /*ship*/ ctx[0] };
    			cellaskbid0.$set(cellaskbid0_changes);
    			const cellaskbid1_changes = {};
    			if (dirty & /*ship*/ 1) cellaskbid1_changes.row = { data: /*ship*/ ctx[0] };
    			cellaskbid1.$set(cellaskbid1_changes);

    			if (!current || dirty & /*priceClass*/ 2 && div_class_value !== (div_class_value = "" + (null_to_empty(/*priceClass*/ ctx[1]) + " svelte-l0wbob"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cellaskbid0.$$.fragment, local);
    			transition_in(cellaskbid1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cellaskbid0.$$.fragment, local);
    			transition_out(cellaskbid1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(cellaskbid0);
    			destroy_component(cellaskbid1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Price_ask_bid_2', slots, []);
    	const columnAskATLAS = columnSettings.find(column => column.dataName === 'askATLAS');
    	const columnAskUSDC = columnSettings.find(column => column.dataName === 'askUSDC');
    	let { ship } = $$props;
    	let { priceClass = 'price-ask-bid' } = $$props;
    	const writable_props = ['ship', 'priceClass'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Price_ask_bid_2> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ship' in $$props) $$invalidate(0, ship = $$props.ship);
    		if ('priceClass' in $$props) $$invalidate(1, priceClass = $$props.priceClass);
    	};

    	$$self.$capture_state = () => ({
    		columnSettings,
    		CellAskBid: Cell_ask_bid,
    		columnAskATLAS,
    		columnAskUSDC,
    		ship,
    		priceClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('ship' in $$props) $$invalidate(0, ship = $$props.ship);
    		if ('priceClass' in $$props) $$invalidate(1, priceClass = $$props.priceClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ship, priceClass, columnAskATLAS, columnAskUSDC];
    }

    class Price_ask_bid_2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { ship: 0, priceClass: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Price_ask_bid_2",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ship*/ ctx[0] === undefined && !('ship' in props)) {
    			console.warn("<Price_ask_bid_2> was created without expected prop 'ship'");
    		}
    	}

    	get ship() {
    		throw new Error("<Price_ask_bid_2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ship(value) {
    		throw new Error("<Price_ask_bid_2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get priceClass() {
    		throw new Error("<Price_ask_bid_2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set priceClass(value) {
    		throw new Error("<Price_ask_bid_2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Ship-card-2.svelte generated by Svelte v3.46.3 */
    const file$4 = "src\\components\\Ship-card-2.svelte";

    function create_fragment$4(ctx) {
    	let li;
    	let div1;
    	let div0;
    	let t0_value = /*ship*/ ctx[0].name + "";
    	let t0;
    	let t1;
    	let metatags;
    	let t2;
    	let div3;
    	let div2;
    	let div2_style_value;
    	let t3;
    	let priceaskbid;
    	let t4;
    	let div9;
    	let div4;
    	let cellbasic0;
    	let t5;
    	let cellbasic1;
    	let t6;
    	let cellbasic2;
    	let t7;
    	let div8;
    	let div5;
    	let t9;
    	let div6;
    	let t11;
    	let div7;
    	let current;
    	let mounted;
    	let dispose;

    	metatags = new Meta_tags_2({
    			props: {
    				ship: /*ship*/ ctx[0],
    				style: "margin-top: -6px;"
    			},
    			$$inline: true
    		});

    	priceaskbid = new Price_ask_bid_2({
    			props: {
    				ship: /*ship*/ ctx[0],
    				priceClass: "right-column"
    			},
    			$$inline: true
    		});

    	cellbasic0 = new Cell_basic({
    			props: {
    				column: /*columnAprAsk*/ ctx[2],
    				row: { data: /*ship*/ ctx[0] },
    				customClass: "ship-card narrow"
    			},
    			$$inline: true
    		});

    	cellbasic1 = new Cell_basic({
    			props: {
    				column: /*columnAprRetail*/ ctx[3],
    				row: { data: /*ship*/ ctx[0] },
    				customClass: "ship-card narrow"
    			},
    			$$inline: true
    		});

    	cellbasic2 = new Cell_basic({
    			props: {
    				column: /*columnDiff*/ ctx[1],
    				row: { data: /*ship*/ ctx[0] },
    				customClass: "ship-card"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(metatags.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");
    			t3 = space();
    			create_component(priceaskbid.$$.fragment);
    			t4 = space();
    			div9 = element("div");
    			div4 = element("div");
    			create_component(cellbasic0.$$.fragment);
    			t5 = space();
    			create_component(cellbasic1.$$.fragment);
    			t6 = space();
    			create_component(cellbasic2.$$.fragment);
    			t7 = space();
    			div8 = element("div");
    			div5 = element("div");
    			div5.textContent = "APR Ask";
    			t9 = space();
    			div6 = element("div");
    			div6.textContent = "APR Retail";
    			t11 = space();
    			div7 = element("div");
    			div7.textContent = "Ask vs Retail";
    			attr_dev(div0, "class", "ship-name svelte-10yjrmv");
    			add_location(div0, file$4, 22, 8, 907);
    			attr_dev(div1, "class", "header-bar svelte-10yjrmv");
    			add_location(div1, file$4, 21, 4, 873);
    			attr_dev(div2, "class", "ship-image svelte-10yjrmv");
    			attr_dev(div2, "style", div2_style_value = 'background-image: url("' + /*ship*/ ctx[0].imageURL + '");');
    			add_location(div2, file$4, 28, 8, 1106);
    			attr_dev(div3, "class", "card-body svelte-10yjrmv");
    			add_location(div3, file$4, 27, 4, 1073);
    			attr_dev(div4, "class", "footer-row svelte-10yjrmv");
    			add_location(div4, file$4, 33, 8, 1348);
    			attr_dev(div5, "class", "label diff narrow svelte-10yjrmv");
    			add_location(div5, file$4, 39, 12, 1731);
    			attr_dev(div6, "class", "label diff narrow svelte-10yjrmv");
    			add_location(div6, file$4, 40, 12, 1789);
    			attr_dev(div7, "class", "label diff svelte-10yjrmv");
    			add_location(div7, file$4, 41, 12, 1850);
    			attr_dev(div8, "class", "footer-row svelte-10yjrmv");
    			add_location(div8, file$4, 38, 12, 1693);
    			attr_dev(div9, "class", "card-footer svelte-10yjrmv");
    			add_location(div9, file$4, 32, 4, 1313);
    			attr_dev(li, "class", "ship-data svelte-10yjrmv");
    			add_location(li, file$4, 20, 0, 845);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			mount_component(metatags, div1, null);
    			append_dev(li, t2);
    			append_dev(li, div3);
    			append_dev(div3, div2);
    			append_dev(div3, t3);
    			mount_component(priceaskbid, div3, null);
    			append_dev(li, t4);
    			append_dev(li, div9);
    			append_dev(div9, div4);
    			mount_component(cellbasic0, div4, null);
    			append_dev(div4, t5);
    			mount_component(cellbasic1, div4, null);
    			append_dev(div4, t6);
    			mount_component(cellbasic2, div4, null);
    			append_dev(div9, t7);
    			append_dev(div9, div8);
    			append_dev(div8, div5);
    			append_dev(div8, t9);
    			append_dev(div8, div6);
    			append_dev(div8, t11);
    			append_dev(div8, div7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*clickHandler*/ ctx[4], false, false, false),
    					listen_dev(div2, "click", /*clickHandler*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*ship*/ 1) && t0_value !== (t0_value = /*ship*/ ctx[0].name + "")) set_data_dev(t0, t0_value);
    			const metatags_changes = {};
    			if (dirty & /*ship*/ 1) metatags_changes.ship = /*ship*/ ctx[0];
    			metatags.$set(metatags_changes);

    			if (!current || dirty & /*ship*/ 1 && div2_style_value !== (div2_style_value = 'background-image: url("' + /*ship*/ ctx[0].imageURL + '");')) {
    				attr_dev(div2, "style", div2_style_value);
    			}

    			const priceaskbid_changes = {};
    			if (dirty & /*ship*/ 1) priceaskbid_changes.ship = /*ship*/ ctx[0];
    			priceaskbid.$set(priceaskbid_changes);
    			const cellbasic0_changes = {};
    			if (dirty & /*ship*/ 1) cellbasic0_changes.row = { data: /*ship*/ ctx[0] };
    			cellbasic0.$set(cellbasic0_changes);
    			const cellbasic1_changes = {};
    			if (dirty & /*ship*/ 1) cellbasic1_changes.row = { data: /*ship*/ ctx[0] };
    			cellbasic1.$set(cellbasic1_changes);
    			const cellbasic2_changes = {};
    			if (dirty & /*ship*/ 1) cellbasic2_changes.row = { data: /*ship*/ ctx[0] };
    			cellbasic2.$set(cellbasic2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(metatags.$$.fragment, local);
    			transition_in(priceaskbid.$$.fragment, local);
    			transition_in(cellbasic0.$$.fragment, local);
    			transition_in(cellbasic1.$$.fragment, local);
    			transition_in(cellbasic2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(metatags.$$.fragment, local);
    			transition_out(priceaskbid.$$.fragment, local);
    			transition_out(cellbasic0.$$.fragment, local);
    			transition_out(cellbasic1.$$.fragment, local);
    			transition_out(cellbasic2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(metatags);
    			destroy_component(priceaskbid);
    			destroy_component(cellbasic0);
    			destroy_component(cellbasic1);
    			destroy_component(cellbasic2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ship_card_2', slots, []);
    	let { ship } = $$props;
    	const columnDiff = columnSettings.find(column => column.dataName === 'diff');
    	const columnAprAsk = columnSettings.find(column => column.dataName === 'aprAskUSDC');
    	const columnAprRetail = columnSettings.find(column => column.dataName === 'aprVWAP');

    	const clickHandler = () => {
    		modalStatus.set(bind(Feature_ship, { message: ship.id }));
    	};

    	const writable_props = ['ship'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Ship_card_2> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('ship' in $$props) $$invalidate(0, ship = $$props.ship);
    	};

    	$$self.$capture_state = () => ({
    		bind,
    		modalStatus,
    		columnSettings,
    		MetaTags: Meta_tags_2,
    		FeatureShip: Feature_ship,
    		PriceAskBid: Price_ask_bid_2,
    		CellBasic: Cell_basic,
    		ship,
    		columnDiff,
    		columnAprAsk,
    		columnAprRetail,
    		clickHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ('ship' in $$props) $$invalidate(0, ship = $$props.ship);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ship, columnDiff, columnAprAsk, columnAprRetail, clickHandler];
    }

    class Ship_card_2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { ship: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ship_card_2",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ship*/ ctx[0] === undefined && !('ship' in props)) {
    			console.warn("<Ship_card_2> was created without expected prop 'ship'");
    		}
    	}

    	get ship() {
    		throw new Error("<Ship_card_2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ship(value) {
    		throw new Error("<Ship_card_2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\layouts\Ships-grid.svelte generated by Svelte v3.46.3 */
    const file$3 = "src\\layouts\\Ships-grid.svelte";

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (21:0) {:else}
    function create_else_block$1(ctx) {
    	let div1;
    	let div0;
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value_1 = /*gridData*/ ctx[1];
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*ship*/ ctx[5].id;
    	validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "list-grid svelte-1vd75v5");
    			add_location(ul, file$3, 23, 12, 729);
    			attr_dev(div0, "class", "grid-column svelte-1vd75v5");
    			add_location(div0, file$3, 22, 8, 690);
    			attr_dev(div1, "class", "grid-frame svelte-1vd75v5");
    			add_location(div1, file$3, 21, 4, 656);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*gridData*/ 2) {
    				each_value_1 = /*gridData*/ ctx[1];
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(21:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (15:0) {#if contained}
    function create_if_block$2(ctx) {
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*gridData*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*ship*/ ctx[5].id;
    	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "list-grid svelte-1vd75v5");
    			add_location(ul, file$3, 15, 4, 509);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*gridData*/ 2) {
    				each_value = /*gridData*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(15:0) {#if contained}",
    		ctx
    	});

    	return block;
    }

    // (25:16) {#each gridData as ship (ship.id)}
    function create_each_block_1$1(key_1, ctx) {
    	let first;
    	let shipcard;
    	let current;

    	shipcard = new Ship_card_2({
    			props: { ship: /*ship*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(shipcard.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(shipcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const shipcard_changes = {};
    			if (dirty & /*gridData*/ 2) shipcard_changes.ship = /*ship*/ ctx[5];
    			shipcard.$set(shipcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shipcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shipcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(shipcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(25:16) {#each gridData as ship (ship.id)}",
    		ctx
    	});

    	return block;
    }

    // (17:8) {#each gridData as ship (ship.id)}
    function create_each_block$1(key_1, ctx) {
    	let first;
    	let shipcard;
    	let current;

    	shipcard = new Ship_card_2({
    			props: { ship: /*ship*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(shipcard.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(shipcard, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const shipcard_changes = {};
    			if (dirty & /*gridData*/ 2) shipcard_changes.ship = /*ship*/ ctx[5];
    			shipcard.$set(shipcard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shipcard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shipcard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(shipcard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(17:8) {#each gridData as ship (ship.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*contained*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let gridData;
    	let $tokenPrices;
    	let $ships;
    	validate_store(tokenPrices, 'tokenPrices');
    	component_subscribe($$self, tokenPrices, $$value => $$invalidate(2, $tokenPrices = $$value));
    	validate_store(ships, 'ships');
    	component_subscribe($$self, ships, $$value => $$invalidate(3, $ships = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ships_grid', slots, []);
    	let { contained = false } = $$props;
    	const sortData = buildSortData();
    	const writable_props = ['contained'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Ships_grid> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('contained' in $$props) $$invalidate(0, contained = $$props.contained);
    	};

    	$$self.$capture_state = () => ({
    		ShipCard: Ship_card_2,
    		ships,
    		tokenPrices,
    		buildSortData,
    		composeShipData,
    		contained,
    		sortData,
    		gridData,
    		$tokenPrices,
    		$ships
    	});

    	$$self.$inject_state = $$props => {
    		if ('contained' in $$props) $$invalidate(0, contained = $$props.contained);
    		if ('gridData' in $$props) $$invalidate(1, gridData = $$props.gridData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$ships, $tokenPrices*/ 12) {
    			$$invalidate(1, gridData = composeShipData($ships, null, sortData, $tokenPrices)); /*columns */
    		}
    	};

    	return [contained, gridData, $tokenPrices, $ships];
    }

    class Ships_grid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { contained: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ships_grid",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get contained() {
    		throw new Error("<Ships_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contained(value) {
    		throw new Error("<Ships_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var deepDiff = createCommonjsModule(function (module, exports) {
    (function(root, factory) { // eslint-disable-line no-extra-semi
      var deepDiff = factory(root);
      // eslint-disable-next-line no-undef
      {
          // Node.js or ReactNative
          module.exports = deepDiff;
      }
    }(commonjsGlobal, function(root) {
      var validKinds = ['N', 'E', 'A', 'D'];

      // nodejs compatible on server side and in the browser.
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }

      function Diff(kind, path) {
        Object.defineProperty(this, 'kind', {
          value: kind,
          enumerable: true
        });
        if (path && path.length) {
          Object.defineProperty(this, 'path', {
            value: path,
            enumerable: true
          });
        }
      }

      function DiffEdit(path, origin, value) {
        DiffEdit.super_.call(this, 'E', path);
        Object.defineProperty(this, 'lhs', {
          value: origin,
          enumerable: true
        });
        Object.defineProperty(this, 'rhs', {
          value: value,
          enumerable: true
        });
      }
      inherits(DiffEdit, Diff);

      function DiffNew(path, value) {
        DiffNew.super_.call(this, 'N', path);
        Object.defineProperty(this, 'rhs', {
          value: value,
          enumerable: true
        });
      }
      inherits(DiffNew, Diff);

      function DiffDeleted(path, value) {
        DiffDeleted.super_.call(this, 'D', path);
        Object.defineProperty(this, 'lhs', {
          value: value,
          enumerable: true
        });
      }
      inherits(DiffDeleted, Diff);

      function DiffArray(path, index, item) {
        DiffArray.super_.call(this, 'A', path);
        Object.defineProperty(this, 'index', {
          value: index,
          enumerable: true
        });
        Object.defineProperty(this, 'item', {
          value: item,
          enumerable: true
        });
      }
      inherits(DiffArray, Diff);

      function arrayRemove(arr, from, to) {
        var rest = arr.slice((to || from) + 1 || arr.length);
        arr.length = from < 0 ? arr.length + from : from;
        arr.push.apply(arr, rest);
        return arr;
      }

      function realTypeOf(subject) {
        var type = typeof subject;
        if (type !== 'object') {
          return type;
        }

        if (subject === Math) {
          return 'math';
        } else if (subject === null) {
          return 'null';
        } else if (Array.isArray(subject)) {
          return 'array';
        } else if (Object.prototype.toString.call(subject) === '[object Date]') {
          return 'date';
        } else if (typeof subject.toString === 'function' && /^\/.*\//.test(subject.toString())) {
          return 'regexp';
        }
        return 'object';
      }

      // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
      function hashThisString(string) {
        var hash = 0;
        if (string.length === 0) { return hash; }
        for (var i = 0; i < string.length; i++) {
          var char = string.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
      }

      // Gets a hash of the given object in an array order-independent fashion
      // also object key order independent (easier since they can be alphabetized)
      function getOrderIndependentHash(object) {
        var accum = 0;
        var type = realTypeOf(object);

        if (type === 'array') {
          object.forEach(function (item) {
            // Addition is commutative so this is order indep
            accum += getOrderIndependentHash(item);
          });

          var arrayString = '[type: array, hash: ' + accum + ']';
          return accum + hashThisString(arrayString);
        }

        if (type === 'object') {
          for (var key in object) {
            if (object.hasOwnProperty(key)) {
              var keyValueString = '[ type: object, key: ' + key + ', value hash: ' + getOrderIndependentHash(object[key]) + ']';
              accum += hashThisString(keyValueString);
            }
          }

          return accum;
        }

        // Non object, non array...should be good?
        var stringToHash = '[ type: ' + type + ' ; value: ' + object + ']';
        return accum + hashThisString(stringToHash);
      }

      function deepDiff(lhs, rhs, changes, prefilter, path, key, stack, orderIndependent) {
        changes = changes || [];
        path = path || [];
        stack = stack || [];
        var currentPath = path.slice(0);
        if (typeof key !== 'undefined' && key !== null) {
          if (prefilter) {
            if (typeof (prefilter) === 'function' && prefilter(currentPath, key)) {
              return;
            } else if (typeof (prefilter) === 'object') {
              if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) {
                return;
              }
              if (prefilter.normalize) {
                var alt = prefilter.normalize(currentPath, key, lhs, rhs);
                if (alt) {
                  lhs = alt[0];
                  rhs = alt[1];
                }
              }
            }
          }
          currentPath.push(key);
        }

        // Use string comparison for regexes
        if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
          lhs = lhs.toString();
          rhs = rhs.toString();
        }

        var ltype = typeof lhs;
        var rtype = typeof rhs;
        var i, j, k, other;

        var ldefined = ltype !== 'undefined' ||
          (stack && (stack.length > 0) && stack[stack.length - 1].lhs &&
            Object.getOwnPropertyDescriptor(stack[stack.length - 1].lhs, key));
        var rdefined = rtype !== 'undefined' ||
          (stack && (stack.length > 0) && stack[stack.length - 1].rhs &&
            Object.getOwnPropertyDescriptor(stack[stack.length - 1].rhs, key));

        if (!ldefined && rdefined) {
          changes.push(new DiffNew(currentPath, rhs));
        } else if (!rdefined && ldefined) {
          changes.push(new DiffDeleted(currentPath, lhs));
        } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
          changes.push(new DiffEdit(currentPath, lhs, rhs));
        } else if (realTypeOf(lhs) === 'date' && (lhs - rhs) !== 0) {
          changes.push(new DiffEdit(currentPath, lhs, rhs));
        } else if (ltype === 'object' && lhs !== null && rhs !== null) {
          for (i = stack.length - 1; i > -1; --i) {
            if (stack[i].lhs === lhs) {
              other = true;
              break;
            }
          }
          if (!other) {
            stack.push({ lhs: lhs, rhs: rhs });
            if (Array.isArray(lhs)) {
              // If order doesn't matter, we need to sort our arrays
              if (orderIndependent) {
                lhs.sort(function (a, b) {
                  return getOrderIndependentHash(a) - getOrderIndependentHash(b);
                });

                rhs.sort(function (a, b) {
                  return getOrderIndependentHash(a) - getOrderIndependentHash(b);
                });
              }
              i = rhs.length - 1;
              j = lhs.length - 1;
              while (i > j) {
                changes.push(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i--])));
              }
              while (j > i) {
                changes.push(new DiffArray(currentPath, j, new DiffDeleted(undefined, lhs[j--])));
              }
              for (; i >= 0; --i) {
                deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack, orderIndependent);
              }
            } else {
              var akeys = Object.keys(lhs);
              var pkeys = Object.keys(rhs);
              for (i = 0; i < akeys.length; ++i) {
                k = akeys[i];
                other = pkeys.indexOf(k);
                if (other >= 0) {
                  deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
                  pkeys[other] = null;
                } else {
                  deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack, orderIndependent);
                }
              }
              for (i = 0; i < pkeys.length; ++i) {
                k = pkeys[i];
                if (k) {
                  deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
                }
              }
            }
            stack.length = stack.length - 1;
          } else if (lhs !== rhs) {
            // lhs is contains a cycle at this element and it differs from rhs
            changes.push(new DiffEdit(currentPath, lhs, rhs));
          }
        } else if (lhs !== rhs) {
          if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
            changes.push(new DiffEdit(currentPath, lhs, rhs));
          }
        }
      }

      function observableDiff(lhs, rhs, observer, prefilter, orderIndependent) {
        var changes = [];
        deepDiff(lhs, rhs, changes, prefilter, null, null, null, orderIndependent);
        if (observer) {
          for (var i = 0; i < changes.length; ++i) {
            observer(changes[i]);
          }
        }
        return changes;
      }

      function orderIndependentDeepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
        return deepDiff(lhs, rhs, changes, prefilter, path, key, stack, true);
      }

      function accumulateDiff(lhs, rhs, prefilter, accum) {
        var observer = (accum) ?
          function (difference) {
            if (difference) {
              accum.push(difference);
            }
          } : undefined;
        var changes = observableDiff(lhs, rhs, observer, prefilter);
        return (accum) ? accum : (changes.length) ? changes : undefined;
      }

      function accumulateOrderIndependentDiff(lhs, rhs, prefilter, accum) {
        var observer = (accum) ?
          function (difference) {
            if (difference) {
              accum.push(difference);
            }
          } : undefined;
        var changes = observableDiff(lhs, rhs, observer, prefilter, true);
        return (accum) ? accum : (changes.length) ? changes : undefined;
      }

      function applyArrayChange(arr, index, change) {
        if (change.path && change.path.length) {
          var it = arr[index],
            i, u = change.path.length - 1;
          for (i = 0; i < u; i++) {
            it = it[change.path[i]];
          }
          switch (change.kind) {
            case 'A':
              applyArrayChange(it[change.path[i]], change.index, change.item);
              break;
            case 'D':
              delete it[change.path[i]];
              break;
            case 'E':
            case 'N':
              it[change.path[i]] = change.rhs;
              break;
          }
        } else {
          switch (change.kind) {
            case 'A':
              applyArrayChange(arr[index], change.index, change.item);
              break;
            case 'D':
              arr = arrayRemove(arr, index);
              break;
            case 'E':
            case 'N':
              arr[index] = change.rhs;
              break;
          }
        }
        return arr;
      }

      function applyChange(target, source, change) {
        if (typeof change === 'undefined' && source && ~validKinds.indexOf(source.kind)) {
          change = source;
        }
        if (target && change && change.kind) {
          var it = target,
            i = -1,
            last = change.path ? change.path.length - 1 : 0;
          while (++i < last) {
            if (typeof it[change.path[i]] === 'undefined') {
              it[change.path[i]] = (typeof change.path[i + 1] !== 'undefined' && typeof change.path[i + 1] === 'number') ? [] : {};
            }
            it = it[change.path[i]];
          }
          switch (change.kind) {
            case 'A':
              if (change.path && typeof it[change.path[i]] === 'undefined') {
                it[change.path[i]] = [];
              }
              applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
              break;
            case 'D':
              delete it[change.path[i]];
              break;
            case 'E':
            case 'N':
              it[change.path[i]] = change.rhs;
              break;
          }
        }
      }

      function revertArrayChange(arr, index, change) {
        if (change.path && change.path.length) {
          // the structure of the object at the index has changed...
          var it = arr[index],
            i, u = change.path.length - 1;
          for (i = 0; i < u; i++) {
            it = it[change.path[i]];
          }
          switch (change.kind) {
            case 'A':
              revertArrayChange(it[change.path[i]], change.index, change.item);
              break;
            case 'D':
              it[change.path[i]] = change.lhs;
              break;
            case 'E':
              it[change.path[i]] = change.lhs;
              break;
            case 'N':
              delete it[change.path[i]];
              break;
          }
        } else {
          // the array item is different...
          switch (change.kind) {
            case 'A':
              revertArrayChange(arr[index], change.index, change.item);
              break;
            case 'D':
              arr[index] = change.lhs;
              break;
            case 'E':
              arr[index] = change.lhs;
              break;
            case 'N':
              arr = arrayRemove(arr, index);
              break;
          }
        }
        return arr;
      }

      function revertChange(target, source, change) {
        if (target && source && change && change.kind) {
          var it = target,
            i, u;
          u = change.path.length - 1;
          for (i = 0; i < u; i++) {
            if (typeof it[change.path[i]] === 'undefined') {
              it[change.path[i]] = {};
            }
            it = it[change.path[i]];
          }
          switch (change.kind) {
            case 'A':
              // Array was modified...
              // it will be an array...
              revertArrayChange(it[change.path[i]], change.index, change.item);
              break;
            case 'D':
              // Item was deleted...
              it[change.path[i]] = change.lhs;
              break;
            case 'E':
              // Item was edited...
              it[change.path[i]] = change.lhs;
              break;
            case 'N':
              // Item is new...
              delete it[change.path[i]];
              break;
          }
        }
      }

      function applyDiff(target, source, filter) {
        if (target && source) {
          var onChange = function (change) {
            if (!filter || filter(target, source, change)) {
              applyChange(target, source, change);
            }
          };
          observableDiff(target, source, onChange);
        }
      }

      Object.defineProperties(accumulateDiff, {

        diff: {
          value: accumulateDiff,
          enumerable: true
        },
        orderIndependentDiff: {
          value: accumulateOrderIndependentDiff,
          enumerable: true
        },
        observableDiff: {
          value: observableDiff,
          enumerable: true
        },
        orderIndependentObservableDiff: {
          value: orderIndependentDeepDiff,
          enumerable: true
        },
        orderIndepHash: {
          value: getOrderIndependentHash,
          enumerable: true
        },
        applyDiff: {
          value: applyDiff,
          enumerable: true
        },
        applyChange: {
          value: applyChange,
          enumerable: true
        },
        revertChange: {
          value: revertChange,
          enumerable: true
        },
        isConflict: {
          value: function () {
            return typeof $conflict !== 'undefined';
          },
          enumerable: true
        }
      });

      // hackish...
      accumulateDiff.DeepDiff = accumulateDiff;
      // ...but works with:
      // import DeepDiff from 'deep-diff'
      // import { DeepDiff } from 'deep-diff'
      // const DeepDiff = require('deep-diff');
      // const { DeepDiff } = require('deep-diff');

      if (root) {
        root.DeepDiff = accumulateDiff;
      }

      return accumulateDiff;
    }));
    });

    const applyChange = deepDiff.applyChange;
    const diff = deepDiff.diff;
    /**
     * Edit history tracker for a javascript object using deep-diff to generate and apply patches
     */
    class EditHistory {
      /**
       * Instantiates an instance of EditHistory
       * @param {Object} obj The object or array to track
       */
      constructor(obj) {
        this.obj = JSON.parse(JSON.stringify(obj));

        // initialize arrays for forwards and backwards patches
        this.forward = [];
        this.backward = [];
      }

      /**
       * Clears all forward and backward patches
       */
      clear() {
        this.forward = [];
        this.backward = [];
      }

      /**
       * Records a change to an object
       * @param {Object} newObj The new object
       */
      recordChange(newObj) {
        const patch = {
          redo: diff(this.obj, newObj),
          undo: diff(newObj, this.obj)
        };

        if (!patch.redo || !patch.undo) {
          console.warn("Objects could not be diffed");
        } else {
          this.obj = JSON.parse(JSON.stringify(newObj));
          this.backward.push(patch);
        }
      }

      /**
       * Applies the most recent undo patch and returns the new object
       * @returns {Object} The tracked object
       */
      undo() {
        if (this.backward.length === 0) {
          return null;
        }

        // grab the most recent backwards patch
        const patch = this.backward.pop();

        // applyChange doesn't accept arrays, only its members
        patch.undo.forEach(x => applyChange(this.obj, x));

        // put the patch into the forward queue
        this.forward.push(patch);

        return JSON.parse(JSON.stringify(this.obj));
      }

      /**
       * Applies the most recent redo patch and returns the new object
       * @returns {Object} The tracked object
       */
      redo() {
        if (this.forward.length === 0) {
          return null;
        }

        // grab the most recent forwards patch
        const patch = this.forward.pop();

        // applyChange doesn't accept arrays, only its members
        patch.redo.forEach(x => applyChange(this.obj, x));

        // put the patch into the backward queue
        this.backward.push(patch);

        return JSON.parse(JSON.stringify(this.obj));
      }

      /**
       * Applies all the undo patches in the queue and returns the new object
       * @returns {Object} The tracked object
       */
      undoAll() {
        while (this.backward.length > 0) {
          this.undo();
        }

        return this.obj;
      }

      /**
       * Applies all the redo patches in the queue and returns the new object
       * @returns {Object} The tracked object
       */
      redoAll() {
        while (this.forward.length > 0) {
          this.redo();
        }

        return this.obj;
      }
    }

    /* src\lib\svelte-data-grid\svelte-data-grid.svelte generated by Svelte v3.46.3 */

    const { console: console_1, window: window_1 } = globals;
    const file$2 = "src\\lib\\svelte-data-grid\\svelte-data-grid.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[75] = list[i];
    	child_ctx[77] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[78] = list[i];
    	child_ctx[80] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[78] = list[i];
    	child_ctx[77] = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[78] = list[i];
    	child_ctx[77] = i;
    	return child_ctx;
    }

    // (855:2) {#if __resizing || __columnDragging || __affixingColumn}
    function create_if_block_7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "column-action-line svelte-15j5yeo");
    			set_style(div, "left", /*__columnActionLineLeft*/ ctx[8] - 2 + "px");
    			add_location(div, file$2, 855, 4, 24970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*__columnActionLineLeft*/ 256) {
    				set_style(div, "left", /*__columnActionLineLeft*/ ctx[8] - 2 + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(855:2) {#if __resizing || __columnDragging || __affixingColumn}",
    		ctx
    	});

    	return block;
    }

    // (860:2) {#if __affixingRow}
    function create_if_block_6(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "row-action-line svelte-15j5yeo");
    			set_style(div, "top", /*__rowActionLineTop*/ ctx[17] - 2 + "px");
    			add_location(div, file$2, 860, 4, 25102);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*__rowActionLineTop*/ 131072) {
    				set_style(div, "top", /*__rowActionLineTop*/ ctx[17] - 2 + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(860:2) {#if __affixingRow}",
    		ctx
    	});

    	return block;
    }

    // (885:10) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let t_value = (/*column*/ ctx[78].display || '') + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "cell-default svelte-15j5yeo");
    			add_location(div, file$2, 885, 12, 26473);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*columns*/ 1 && t_value !== (t_value = (/*column*/ ctx[78].display || '') + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(885:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (883:10) {#if column.headerComponent}
    function create_if_block_5(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*column*/ ctx[78].headerComponent;

    	function switch_props(ctx) {
    		return {
    			props: { column: /*column*/ ctx[78] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*columns*/ 1) switch_instance_changes.column = /*column*/ ctx[78];

    			if (switch_value !== (switch_value = /*column*/ ctx[78].headerComponent)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(883:10) {#if column.headerComponent}",
    		ctx
    	});

    	return block;
    }

    // (889:8) {#if allowResizeFromTableHeaders && !column.disallowResize}
    function create_if_block_4(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	function mousedown_handler_1(...args) {
    		return /*mousedown_handler_1*/ ctx[55](/*i*/ ctx[77], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "grid-cell-size-capture svelte-15j5yeo");

    			set_style(div, "left", getCellLeft({
    				i: /*i*/ ctx[77],
    				columnWidths: /*columnWidths*/ ctx[21],
    				__affixedColumnIndices: /*__affixedColumnIndices*/ ctx[1],
    				__scrollLeft: /*__scrollLeft*/ ctx[4]
    			}) + /*columnWidths*/ ctx[21][/*i*/ ctx[77]] - Math.floor(/*__columnHeaderResizeCaptureWidth*/ ctx[16] / 2) + "px");

    			set_style(div, "width", /*__columnHeaderResizeCaptureWidth*/ ctx[16] + "px");
    			add_location(div, file$2, 889, 10, 26641);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", mousedown_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*columns, columnWidths, __affixedColumnIndices, __scrollLeft, __columnHeaderResizeCaptureWidth*/ 2162707) {
    				set_style(div, "left", getCellLeft({
    					i: /*i*/ ctx[77],
    					columnWidths: /*columnWidths*/ ctx[21],
    					__affixedColumnIndices: /*__affixedColumnIndices*/ ctx[1],
    					__scrollLeft: /*__scrollLeft*/ ctx[4]
    				}) + /*columnWidths*/ ctx[21][/*i*/ ctx[77]] - Math.floor(/*__columnHeaderResizeCaptureWidth*/ ctx[16] / 2) + "px");
    			}

    			if (dirty[0] & /*__columnHeaderResizeCaptureWidth*/ 65536) {
    				set_style(div, "width", /*__columnHeaderResizeCaptureWidth*/ ctx[16] + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(889:8) {#if allowResizeFromTableHeaders && !column.disallowResize}",
    		ctx
    	});

    	return block;
    }

    // (873:6) {#each columns as column, i (i)}
    function create_each_block_3(key_1, ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block0;
    	let div_class_value;
    	let div_title_value;
    	let dragCopy_action;
    	let t;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_5, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*column*/ ctx[78].headerComponent) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function mousedown_handler(...args) {
    		return /*mousedown_handler*/ ctx[54](/*i*/ ctx[77], ...args);
    	}

    	let if_block1 = /*allowResizeFromTableHeaders*/ ctx[13] && !/*column*/ ctx[78].disallowResize && create_if_block_4(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div = element("div");
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty('grid-cell' + (/*column*/ ctx[78].parent ? ' parent' : '') + (/*column*/ ctx[78].child ? ' child' : '')) + " svelte-15j5yeo"));
    			set_style(div, "z-index", /*getCellZIndex*/ ctx[38](/*__affixedColumnIndices*/ ctx[1], /*i*/ ctx[77]));

    			set_style(div, "left", getCellLeft({
    				i: /*i*/ ctx[77],
    				columnWidths: /*columnWidths*/ ctx[21],
    				__affixedColumnIndices: /*__affixedColumnIndices*/ ctx[1],
    				__scrollLeft: /*__scrollLeft*/ ctx[4]
    			}) + "px");

    			set_style(div, "width", /*columnWidths*/ ctx[21][/*i*/ ctx[77]] + "px");
    			set_style(div, "height", /*headerHeight*/ ctx[11] + "px");
    			set_style(div, "line-height", /*headerHeight*/ ctx[11] + "px");
    			attr_dev(div, "title", div_title_value = /*column*/ ctx[78].display || '');
    			attr_dev(div, "role", "columnheader");
    			add_location(div, file$2, 873, 8, 25776);
    			this.first = div;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mousedown", mousedown_handler, false, false, false),
    					action_destroyer(dragCopy_action = dragCopy.call(null, div, /*allowColumnReordering*/ ctx[14]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div, null);
    			}

    			if (!current || dirty[0] & /*columns*/ 1 && div_class_value !== (div_class_value = "" + (null_to_empty('grid-cell' + (/*column*/ ctx[78].parent ? ' parent' : '') + (/*column*/ ctx[78].child ? ' child' : '')) + " svelte-15j5yeo"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty[0] & /*__affixedColumnIndices, columns*/ 3) {
    				set_style(div, "z-index", /*getCellZIndex*/ ctx[38](/*__affixedColumnIndices*/ ctx[1], /*i*/ ctx[77]));
    			}

    			if (!current || dirty[0] & /*columns, columnWidths, __affixedColumnIndices, __scrollLeft*/ 2097171) {
    				set_style(div, "left", getCellLeft({
    					i: /*i*/ ctx[77],
    					columnWidths: /*columnWidths*/ ctx[21],
    					__affixedColumnIndices: /*__affixedColumnIndices*/ ctx[1],
    					__scrollLeft: /*__scrollLeft*/ ctx[4]
    				}) + "px");
    			}

    			if (!current || dirty[0] & /*columnWidths, columns*/ 2097153) {
    				set_style(div, "width", /*columnWidths*/ ctx[21][/*i*/ ctx[77]] + "px");
    			}

    			if (!current || dirty[0] & /*headerHeight*/ 2048) {
    				set_style(div, "height", /*headerHeight*/ ctx[11] + "px");
    			}

    			if (!current || dirty[0] & /*headerHeight*/ 2048) {
    				set_style(div, "line-height", /*headerHeight*/ ctx[11] + "px");
    			}

    			if (!current || dirty[0] & /*columns*/ 1 && div_title_value !== (div_title_value = /*column*/ ctx[78].display || '')) {
    				attr_dev(div, "title", div_title_value);
    			}

    			if (dragCopy_action && is_function(dragCopy_action.update) && dirty[0] & /*allowColumnReordering*/ 16384) dragCopy_action.update.call(null, /*allowColumnReordering*/ ctx[14]);

    			if (/*allowResizeFromTableHeaders*/ ctx[13] && !/*column*/ ctx[78].disallowResize) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(873:6) {#each columns as column, i (i)}",
    		ctx
    	});

    	return block;
    }

    // (915:4) {#if allowColumnAffix}
    function create_if_block_3(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "column-affix-marker svelte-15j5yeo");
    			set_style(div, "left", /*columnAffixLineLeft*/ ctx[24] + "px");
    			set_style(div, "height", /*gridSpaceHeight*/ ctx[26] + "px");
    			add_location(div, file$2, 915, 6, 27405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", /*onColumnAffixStart*/ ctx[32], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*columnAffixLineLeft*/ 16777216) {
    				set_style(div, "left", /*columnAffixLineLeft*/ ctx[24] + "px");
    			}

    			if (dirty[0] & /*gridSpaceHeight*/ 67108864) {
    				set_style(div, "height", /*gridSpaceHeight*/ ctx[26] + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(915:4) {#if allowColumnAffix}",
    		ctx
    	});

    	return block;
    }

    // (930:6) {#if allowResizeFromTableCells}
    function create_if_block_1$1(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*columns*/ ctx[0];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*columnWidths, __affixedColumnIndices, __scrollLeft, __columnHeaderResizeCaptureWidth, columns*/ 2162707 | dirty[1] & /*onColumnResizeStart*/ 16) {
    				each_value_2 = /*columns*/ ctx[0];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(930:6) {#if allowResizeFromTableCells}",
    		ctx
    	});

    	return block;
    }

    // (932:10) {#if !column.disallowResize}
    function create_if_block_2(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	function mousedown_handler_2(...args) {
    		return /*mousedown_handler_2*/ ctx[56](/*i*/ ctx[77], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "grid-cell-size-capture svelte-15j5yeo");

    			set_style(div, "left", getCellLeft({
    				i: /*i*/ ctx[77] + 1,
    				columnWidths: /*columnWidths*/ ctx[21],
    				__affixedColumnIndices: /*__affixedColumnIndices*/ ctx[1],
    				__scrollLeft: /*__scrollLeft*/ ctx[4]
    			}) - Math.floor(/*__columnHeaderResizeCaptureWidth*/ ctx[16] / 2) + "px");

    			set_style(div, "width", /*__columnHeaderResizeCaptureWidth*/ ctx[16] + "px");
    			add_location(div, file$2, 932, 12, 28048);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "mousedown", mousedown_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*columnWidths, __affixedColumnIndices, __scrollLeft, __columnHeaderResizeCaptureWidth*/ 2162706) {
    				set_style(div, "left", getCellLeft({
    					i: /*i*/ ctx[77] + 1,
    					columnWidths: /*columnWidths*/ ctx[21],
    					__affixedColumnIndices: /*__affixedColumnIndices*/ ctx[1],
    					__scrollLeft: /*__scrollLeft*/ ctx[4]
    				}) - Math.floor(/*__columnHeaderResizeCaptureWidth*/ ctx[16] / 2) + "px");
    			}

    			if (dirty[0] & /*__columnHeaderResizeCaptureWidth*/ 65536) {
    				set_style(div, "width", /*__columnHeaderResizeCaptureWidth*/ ctx[16] + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(932:10) {#if !column.disallowResize}",
    		ctx
    	});

    	return block;
    }

    // (931:8) {#each columns as column, i}
    function create_each_block_2(ctx) {
    	let if_block_anchor;
    	let if_block = !/*column*/ ctx[78].disallowResize && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*column*/ ctx[78].disallowResize) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(931:8) {#each columns as column, i}",
    		ctx
    	});

    	return block;
    }

    // (975:12) {:else}
    function create_else_block(ctx) {
    	let div;
    	let t_value = (/*row*/ ctx[75].data[/*column*/ ctx[78].dataName] || '') + "";
    	let t;
    	let div_style_value;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "style", div_style_value = /*column*/ ctx[78].style);

    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`cell-default ${/*row*/ ctx[75].i % 2 === 0 && /*Striped*/ ctx[20] && !(/*CurrentSelectedRow*/ ctx[9] === /*row*/ ctx[75].i && /*EnableCursor*/ ctx[19])
			? ' stripedRow '
			: ''} ${/*CurrentSelectedRow*/ ctx[9] === /*row*/ ctx[75].i && /*EnableCursor*/ ctx[19]
			? 'selectedrow'
			: ''}`) + " svelte-15j5yeo"));

    			add_location(div, file$2, 975, 14, 29740);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*visibleRows, columns*/ 134217729 && t_value !== (t_value = (/*row*/ ctx[75].data[/*column*/ ctx[78].dataName] || '') + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*columns*/ 1 && div_style_value !== (div_style_value = /*column*/ ctx[78].style)) {
    				attr_dev(div, "style", div_style_value);
    			}

    			if (dirty[0] & /*visibleRows, Striped, CurrentSelectedRow, EnableCursor*/ 135791104 && div_class_value !== (div_class_value = "" + (null_to_empty(`cell-default ${/*row*/ ctx[75].i % 2 === 0 && /*Striped*/ ctx[20] && !(/*CurrentSelectedRow*/ ctx[9] === /*row*/ ctx[75].i && /*EnableCursor*/ ctx[19])
			? ' stripedRow '
			: ''} ${/*CurrentSelectedRow*/ ctx[9] === /*row*/ ctx[75].i && /*EnableCursor*/ ctx[19]
			? 'selectedrow'
			: ''}`) + " svelte-15j5yeo"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(975:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (968:12) {#if column.cellComponent}
    function create_if_block$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*column*/ ctx[78].cellComponent;

    	function switch_props(ctx) {
    		return {
    			props: {
    				rowNumber: /*row*/ ctx[75].i,
    				column: /*column*/ ctx[78],
    				row: /*row*/ ctx[75]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("valueupdate", /*onCellUpdated*/ ctx[31]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*visibleRows*/ 134217728) switch_instance_changes.rowNumber = /*row*/ ctx[75].i;
    			if (dirty[0] & /*columns*/ 1) switch_instance_changes.column = /*column*/ ctx[78];
    			if (dirty[0] & /*visibleRows*/ 134217728) switch_instance_changes.row = /*row*/ ctx[75];

    			if (switch_value !== (switch_value = /*column*/ ctx[78].cellComponent)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("valueupdate", /*onCellUpdated*/ ctx[31]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(968:12) {#if column.cellComponent}",
    		ctx
    	});

    	return block;
    }

    // (961:8) {#each columns as column, j}
    function create_each_block_1(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let div_class_value;
    	let current;
    	const if_block_creators = [create_if_block$1, create_else_block];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*column*/ ctx[78].cellComponent) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty('grid-cell' + (/*column*/ ctx[78].parent ? ' parent' : '') + (/*column*/ ctx[78].child ? ' child' : '')) + " svelte-15j5yeo"));
    			set_style(div, "z-index", /*getCellZIndex*/ ctx[38](/*__affixedColumnIndices*/ ctx[1], /*j*/ ctx[80]));

    			set_style(div, "left", getCellLeft({
    				i: /*j*/ ctx[80],
    				columnWidths: /*columnWidths*/ ctx[21],
    				__affixedColumnIndices: /*__affixedColumnIndices*/ ctx[1],
    				__scrollLeft: /*__scrollLeft*/ ctx[4]
    			}) + "px");

    			set_style(div, "height", /*rowHeight*/ ctx[10] + "px");
    			set_style(div, "line-height", /*rowHeight*/ ctx[10] + "px");
    			set_style(div, "width", /*columnWidths*/ ctx[21][/*j*/ ctx[80]] + "px");
    			attr_dev(div, "role", "cell");
    			add_location(div, file$2, 961, 10, 29051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty[0] & /*columns*/ 1 && div_class_value !== (div_class_value = "" + (null_to_empty('grid-cell' + (/*column*/ ctx[78].parent ? ' parent' : '') + (/*column*/ ctx[78].child ? ' child' : '')) + " svelte-15j5yeo"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty[0] & /*__affixedColumnIndices*/ 2) {
    				set_style(div, "z-index", /*getCellZIndex*/ ctx[38](/*__affixedColumnIndices*/ ctx[1], /*j*/ ctx[80]));
    			}

    			if (!current || dirty[0] & /*columnWidths, __affixedColumnIndices, __scrollLeft*/ 2097170) {
    				set_style(div, "left", getCellLeft({
    					i: /*j*/ ctx[80],
    					columnWidths: /*columnWidths*/ ctx[21],
    					__affixedColumnIndices: /*__affixedColumnIndices*/ ctx[1],
    					__scrollLeft: /*__scrollLeft*/ ctx[4]
    				}) + "px");
    			}

    			if (!current || dirty[0] & /*rowHeight*/ 1024) {
    				set_style(div, "height", /*rowHeight*/ ctx[10] + "px");
    			}

    			if (!current || dirty[0] & /*rowHeight*/ 1024) {
    				set_style(div, "line-height", /*rowHeight*/ ctx[10] + "px");
    			}

    			if (!current || dirty[0] & /*columnWidths*/ 2097152) {
    				set_style(div, "width", /*columnWidths*/ ctx[21][/*j*/ ctx[80]] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(961:8) {#each columns as column, j}",
    		ctx
    	});

    	return block;
    }

    // (949:4) {#each visibleRows as row, i}
    function create_each_block(ctx) {
    	let div;
    	let t;
    	let div_aria_rowindex_value;
    	let div_rownumber_value;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*columns*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(div, "class", "grid-row  svelte-15j5yeo");
    			set_style(div, "top", /*getRowTop*/ ctx[39](/*row*/ ctx[75].i, /*rowHeight*/ ctx[10]) + "px");
    			set_style(div, "height", /*rowHeight*/ ctx[10] + "px");
    			set_style(div, "width", /*gridSpaceWidth*/ ctx[25] + "px");
    			attr_dev(div, "role", "row");
    			attr_dev(div, "aria-rowindex", div_aria_rowindex_value = /*row*/ ctx[75].i);
    			attr_dev(div, "rownumber", div_rownumber_value = /*row*/ ctx[75].i);
    			attr_dev(div, "viewindex", /*i*/ ctx[77]);
    			add_location(div, file$2, 949, 6, 28711);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*onClickRow*/ ctx[40], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*columns, __affixedColumnIndices, columnWidths, __scrollLeft, rowHeight, visibleRows, Striped, CurrentSelectedRow, EnableCursor*/ 137889299 | dirty[1] & /*getCellZIndex, onCellUpdated*/ 129) {
    				each_value_1 = /*columns*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*visibleRows, rowHeight*/ 134218752) {
    				set_style(div, "top", /*getRowTop*/ ctx[39](/*row*/ ctx[75].i, /*rowHeight*/ ctx[10]) + "px");
    			}

    			if (!current || dirty[0] & /*rowHeight*/ 1024) {
    				set_style(div, "height", /*rowHeight*/ ctx[10] + "px");
    			}

    			if (!current || dirty[0] & /*gridSpaceWidth*/ 33554432) {
    				set_style(div, "width", /*gridSpaceWidth*/ ctx[25] + "px");
    			}

    			if (!current || dirty[0] & /*visibleRows*/ 134217728 && div_aria_rowindex_value !== (div_aria_rowindex_value = /*row*/ ctx[75].i)) {
    				attr_dev(div, "aria-rowindex", div_aria_rowindex_value);
    			}

    			if (!current || dirty[0] & /*visibleRows*/ 134217728 && div_rownumber_value !== (div_rownumber_value = /*row*/ ctx[75].i)) {
    				attr_dev(div, "rownumber", div_rownumber_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(949:4) {#each visibleRows as row, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div5;
    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let each_blocks_1 = [];
    	let each0_lookup = new Map();
    	let t2;
    	let div4;
    	let t3;
    	let div2;
    	let t4;
    	let div3;
    	let t5;
    	let div4_resize_listener;
    	let div5_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = (/*__resizing*/ ctx[2] || /*__columnDragging*/ ctx[7] || /*__affixingColumn*/ ctx[6]) && create_if_block_7(ctx);
    	let if_block1 = /*__affixingRow*/ ctx[5] && create_if_block_6(ctx);
    	let each_value_3 = /*columns*/ ctx[0];
    	validate_each_argument(each_value_3);
    	const get_key = ctx => /*i*/ ctx[77];
    	validate_each_keys(ctx, each_value_3, get_each_context_3, get_key);

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		let child_ctx = get_each_context_3(ctx, each_value_3, i);
    		let key = get_key(child_ctx);
    		each0_lookup.set(key, each_blocks_1[i] = create_each_block_3(key, child_ctx));
    	}

    	let if_block2 = /*allowColumnAffix*/ ctx[15] && create_if_block_3(ctx);
    	let if_block3 = /*allowResizeFromTableCells*/ ctx[12] && create_if_block_1$1(ctx);
    	let each_value = /*visibleRows*/ ctx[27];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			div4 = element("div");
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div2 = element("div");
    			t4 = space();
    			div3 = element("div");
    			if (if_block3) if_block3.c();
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "grid-header-row svelte-15j5yeo");
    			set_style(div0, "left", "-" + /*__scrollLeft*/ ctx[4] + "px");
    			set_style(div0, "height", /*headerHeight*/ ctx[11] + "px");
    			set_style(div0, "width", /*gridSpaceWidth*/ ctx[25] + "px");
    			attr_dev(div0, "role", "row");
    			add_location(div0, file$2, 868, 4, 25579);
    			attr_dev(div1, "class", "grid-headers svelte-15j5yeo");
    			attr_dev(div1, "rolw", "rowgroup");
    			set_style(div1, "height", /*headerHeight*/ ctx[11] + "px");
    			set_style(div1, "margin-top", /*rowHeight*/ ctx[10] - /*headerHeight*/ ctx[11] + "px");
    			add_location(div1, file$2, 863, 2, 25189);
    			attr_dev(div2, "class", "row-affix-marker svelte-15j5yeo");
    			set_style(div2, "top", /*__rowAffixLineTop*/ ctx[18] + "px");
    			set_style(div2, "width", /*gridSpaceWidth*/ ctx[25] + "px");
    			add_location(div2, file$2, 920, 4, 27586);
    			attr_dev(div3, "class", "grid-space svelte-15j5yeo");
    			set_style(div3, "width", /*gridSpaceWidth*/ ctx[25] + "px");
    			set_style(div3, "height", /*gridSpaceHeight*/ ctx[26] + "px");
    			add_location(div3, file$2, 926, 4, 27815);
    			attr_dev(div4, "class", "grid-inner svelte-15j5yeo");
    			set_style(div4, "height", "100%");
    			attr_dev(div4, "role", "rowgroup");
    			add_render_callback(() => /*div4_elementresize_handler*/ ctx[58].call(div4));
    			add_location(div4, file$2, 904, 2, 27123);

    			attr_dev(div5, "class", div5_class_value = "data-grid-wrapper " + (/*__resizing*/ ctx[2] || /*__columnDragging*/ ctx[7]
    			? 'resizing'
    			: '') + " svelte-15j5yeo");

    			set_style(div5, "padding-top", /*rowHeight*/ ctx[10] + "px");
    			attr_dev(div5, "role", "table");
    			add_location(div5, file$2, 849, 0, 24741);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			if (if_block0) if_block0.m(div5, null);
    			append_dev(div5, t0);
    			if (if_block1) if_block1.m(div5, null);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div0, null);
    			}

    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			if (if_block2) if_block2.m(div4, null);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			if (if_block3) if_block3.m(div3, null);
    			append_dev(div4, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div4, null);
    			}

    			/*div4_binding*/ ctx[57](div4);
    			div4_resize_listener = add_resize_listener(div4, /*div4_elementresize_handler*/ ctx[58].bind(div4));
    			/*div5_binding*/ ctx[59](div5);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1, "mouseup", /*onMouseUp*/ ctx[30], false, false, false),
    					listen_dev(window_1, "mousemove", /*onMouseMove*/ ctx[29], false, false, false),
    					listen_dev(window_1, "keydown", /*onWindowKeyDown*/ ctx[28], false, false, false),
    					listen_dev(div2, "mousedown", /*onRowAffixStart*/ ctx[33], false, false, false),
    					listen_dev(div4, "scroll", /*onScroll*/ ctx[36], false, false, false),
    					listen_dev(div4, "mousewheel", /*mousewheel*/ ctx[37], false, false, false),
    					listen_dev(div4, "DOMMouseScroll", /*mousewheel*/ ctx[37], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*__resizing*/ ctx[2] || /*__columnDragging*/ ctx[7] || /*__affixingColumn*/ ctx[6]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					if_block0.m(div5, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*__affixingRow*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_6(ctx);
    					if_block1.c();
    					if_block1.m(div5, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*columns, columnWidths, __affixedColumnIndices, __scrollLeft, __columnHeaderResizeCaptureWidth, allowResizeFromTableHeaders, headerHeight, allowColumnReordering*/ 2189331 | dirty[1] & /*onColumnResizeStart, getCellZIndex, onColumnDragStart*/ 152) {
    				each_value_3 = /*columns*/ ctx[0];
    				validate_each_argument(each_value_3);
    				group_outros();
    				validate_each_keys(ctx, each_value_3, get_each_context_3, get_key);
    				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_3, each0_lookup, div0, outro_and_destroy_block, create_each_block_3, null, get_each_context_3);
    				check_outros();
    			}

    			if (!current || dirty[0] & /*__scrollLeft*/ 16) {
    				set_style(div0, "left", "-" + /*__scrollLeft*/ ctx[4] + "px");
    			}

    			if (!current || dirty[0] & /*headerHeight*/ 2048) {
    				set_style(div0, "height", /*headerHeight*/ ctx[11] + "px");
    			}

    			if (!current || dirty[0] & /*gridSpaceWidth*/ 33554432) {
    				set_style(div0, "width", /*gridSpaceWidth*/ ctx[25] + "px");
    			}

    			if (!current || dirty[0] & /*headerHeight*/ 2048) {
    				set_style(div1, "height", /*headerHeight*/ ctx[11] + "px");
    			}

    			if (!current || dirty[0] & /*rowHeight, headerHeight*/ 3072) {
    				set_style(div1, "margin-top", /*rowHeight*/ ctx[10] - /*headerHeight*/ ctx[11] + "px");
    			}

    			if (/*allowColumnAffix*/ ctx[15]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_3(ctx);
    					if_block2.c();
    					if_block2.m(div4, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (!current || dirty[0] & /*__rowAffixLineTop*/ 262144) {
    				set_style(div2, "top", /*__rowAffixLineTop*/ ctx[18] + "px");
    			}

    			if (!current || dirty[0] & /*gridSpaceWidth*/ 33554432) {
    				set_style(div2, "width", /*gridSpaceWidth*/ ctx[25] + "px");
    			}

    			if (/*allowResizeFromTableCells*/ ctx[12]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_1$1(ctx);
    					if_block3.c();
    					if_block3.m(div3, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (!current || dirty[0] & /*gridSpaceWidth*/ 33554432) {
    				set_style(div3, "width", /*gridSpaceWidth*/ ctx[25] + "px");
    			}

    			if (!current || dirty[0] & /*gridSpaceHeight*/ 67108864) {
    				set_style(div3, "height", /*gridSpaceHeight*/ ctx[26] + "px");
    			}

    			if (dirty[0] & /*visibleRows, rowHeight, gridSpaceWidth, columns, __affixedColumnIndices, columnWidths, __scrollLeft, Striped, CurrentSelectedRow, EnableCursor*/ 171443731 | dirty[1] & /*getRowTop, onClickRow, getCellZIndex, onCellUpdated*/ 897) {
    				each_value = /*visibleRows*/ ctx[27];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div4, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*__resizing, __columnDragging*/ 132 && div5_class_value !== (div5_class_value = "data-grid-wrapper " + (/*__resizing*/ ctx[2] || /*__columnDragging*/ ctx[7]
    			? 'resizing'
    			: '') + " svelte-15j5yeo")) {
    				attr_dev(div5, "class", div5_class_value);
    			}

    			if (!current || dirty[0] & /*rowHeight*/ 1024) {
    				set_style(div5, "padding-top", /*rowHeight*/ ctx[10] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].d();
    			}

    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			destroy_each(each_blocks, detaching);
    			/*div4_binding*/ ctx[57](null);
    			div4_resize_listener();
    			/*div5_binding*/ ctx[59](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const MIN_COLUMN_SIZE = 30;

    /**
     * Computes the 'left' value for a grid-cell.
     * @param {Number} i The cell index
     * @param {Array} columnWidths The array of column widths in order
     * @returns {Number}
     */
    function getCellLeft({ i, columnWidths, __affixedColumnIndices, __scrollLeft }) {
    	if (__affixedColumnIndices.indexOf(i) >= 0) {
    		if (i === 0) {
    			return __scrollLeft;
    		}

    		let left = __scrollLeft;

    		for (let j = i - 1; j >= 0; j--) {
    			left += columnWidths[j];
    		}

    		return left;
    	}

    	let left = 0;

    	for (let j = 0; j < i; j++) {
    		left += columnWidths[j];
    	}

    	return left;
    }

    /**
     * Gets the closest column index given an x offset
     * @param {Number} x The x offset
     * @param {Array} columnWidths Array of column widths
     * @param {Array} __affixedColumnIndices Array of column indices that have been affixed
     * @param {Number} __scrollLeft The scrollLeft value of the scrollable container
     * @returns {Number}
     */
    function getClosestIndex(x, columnWidths, __affixedColumnIndices, __scrollLeft) {
    	let closest = 0;

    	for (let i = 0; i < columnWidths.length; i++) {
    		const left = getCellLeft({
    			i,
    			columnWidths,
    			__affixedColumnIndices,
    			__scrollLeft
    		}) + Math.floor(columnWidths[i] / 2);

    		if (left < x) {
    			closest = i + 1;
    		}
    	}

    	// special handling required when there are affixed columns, because
    	// if the grid is scrolled horizontally to the right, we want to have this function return the closest
    	// affixed column, rather than any columns that might be closer to x but are being overlapped by an affixed column
    	if (__affixedColumnIndices.length > 0) {
    		const firstAffixedLeft = getCellLeft({
    			i: __affixedColumnIndices[0],
    			columnWidths,
    			__affixedColumnIndices,
    			__scrollLeft
    		});

    		const lastAffixedLeft = getCellLeft({
    			i: __affixedColumnIndices[__affixedColumnIndices.length - 1],
    			columnWidths,
    			__affixedColumnIndices,
    			__scrollLeft
    		});

    		const lastAffixedRight = lastAffixedLeft + columnWidths[__affixedColumnIndices[__affixedColumnIndices.length - 1]];

    		const closestLeft = getCellLeft({
    			i: closest,
    			columnWidths,
    			__affixedColumnIndices,
    			__scrollLeft
    		});

    		if (closestLeft > firstAffixedLeft && closestLeft < lastAffixedRight) {
    			if (closestLeft < lastAffixedRight && closestLeft > lastAffixedLeft) {
    				closest = __affixedColumnIndices[__affixedColumnIndices.length - 1];
    			} else {
    				for (let i = 0; i < __affixedColumnIndices.length; i++) {
    					const left = getCellLeft({
    						i: __affixedColumnIndices[i],
    						columnWidths,
    						__affixedColumnIndices,
    						__scrollLeft
    					}) + Math.floor(columnWidths[__affixedColumnIndices[i]] / 2);

    					if (left < x) {
    						closest = __affixedColumnIndices[i] + 1;
    					}
    				}
    			}
    		}
    	}

    	return closest;
    }

    function getBodyScrollTop() {
    	return window.pageYOffset || (document.documentElement.clientHeight
    	? document.documentElement.scrollTop
    	: document.body.scrollTop);
    }

    /**
     * TODO handle svelte 2's onupdate
     **/
    // onupdate(({ changed, current, previous }) => {
    //   // Record the change in onupdate to allow the DOM to change before doing the deep diff
    //   if (changed.rows && previous && previous.rows && previous.rows.length > 0) {
    //     if (!current.skipRecord) {
    //       this.editHistory.recordChange(current.rows);
    //     } else {
    //       this.set({ skipRecord: false });
    //     }
    //   }
    // });
    /**
     * This action creates a half-opaque 'ghost' column header to visualize dragging a column into a different position
     * This is put in an action because ultimately the ghost image has nothing to do with the actual column index move
     */
    function dragCopy(node, enabled) {
    	let copy = null;
    	let dragging = false;
    	let offsetX = 0;

    	function onWindowMouseMove(event) {
    		if (!dragging) {
    			return;
    		}

    		copy.style.left = event.pageX - offsetX + "px";
    	}

    	function onWindowMouseUp(event) {
    		if (!dragging || event.which !== 1) {
    			return;
    		}

    		dragging = false;
    		document.body.removeChild(copy);
    		copy = null;
    	}

    	function onNodeMouseDown(event) {
    		if (event.which !== 1) {
    			return;
    		}

    		dragging = true;

    		if (copy) {
    			document.body.removeChild(copy);
    		}

    		copy = createCopy();
    		offsetX = event.offsetX;
    		copy.style.top = node.getBoundingClientRect().top + getBodyScrollTop() + "px";
    		copy.style.left = event.pageX - offsetX + "px";
    		document.body.appendChild(copy);
    	}

    	function createCopy() {
    		const copy = document.createElement("div");
    		copy.innerHTML = node.innerHTML;
    		const { width, height, textAlign, fontWeight } = getComputedStyle(node);
    		copy.style.width = width;
    		copy.style.height = height;
    		copy.style.maxHeight = height;
    		copy.style.textAlign = textAlign;
    		copy.style.fontWeight = fontWeight;
    		copy.style.position = "absolute";
    		copy.style.opacity = "0.5";
    		copy.style.pointerEvents = "none";
    		copy.style.overflow = "hidden";
    		copy.style.background = "#dddddd";
    		copy.style["z-index"] = "99999";
    		return copy;
    	}

    	function attachEvents() {
    		window.addEventListener("mousemove", onWindowMouseMove);
    		window.addEventListener("mouseup", onWindowMouseUp);
    		node.addEventListener("mousedown", onNodeMouseDown);
    	}

    	function detachEvents() {
    		window.removeEventListener("mousemove", onWindowMouseMove);
    		window.removeEventListener("mouseup", onWindowMouseUp);
    		node.removeEventListener("mousedown", onNodeMouseDown);
    	}

    	if (enabled) {
    		attachEvents();
    	}

    	return {
    		destroy() {
    			detachEvents();
    		},
    		update(enabled) {
    			if (enabled) {
    				attachEvents();
    			} else {
    				detachEvents();
    			}
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Svelte_data_grid', slots, []);
    	const dispatch = createEventDispatcher();
    	let wrapper;
    	let tableSpace;
    	let isLoadMore = false;
    	let editHistory = null;
    	let { rows = [] } = $$props;
    	let { columns = [] } = $$props;
    	let { rowHeight = 24 } = $$props;
    	let { headerHeight = 32 } = $$props;
    	let { allowResizeFromTableCells = false } = $$props;
    	let { allowResizeFromTableHeaders = true } = $$props;
    	let { allowColumnReordering = true } = $$props;
    	let { allowColumnAffix = true } = $$props;
    	let { __extraRows = 0 } = $$props;
    	let { __columnHeaderResizeCaptureWidth = 20 } = $$props;
    	let { __affixedColumnIndices = [] } = $$props;
    	let { __affixingRow = false } = $$props;
    	let { __affixingColumn = false } = $$props;
    	let { __rowActionLineTop = 0 } = $$props;
    	let { __rowAffixLineTop = 0 } = $$props;
    	let { __columnDragging = false } = $$props;
    	let { __columnIndexBeingDragged = null } = $$props;
    	let { __columnDragOffsetX = 0 } = $$props;
    	let { __resizing = false } = $$props;
    	let { __columnIndexBeingResized = null } = $$props;
    	let { __columnActionLineLeft = 0 } = $$props;
    	let { __innerOffsetHeight = 0 } = $$props;
    	let { __scrollTop = 0 } = $$props;
    	let { __scrollLeft = 0 } = $$props;
    	let { __scrolledAllTheWayToTheRight = false } = $$props;
    	let { threshold = 0 } = $$props;
    	let { horizontal = false } = $$props;
    	let { hasMore = true } = $$props;
    	let { EnableCursor = false } = $$props;
    	let { CurrentSelectedRow = 0 } = $$props;
    	let { Striped = false } = $$props;
    	let { fixColumn = 0 } = $$props;

    	const setFixedColumn = () => {
    		// MATTSAHR_MODIFIED 2 FEB 2022 -- ADDED THIS METHOD ON MOUNT
    		if (fixColumn) {
    			const indices = [];

    			for (let i = 0; i <= fixColumn; i++) {
    				indices.push(i);
    			}

    			$$invalidate(1, __affixedColumnIndices = indices);
    		}
    	};

    	onMount(() => {
    		editHistory = new EditHistory(rows);
    		setFixedColumn();
    	});

    	function onWindowKeyDown(event) {
    		if (event.ctrlKey) {
    			if (event.keyCode === 90) {
    				undo();
    				event.preventDefault();
    			}

    			if (event.keyCode === 89) {
    				redo();
    				event.preventDefault();
    			}
    		}

    		if ([38, 40].includes(event.keyCode) && EnableCursor) {
    			const Direction = event.keyCode == 40 ? 1 : 0;
    			moveCursorWithIndexRow(Direction);
    			event.preventDefault();
    		}
    	}

    	function moveCursorWithIndexRow(Direction) {
    		const last = CurrentSelectedRow;

    		if (Direction === 1) {
    			// upscroll code
    			if (rows.length - 1 >= CurrentSelectedRow + 1) {
    				$$invalidate(9, CurrentSelectedRow++, CurrentSelectedRow);
    			}
    		} else {
    			// upscroll code
    			if (CurrentSelectedRow - 1 >= 0) {
    				$$invalidate(9, CurrentSelectedRow--, CurrentSelectedRow);
    			}
    		}

    		if (last !== CurrentSelectedRow) {
    			dispatch("changecursor", { CurrentSelectedRow });
    		}

    		if (Direction === 1 && CurrentSelectedRow < rows.length) {
    			$$invalidate(23, tableSpace.scrollTop += rowHeight, tableSpace);
    		} else {
    			$$invalidate(23, tableSpace.scrollTop -= rowHeight, tableSpace);
    		}
    	}

    	/**
     * Event handler for window's mousemove event
     * @param {MouseEvent} event The MouseEvent object
     */
    	function onMouseMove(event) {
    		onColumnDragMouseMove(event);
    		onColumnResizeMouseMove(event);
    		onColumnAffixMouseMove(event);
    	}

    	/**
     * Event handler for window's mouseup event
     * @param {MouseEvent} event The MouseEvent object
     */
    	function onMouseUp(event) {
    		onColumnDragEnd(event);
    		onColumnResizeEnd();
    		onRowAffixEnd();
    		onColumnAffixEnd();
    	}

    	/**
     * Event handler for when a value has been updated
     * @param {Object} event Event object with row and column objects
     */
    	function onCellUpdated(event) {
    		$$invalidate(41, rows[event.detail.rowNumber][event.detail.column.dataName] = event.detail.value, rows);
    		dispatch("valueUpdated", event);
    	}

    	/**
     * Applies the most recent backward change
     */
    	function undo() {
    		const eRows = editHistory.undo();

    		if (eRows) {
    			$$invalidate(41, rows = eRows);
    		}
    	}

    	/**
     * Applies the most recent forward change
     */
    	function redo() {
    		const eRows = editHistory.redo();

    		if (eRows) {
    			$$invalidate(41, rows = eRows);
    		}
    	}

    	/**
     * Event handler for starting column affix operation
     */
    	function onColumnAffixStart(event) {
    		// left click only
    		if (event.which !== 1) {
    			return;
    		}

    		if (__affixedColumnIndices.length > 0) {
    			$$invalidate(23, tableSpace.scrollLeft = 0, tableSpace);
    			$$invalidate(6, __affixingColumn = true);
    		} else {
    			$$invalidate(6, __affixingColumn = true);
    		}
    	}

    	/**
     * Event handler for mousemove column affix operation
     */
    	function onColumnAffixMouseMove(event) {
    		if (!__affixingColumn) {
    			return;
    		}

    		if (event.which !== 1) {
    			onColumnAffixEnd();
    			return;
    		}

    		const { left: wrapperPageX } = wrapper.getBoundingClientRect();
    		const offsetPoint = event.pageX - wrapperPageX + __scrollLeft;
    		const idx = getClosestIndex(offsetPoint, columnWidths, __affixedColumnIndices, __scrollLeft);
    		const indices = [];

    		for (let i = 0; i < idx; i++) {
    			indices.push(i);
    		}

    		$$invalidate(8, __columnActionLineLeft = offsetPoint);
    		$$invalidate(1, __affixedColumnIndices = indices);
    		console.log('INDICES', indices);
    		event.preventDefault();
    	} // check to see if horizontal scroll position doesn't match where the

    	/**
     * Event handler for ending column affix operation
     */
    	function onColumnAffixEnd(event) {
    		$$invalidate(6, __affixingColumn = false);
    	}

    	/**
     * Event handler for starting row affix operation
     */
    	function onRowAffixStart(event) {
    		$$invalidate(5, __affixingRow = true);
    	}

    	/**
     * Event handler for mousemove row affix operation
     */
    	function onRowAffixMouseMove(event) {
    		if (!__affixingRow) {
    			return;
    		}
    	}

    	/**
     * Event handler for ending row affix operation
     */
    	function onRowAffixEnd(event) {
    		$$invalidate(5, __affixingRow = false);
    	}

    	/**
     * Event handler for column dragging
     */
    	function onColumnDragStart(event, columnIndex) {
    		if (event.which !== 1) {
    			return;
    		}

    		// if the developer has disabled column reordering, don't begin a reorder
    		if (!allowColumnReordering) {
    			return;
    		}

    		$$invalidate(7, __columnDragging = true);
    		$$invalidate(44, __columnIndexBeingDragged = columnIndex);
    		$$invalidate(45, __columnDragOffsetX = event.offsetX);

    		$$invalidate(8, __columnActionLineLeft = getCellLeft({
    			i: columnIndex,
    			columnWidths,
    			__scrollLeft,
    			__affixedColumnIndices
    		}) - __scrollLeft);
    	}

    	function onColumnDragMouseMove(event) {
    		if (!__columnDragging) {
    			return;
    		}

    		// if user is no longer pressing the left mouse button and we are out of sync
    		// with __columnDragging because mouseup didn't fire, finish the reorder
    		if (event.which !== 1) {
    			onColumnDragEnd(event);
    			return;
    		}

    		const { left: wrapperPageX } = wrapper.getBoundingClientRect();

    		// change the position of the action line to the closest column index under the mouse
    		const offsetPoint = event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;

    		const idx = getClosestIndex(offsetPoint, columnWidths, __affixedColumnIndices, __scrollLeft);

    		$$invalidate(8, __columnActionLineLeft = getCellLeft({
    			i: idx,
    			columnWidths,
    			__affixedColumnIndices,
    			__scrollLeft
    		}) - __scrollLeft);
    	}

    	/**
     * Window mouseup handler for column dragging
     */
    	function onColumnDragEnd(event) {
    		// user might try to be clever and middle-click to scroll horizontally while dragging a column
    		// don't stop the drag for middle clicks
    		if (event.which !== 1) {
    			return;
    		}

    		// if a column isn't being dragged, don't reorder anything
    		if (!__columnDragging) {
    			return;
    		}

    		const { left: wrapperPageX } = wrapper.getBoundingClientRect();
    		const offsetPoint = event.pageX - wrapperPageX + __scrollLeft - __columnDragOffsetX;

    		// move column object to its new position in the array based off the mouse position and scroll position
    		const newIdx = getClosestIndex(offsetPoint, columnWidths, __affixedColumnIndices, __scrollLeft);

    		let mColumns = columns;
    		mColumns.splice(newIdx > __columnIndexBeingDragged ? newIdx - 1 : newIdx, 0, mColumns.splice(__columnIndexBeingDragged, 1)[0]);
    		$$invalidate(0, columns = mColumns);

    		// delay firing of event so that new column order is accessible when handlers are called
    		setTimeout(() => dispatch("columnOrderUpdated"), 0);

    		$$invalidate(7, __columnDragging = false);
    		$$invalidate(45, __columnDragOffsetX = 0);
    		$$invalidate(44, __columnIndexBeingDragged = null);
    	}

    	/**
     * Mousedown handler for column resizing
     */
    	function onColumnResizeStart(event, columnIndex) {
    		// left click only
    		if (event.which !== 1) {
    			return;
    		}

    		const { left: wrapperPageX } = wrapper.getBoundingClientRect();
    		$$invalidate(2, __resizing = true);
    		$$invalidate(8, __columnActionLineLeft = event.pageX - wrapperPageX - __scrollLeft);
    		$$invalidate(46, __columnIndexBeingResized = columnIndex);
    		event.stopPropagation();
    	}

    	/**
     * Mousemove handler for column resizing
     */
    	function onColumnResizeMouseMove(event) {
    		// if not currently resizing a column, ignore the event
    		if (!__resizing) {
    			return;
    		}

    		const { left: wrapperPageX } = wrapper.getBoundingClientRect();
    		const resizeLineLeft = event.pageX - wrapperPageX;

    		const columnLeft = getCellLeft({
    			i: __columnIndexBeingResized,
    			columnWidths,
    			__affixedColumnIndices,
    			__scrollLeft
    		});

    		const resizeLineMinLeft = columnLeft - __scrollLeft + MIN_COLUMN_SIZE;
    		const newColumnWidth = Math.max(resizeLineLeft + __scrollLeft - columnLeft, MIN_COLUMN_SIZE);

    		// thanks to the virtual list, we're able to get away with setting the column's size while the mouse moves
    		$$invalidate(0, columns[__columnIndexBeingResized].width = newColumnWidth, columns);

    		$$invalidate(8, __columnActionLineLeft = Math.max(resizeLineLeft, resizeLineMinLeft));

    		// If mouseup was not fired for some reason, abort the resize
    		if (event.which !== 1) {
    			$$invalidate(2, __resizing = false);
    			$$invalidate(46, __columnIndexBeingResized = null);

    			// delay firing the event until the next frame to guarantee that new values will be available in component.get()
    			setTimeout(
    				() => dispatch("columnWidthUpdated", {
    					idx: __columnIndexBeingResized,
    					width: newColumnWidth
    				}),
    				0
    			);
    		}
    	} // if still resizing and the user does not have the left mouse button depressed,
    	// the mouseup event didn't fire for some reason, so turn off the resize mode

    	/**
     * Mouseup handler for column resizing
     */
    	function onColumnResizeEnd(event) {
    		if (!__resizing) {
    			return;
    		}

    		dispatch("columnWidthUpdated");
    		$$invalidate(2, __resizing = false);
    		$$invalidate(46, __columnIndexBeingResized = null);
    	}

    	/**
     * Sets updated scroll values when the scrollable area is scrolled
     */
    	function onScroll(e) {
    		// get new scroll values from the scroll area
    		const { scrollTop: newScrollTop, scrollLeft: newScrollLeft } = tableSpace;

    		/*
     * To avoid doing unnecessary re-calculation of computed variables, don't set the scroll
     * properties that haven't changed
     */
    		if (__scrollTop !== newScrollTop) {
    			$$invalidate(42, __scrollTop = newScrollTop);
    		}

    		if (__scrollLeft !== newScrollLeft) {
    			$$invalidate(4, __scrollLeft = newScrollLeft);
    		}

    		$$invalidate(43, __scrolledAllTheWayToTheRight = Math.ceil(tableSpace.scrollWidth - tableSpace.scrollLeft) === tableSpace.clientWidth);

    		//evaluates if the event is executed to load more data
    		const offset = horizontal
    		? e.target.scrollWidth - e.target.clientWidth - e.target.scrollLeft
    		: e.target.scrollHeight - e.target.clientHeight - e.target.scrollTop;

    		if (offset <= threshold) {
    			if (!isLoadMore && hasMore) {
    				dispatch("loadMore");
    			}

    			isLoadMore = true;
    		} else {
    			isLoadMore = false;
    		}
    	}

    	function mousewheel(event) {
    		if (EnableCursor) {
    			let Direction = Math.sign(event.deltaY);

    			if (!Direction) {
    				Direction = event.detail > 0 ? 1 : 0;
    			}

    			moveCursorWithIndexRow(Direction);
    			event.preventDefault();
    		}
    	}

    	/**
     * Computed Properties
     */
    	/**
     * The 'left' value of the column affix line
     */
    	let columnAffixLineLeft = 0; //TODO setter probably not needed due to reactive statement

    	/**
     * Array of column widths
     */
    	let columnWidths = columns.map(x => x.width || MIN_COLUMN_SIZE); //TODO setter probably not needed due to reactive statement

    	/**
     * The number of rows we have
     */
    	let numRows = rows.length; //TODO setter probably not needed due to reactive statement

    	/**
     * Width of the overall grid space
     */
    	let gridSpaceWidth = 0; //TODO setter probably not needed due to reactive statement

    	/**
     * Height of the overall grid space
     */
    	let gridSpaceHeight = rowHeight * numRows; //TODO setter probably not needed due to reactive statement

    	/**
     * Number of rows to render in the viewport
     */
    	let numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight);

    	/**
     * Computes which rows should be visible
     */
    	let visibleRows;

    	/**
     * Helpers
     */
    	const getCellZIndex = function (__affixedColumnIndices, i) {
    		return __affixedColumnIndices.indexOf(i) === -1 ? 1 : 2;
    	};

    	/**
     * Gets the 'top' value for a grid-row
     */
    	const getRowTop = function (i, rowHeight) {
    		return i * rowHeight;
    	};

    	// const getCellLeft =getCellLeft
    	/**
     * onclickrow
    */
    	const onClickRow = event => {
    		const Sender = event.target.offsetParent.offsetParent;
    		const index = Sender.getAttribute('rownumber');
    		dispatch("clickrow", { index });

    		if (EnableCursor) {
    			$$invalidate(9, CurrentSelectedRow = parseInt(index, 10));
    			dispatch("changecursor", { CurrentSelectedRow });
    		}
    	};

    	const writable_props = [
    		'rows',
    		'columns',
    		'rowHeight',
    		'headerHeight',
    		'allowResizeFromTableCells',
    		'allowResizeFromTableHeaders',
    		'allowColumnReordering',
    		'allowColumnAffix',
    		'__extraRows',
    		'__columnHeaderResizeCaptureWidth',
    		'__affixedColumnIndices',
    		'__affixingRow',
    		'__affixingColumn',
    		'__rowActionLineTop',
    		'__rowAffixLineTop',
    		'__columnDragging',
    		'__columnIndexBeingDragged',
    		'__columnDragOffsetX',
    		'__resizing',
    		'__columnIndexBeingResized',
    		'__columnActionLineLeft',
    		'__innerOffsetHeight',
    		'__scrollTop',
    		'__scrollLeft',
    		'__scrolledAllTheWayToTheRight',
    		'threshold',
    		'horizontal',
    		'hasMore',
    		'EnableCursor',
    		'CurrentSelectedRow',
    		'Striped',
    		'fixColumn'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Svelte_data_grid> was created with unknown prop '${key}'`);
    	});

    	const mousedown_handler = (i, event) => onColumnDragStart(event, i);
    	const mousedown_handler_1 = (i, event) => onColumnResizeStart(event, i);
    	const mousedown_handler_2 = (i, event) => onColumnResizeStart(event, i);

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			tableSpace = $$value;
    			$$invalidate(23, tableSpace);
    		});
    	}

    	function div4_elementresize_handler() {
    		__innerOffsetHeight = this.offsetHeight;
    		$$invalidate(3, __innerOffsetHeight);
    	}

    	function div5_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			wrapper = $$value;
    			$$invalidate(22, wrapper);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('rows' in $$props) $$invalidate(41, rows = $$props.rows);
    		if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);
    		if ('rowHeight' in $$props) $$invalidate(10, rowHeight = $$props.rowHeight);
    		if ('headerHeight' in $$props) $$invalidate(11, headerHeight = $$props.headerHeight);
    		if ('allowResizeFromTableCells' in $$props) $$invalidate(12, allowResizeFromTableCells = $$props.allowResizeFromTableCells);
    		if ('allowResizeFromTableHeaders' in $$props) $$invalidate(13, allowResizeFromTableHeaders = $$props.allowResizeFromTableHeaders);
    		if ('allowColumnReordering' in $$props) $$invalidate(14, allowColumnReordering = $$props.allowColumnReordering);
    		if ('allowColumnAffix' in $$props) $$invalidate(15, allowColumnAffix = $$props.allowColumnAffix);
    		if ('__extraRows' in $$props) $$invalidate(47, __extraRows = $$props.__extraRows);
    		if ('__columnHeaderResizeCaptureWidth' in $$props) $$invalidate(16, __columnHeaderResizeCaptureWidth = $$props.__columnHeaderResizeCaptureWidth);
    		if ('__affixedColumnIndices' in $$props) $$invalidate(1, __affixedColumnIndices = $$props.__affixedColumnIndices);
    		if ('__affixingRow' in $$props) $$invalidate(5, __affixingRow = $$props.__affixingRow);
    		if ('__affixingColumn' in $$props) $$invalidate(6, __affixingColumn = $$props.__affixingColumn);
    		if ('__rowActionLineTop' in $$props) $$invalidate(17, __rowActionLineTop = $$props.__rowActionLineTop);
    		if ('__rowAffixLineTop' in $$props) $$invalidate(18, __rowAffixLineTop = $$props.__rowAffixLineTop);
    		if ('__columnDragging' in $$props) $$invalidate(7, __columnDragging = $$props.__columnDragging);
    		if ('__columnIndexBeingDragged' in $$props) $$invalidate(44, __columnIndexBeingDragged = $$props.__columnIndexBeingDragged);
    		if ('__columnDragOffsetX' in $$props) $$invalidate(45, __columnDragOffsetX = $$props.__columnDragOffsetX);
    		if ('__resizing' in $$props) $$invalidate(2, __resizing = $$props.__resizing);
    		if ('__columnIndexBeingResized' in $$props) $$invalidate(46, __columnIndexBeingResized = $$props.__columnIndexBeingResized);
    		if ('__columnActionLineLeft' in $$props) $$invalidate(8, __columnActionLineLeft = $$props.__columnActionLineLeft);
    		if ('__innerOffsetHeight' in $$props) $$invalidate(3, __innerOffsetHeight = $$props.__innerOffsetHeight);
    		if ('__scrollTop' in $$props) $$invalidate(42, __scrollTop = $$props.__scrollTop);
    		if ('__scrollLeft' in $$props) $$invalidate(4, __scrollLeft = $$props.__scrollLeft);
    		if ('__scrolledAllTheWayToTheRight' in $$props) $$invalidate(43, __scrolledAllTheWayToTheRight = $$props.__scrolledAllTheWayToTheRight);
    		if ('threshold' in $$props) $$invalidate(48, threshold = $$props.threshold);
    		if ('horizontal' in $$props) $$invalidate(49, horizontal = $$props.horizontal);
    		if ('hasMore' in $$props) $$invalidate(50, hasMore = $$props.hasMore);
    		if ('EnableCursor' in $$props) $$invalidate(19, EnableCursor = $$props.EnableCursor);
    		if ('CurrentSelectedRow' in $$props) $$invalidate(9, CurrentSelectedRow = $$props.CurrentSelectedRow);
    		if ('Striped' in $$props) $$invalidate(20, Striped = $$props.Striped);
    		if ('fixColumn' in $$props) $$invalidate(51, fixColumn = $$props.fixColumn);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		EditHistory,
    		createEventDispatcher,
    		dispatch,
    		MIN_COLUMN_SIZE,
    		wrapper,
    		tableSpace,
    		isLoadMore,
    		getCellLeft,
    		getClosestIndex,
    		getBodyScrollTop,
    		editHistory,
    		rows,
    		columns,
    		rowHeight,
    		headerHeight,
    		allowResizeFromTableCells,
    		allowResizeFromTableHeaders,
    		allowColumnReordering,
    		allowColumnAffix,
    		__extraRows,
    		__columnHeaderResizeCaptureWidth,
    		__affixedColumnIndices,
    		__affixingRow,
    		__affixingColumn,
    		__rowActionLineTop,
    		__rowAffixLineTop,
    		__columnDragging,
    		__columnIndexBeingDragged,
    		__columnDragOffsetX,
    		__resizing,
    		__columnIndexBeingResized,
    		__columnActionLineLeft,
    		__innerOffsetHeight,
    		__scrollTop,
    		__scrollLeft,
    		__scrolledAllTheWayToTheRight,
    		threshold,
    		horizontal,
    		hasMore,
    		EnableCursor,
    		CurrentSelectedRow,
    		Striped,
    		fixColumn,
    		setFixedColumn,
    		dragCopy,
    		onWindowKeyDown,
    		moveCursorWithIndexRow,
    		onMouseMove,
    		onMouseUp,
    		onCellUpdated,
    		undo,
    		redo,
    		onColumnAffixStart,
    		onColumnAffixMouseMove,
    		onColumnAffixEnd,
    		onRowAffixStart,
    		onRowAffixMouseMove,
    		onRowAffixEnd,
    		onColumnDragStart,
    		onColumnDragMouseMove,
    		onColumnDragEnd,
    		onColumnResizeStart,
    		onColumnResizeMouseMove,
    		onColumnResizeEnd,
    		onScroll,
    		mousewheel,
    		columnAffixLineLeft,
    		columnWidths,
    		numRows,
    		gridSpaceWidth,
    		gridSpaceHeight,
    		numRowsInViewport,
    		visibleRows,
    		getCellZIndex,
    		getRowTop,
    		onClickRow
    	});

    	$$self.$inject_state = $$props => {
    		if ('wrapper' in $$props) $$invalidate(22, wrapper = $$props.wrapper);
    		if ('tableSpace' in $$props) $$invalidate(23, tableSpace = $$props.tableSpace);
    		if ('isLoadMore' in $$props) isLoadMore = $$props.isLoadMore;
    		if ('editHistory' in $$props) editHistory = $$props.editHistory;
    		if ('rows' in $$props) $$invalidate(41, rows = $$props.rows);
    		if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);
    		if ('rowHeight' in $$props) $$invalidate(10, rowHeight = $$props.rowHeight);
    		if ('headerHeight' in $$props) $$invalidate(11, headerHeight = $$props.headerHeight);
    		if ('allowResizeFromTableCells' in $$props) $$invalidate(12, allowResizeFromTableCells = $$props.allowResizeFromTableCells);
    		if ('allowResizeFromTableHeaders' in $$props) $$invalidate(13, allowResizeFromTableHeaders = $$props.allowResizeFromTableHeaders);
    		if ('allowColumnReordering' in $$props) $$invalidate(14, allowColumnReordering = $$props.allowColumnReordering);
    		if ('allowColumnAffix' in $$props) $$invalidate(15, allowColumnAffix = $$props.allowColumnAffix);
    		if ('__extraRows' in $$props) $$invalidate(47, __extraRows = $$props.__extraRows);
    		if ('__columnHeaderResizeCaptureWidth' in $$props) $$invalidate(16, __columnHeaderResizeCaptureWidth = $$props.__columnHeaderResizeCaptureWidth);
    		if ('__affixedColumnIndices' in $$props) $$invalidate(1, __affixedColumnIndices = $$props.__affixedColumnIndices);
    		if ('__affixingRow' in $$props) $$invalidate(5, __affixingRow = $$props.__affixingRow);
    		if ('__affixingColumn' in $$props) $$invalidate(6, __affixingColumn = $$props.__affixingColumn);
    		if ('__rowActionLineTop' in $$props) $$invalidate(17, __rowActionLineTop = $$props.__rowActionLineTop);
    		if ('__rowAffixLineTop' in $$props) $$invalidate(18, __rowAffixLineTop = $$props.__rowAffixLineTop);
    		if ('__columnDragging' in $$props) $$invalidate(7, __columnDragging = $$props.__columnDragging);
    		if ('__columnIndexBeingDragged' in $$props) $$invalidate(44, __columnIndexBeingDragged = $$props.__columnIndexBeingDragged);
    		if ('__columnDragOffsetX' in $$props) $$invalidate(45, __columnDragOffsetX = $$props.__columnDragOffsetX);
    		if ('__resizing' in $$props) $$invalidate(2, __resizing = $$props.__resizing);
    		if ('__columnIndexBeingResized' in $$props) $$invalidate(46, __columnIndexBeingResized = $$props.__columnIndexBeingResized);
    		if ('__columnActionLineLeft' in $$props) $$invalidate(8, __columnActionLineLeft = $$props.__columnActionLineLeft);
    		if ('__innerOffsetHeight' in $$props) $$invalidate(3, __innerOffsetHeight = $$props.__innerOffsetHeight);
    		if ('__scrollTop' in $$props) $$invalidate(42, __scrollTop = $$props.__scrollTop);
    		if ('__scrollLeft' in $$props) $$invalidate(4, __scrollLeft = $$props.__scrollLeft);
    		if ('__scrolledAllTheWayToTheRight' in $$props) $$invalidate(43, __scrolledAllTheWayToTheRight = $$props.__scrolledAllTheWayToTheRight);
    		if ('threshold' in $$props) $$invalidate(48, threshold = $$props.threshold);
    		if ('horizontal' in $$props) $$invalidate(49, horizontal = $$props.horizontal);
    		if ('hasMore' in $$props) $$invalidate(50, hasMore = $$props.hasMore);
    		if ('EnableCursor' in $$props) $$invalidate(19, EnableCursor = $$props.EnableCursor);
    		if ('CurrentSelectedRow' in $$props) $$invalidate(9, CurrentSelectedRow = $$props.CurrentSelectedRow);
    		if ('Striped' in $$props) $$invalidate(20, Striped = $$props.Striped);
    		if ('fixColumn' in $$props) $$invalidate(51, fixColumn = $$props.fixColumn);
    		if ('columnAffixLineLeft' in $$props) $$invalidate(24, columnAffixLineLeft = $$props.columnAffixLineLeft);
    		if ('columnWidths' in $$props) $$invalidate(21, columnWidths = $$props.columnWidths);
    		if ('numRows' in $$props) $$invalidate(52, numRows = $$props.numRows);
    		if ('gridSpaceWidth' in $$props) $$invalidate(25, gridSpaceWidth = $$props.gridSpaceWidth);
    		if ('gridSpaceHeight' in $$props) $$invalidate(26, gridSpaceHeight = $$props.gridSpaceHeight);
    		if ('numRowsInViewport' in $$props) $$invalidate(53, numRowsInViewport = $$props.numRowsInViewport);
    		if ('visibleRows' in $$props) $$invalidate(27, visibleRows = $$props.visibleRows);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*columns*/ 1) {
    			{
    				// if width was not provided for this column, give it a default value
    				$$invalidate(21, columnWidths = columns.map(x => x.width || MIN_COLUMN_SIZE));
    			}
    		}

    		if ($$self.$$.dirty[0] & /*__affixedColumnIndices, __scrollLeft, columnWidths*/ 2097170) {
    			{
    				// if no columns are affixed, set the line all the way to the left
    				if (__affixedColumnIndices.length === 0) {
    					$$invalidate(24, columnAffixLineLeft = 0);
    				}

    				let left = __scrollLeft;

    				for (let i = 0; i < __affixedColumnIndices.length; i++) {
    					left += columnWidths[__affixedColumnIndices[i]];
    				}

    				$$invalidate(24, columnAffixLineLeft = left);
    			}
    		}

    		if ($$self.$$.dirty[1] & /*rows*/ 1024) {
    			{
    				$$invalidate(52, numRows = rows.length);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*columnWidths, __resizing*/ 2097156 | $$self.$$.dirty[1] & /*__scrolledAllTheWayToTheRight*/ 4096) {
    			{
    				let sum = 0;

    				for (let i = 0; i < columnWidths.length; i++) {
    					sum += columnWidths[i];
    				}

    				/**
     * If the table is scrolled all the way to the right, resizing columns could
     * accelerate until the column is the minimum width. Add some extra space on the right
     * to ensure this undesired behavior does not happen. This doesn't seem like a perfect solution
     * but it works for now until I can think of something better.
     */
    				if (__resizing && __scrolledAllTheWayToTheRight) {
    					sum *= 2;
    				}

    				$$invalidate(25, gridSpaceWidth = sum);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*rowHeight*/ 1024 | $$self.$$.dirty[1] & /*numRows*/ 2097152) {
    			{
    				$$invalidate(26, gridSpaceHeight = rowHeight * numRows);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*__innerOffsetHeight, rowHeight*/ 1032) {
    			{
    				$$invalidate(53, numRowsInViewport = Math.ceil(__innerOffsetHeight / rowHeight));
    			}
    		}

    		if ($$self.$$.dirty[0] & /*rowHeight*/ 1024 | $$self.$$.dirty[1] & /*__scrollTop, __extraRows, numRowsInViewport, rows*/ 4262912) {
    			{
    				const start = Math.max(0, Math.floor(__scrollTop / rowHeight - __extraRows / 2));
    				const end = start + numRowsInViewport + __extraRows;

    				$$invalidate(27, visibleRows = rows.slice(start, end).map((x, i) => {
    					return {
    						i: i + start, // for aria-rowindex
    						data: x, // the row data
    						
    					};
    				}));
    			}
    		}
    	};

    	return [
    		columns,
    		__affixedColumnIndices,
    		__resizing,
    		__innerOffsetHeight,
    		__scrollLeft,
    		__affixingRow,
    		__affixingColumn,
    		__columnDragging,
    		__columnActionLineLeft,
    		CurrentSelectedRow,
    		rowHeight,
    		headerHeight,
    		allowResizeFromTableCells,
    		allowResizeFromTableHeaders,
    		allowColumnReordering,
    		allowColumnAffix,
    		__columnHeaderResizeCaptureWidth,
    		__rowActionLineTop,
    		__rowAffixLineTop,
    		EnableCursor,
    		Striped,
    		columnWidths,
    		wrapper,
    		tableSpace,
    		columnAffixLineLeft,
    		gridSpaceWidth,
    		gridSpaceHeight,
    		visibleRows,
    		onWindowKeyDown,
    		onMouseMove,
    		onMouseUp,
    		onCellUpdated,
    		onColumnAffixStart,
    		onRowAffixStart,
    		onColumnDragStart,
    		onColumnResizeStart,
    		onScroll,
    		mousewheel,
    		getCellZIndex,
    		getRowTop,
    		onClickRow,
    		rows,
    		__scrollTop,
    		__scrolledAllTheWayToTheRight,
    		__columnIndexBeingDragged,
    		__columnDragOffsetX,
    		__columnIndexBeingResized,
    		__extraRows,
    		threshold,
    		horizontal,
    		hasMore,
    		fixColumn,
    		numRows,
    		numRowsInViewport,
    		mousedown_handler,
    		mousedown_handler_1,
    		mousedown_handler_2,
    		div4_binding,
    		div4_elementresize_handler,
    		div5_binding
    	];
    }

    class Svelte_data_grid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$2,
    			create_fragment$2,
    			safe_not_equal,
    			{
    				rows: 41,
    				columns: 0,
    				rowHeight: 10,
    				headerHeight: 11,
    				allowResizeFromTableCells: 12,
    				allowResizeFromTableHeaders: 13,
    				allowColumnReordering: 14,
    				allowColumnAffix: 15,
    				__extraRows: 47,
    				__columnHeaderResizeCaptureWidth: 16,
    				__affixedColumnIndices: 1,
    				__affixingRow: 5,
    				__affixingColumn: 6,
    				__rowActionLineTop: 17,
    				__rowAffixLineTop: 18,
    				__columnDragging: 7,
    				__columnIndexBeingDragged: 44,
    				__columnDragOffsetX: 45,
    				__resizing: 2,
    				__columnIndexBeingResized: 46,
    				__columnActionLineLeft: 8,
    				__innerOffsetHeight: 3,
    				__scrollTop: 42,
    				__scrollLeft: 4,
    				__scrolledAllTheWayToTheRight: 43,
    				threshold: 48,
    				horizontal: 49,
    				hasMore: 50,
    				EnableCursor: 19,
    				CurrentSelectedRow: 9,
    				Striped: 20,
    				fixColumn: 51
    			},
    			null,
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Svelte_data_grid",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get rows() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get columns() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columns(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowHeight() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowHeight(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get headerHeight() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerHeight(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allowResizeFromTableCells() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowResizeFromTableCells(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allowResizeFromTableHeaders() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowResizeFromTableHeaders(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allowColumnReordering() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowColumnReordering(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get allowColumnAffix() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowColumnAffix(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __extraRows() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __extraRows(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __columnHeaderResizeCaptureWidth() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __columnHeaderResizeCaptureWidth(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __affixedColumnIndices() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __affixedColumnIndices(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __affixingRow() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __affixingRow(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __affixingColumn() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __affixingColumn(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __rowActionLineTop() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __rowActionLineTop(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __rowAffixLineTop() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __rowAffixLineTop(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __columnDragging() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __columnDragging(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __columnIndexBeingDragged() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __columnIndexBeingDragged(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __columnDragOffsetX() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __columnDragOffsetX(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __resizing() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __resizing(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __columnIndexBeingResized() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __columnIndexBeingResized(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __columnActionLineLeft() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __columnActionLineLeft(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __innerOffsetHeight() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __innerOffsetHeight(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __scrollTop() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __scrollTop(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __scrollLeft() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __scrollLeft(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get __scrolledAllTheWayToTheRight() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set __scrolledAllTheWayToTheRight(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get threshold() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set threshold(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get horizontal() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set horizontal(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasMore() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasMore(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get EnableCursor() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set EnableCursor(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get CurrentSelectedRow() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set CurrentSelectedRow(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Striped() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Striped(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixColumn() {
    		throw new Error("<Svelte_data_grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixColumn(value) {
    		throw new Error("<Svelte_data_grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\layouts\Ships-table.svelte generated by Svelte v3.46.3 */

    const { Object: Object_1 } = globals;

    const file$1 = "src\\layouts\\Ships-table.svelte";

    function create_fragment$1(ctx) {
    	let div1;
    	let div0;
    	let datagrid;
    	let div0_resize_listener;
    	let current;

    	datagrid = new Svelte_data_grid({
    			props: {
    				headerHeight: 44,
    				rowHeight: 52,
    				rows: /*gridData*/ ctx[4],
    				columns: /*gridColumns*/ ctx[1],
    				fixColumn: 1,
    				allowColumnReordering: false
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(datagrid.$$.fragment);
    			attr_dev(div0, "class", "grid-wrapper svelte-15w4stl");
    			add_render_callback(() => /*div0_elementresize_handler*/ ctx[10].call(div0));
    			add_location(div0, file$1, 55, 4, 1919);
    			attr_dev(div1, "class", "grid-frame svelte-15w4stl");
    			attr_dev(div1, "style", /*gridWrapStyle*/ ctx[3]);
    			add_location(div1, file$1, 54, 0, 1867);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(datagrid, div0, null);
    			div0_resize_listener = add_resize_listener(div0, /*div0_elementresize_handler*/ ctx[10].bind(div0));
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const datagrid_changes = {};
    			if (dirty & /*gridData*/ 16) datagrid_changes.rows = /*gridData*/ ctx[4];
    			if (dirty & /*gridColumns*/ 2) datagrid_changes.columns = /*gridColumns*/ ctx[1];
    			datagrid.$set(datagrid_changes);

    			if (!current || dirty & /*gridWrapStyle*/ 8) {
    				attr_dev(div1, "style", /*gridWrapStyle*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datagrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datagrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(datagrid);
    			div0_resize_listener();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let verticalPadding;
    	let gridColumns;
    	let gridData;
    	let gridWrapStyle;
    	let $ships;
    	let $tokenPrices;
    	validate_store(ships, 'ships');
    	component_subscribe($$self, ships, $$value => $$invalidate(8, $ships = $$value));
    	validate_store(tokenPrices, 'tokenPrices');
    	component_subscribe($$self, tokenPrices, $$value => $$invalidate(9, $tokenPrices = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ships_table', slots, []);
    	let { heightOffset = 0 } = $$props;
    	let width;
    	let height;
    	let sortData = buildSortData();

    	const composeClickHandler = dataName => e => {
    		$$invalidate(
    			6,
    			sortData[dataName] = sortData[dataName] === ''
    			? ASCEND
    			: sortData[dataName] === ASCEND ? DESCEND : '',
    			sortData
    		);

    		for (const key of Object.keys(sortData)) {
    			if (key !== dataName) {
    				$$invalidate(6, sortData[key] = '', sortData);
    			}
    		}

    		$$invalidate(6, sortData = { ...sortData });
    	};

    	const calcTableHeight = (shipList, padding) => {
    		const nativeHeight = (shipList.length || 1) * 53 + 56;
    		const tooNarrow = getDocWidth() < 760;
    		const tooShort = getDocHeight() < 600;

    		if (tooNarrow || tooShort) {
    			return nativeHeight;
    		}

    		return Math.min(getDocHeight() - padding, nativeHeight);
    	};

    	const writable_props = ['heightOffset'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Ships_table> was created with unknown prop '${key}'`);
    	});

    	function div0_elementresize_handler() {
    		width = this.clientWidth;
    		height = this.clientHeight;
    		$$invalidate(0, width);
    		$$invalidate(2, height);
    	}

    	$$self.$$set = $$props => {
    		if ('heightOffset' in $$props) $$invalidate(5, heightOffset = $$props.heightOffset);
    	};

    	$$self.$capture_state = () => ({
    		ASCEND,
    		DESCEND,
    		getDocHeight,
    		getDocWidth,
    		DataGrid: Svelte_data_grid,
    		ships,
    		tokenPrices,
    		buildSortData,
    		composeColumns,
    		composeShipData,
    		heightOffset,
    		width,
    		height,
    		sortData,
    		composeClickHandler,
    		calcTableHeight,
    		verticalPadding,
    		gridWrapStyle,
    		gridColumns,
    		gridData,
    		$ships,
    		$tokenPrices
    	});

    	$$self.$inject_state = $$props => {
    		if ('heightOffset' in $$props) $$invalidate(5, heightOffset = $$props.heightOffset);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    		if ('sortData' in $$props) $$invalidate(6, sortData = $$props.sortData);
    		if ('verticalPadding' in $$props) $$invalidate(7, verticalPadding = $$props.verticalPadding);
    		if ('gridWrapStyle' in $$props) $$invalidate(3, gridWrapStyle = $$props.gridWrapStyle);
    		if ('gridColumns' in $$props) $$invalidate(1, gridColumns = $$props.gridColumns);
    		if ('gridData' in $$props) $$invalidate(4, gridData = $$props.gridData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*heightOffset*/ 32) {
    			$$invalidate(7, verticalPadding = 126 + heightOffset);
    		}

    		if ($$self.$$.dirty & /*width, sortData*/ 65) {
    			$$invalidate(1, gridColumns = !width
    			? []
    			: composeColumns(composeClickHandler, sortData));
    		}

    		if ($$self.$$.dirty & /*$ships, gridColumns, sortData, $tokenPrices*/ 834) {
    			$$invalidate(4, gridData = composeShipData($ships, gridColumns, sortData, $tokenPrices));
    		}

    		if ($$self.$$.dirty & /*$ships, verticalPadding*/ 384) {
    			$$invalidate(3, gridWrapStyle = 'height: ' + calcTableHeight($ships, verticalPadding) + 'px;');
    		}
    	};

    	return [
    		width,
    		gridColumns,
    		height,
    		gridWrapStyle,
    		gridData,
    		heightOffset,
    		sortData,
    		verticalPadding,
    		$ships,
    		$tokenPrices,
    		div0_elementresize_handler
    	];
    }

    class Ships_table extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { heightOffset: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ships_table",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get heightOffset() {
    		throw new Error("<Ships_table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set heightOffset(value) {
    		throw new Error("<Ships_table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\App.svelte generated by Svelte v3.46.3 */
    const file = "src\\App.svelte";

    // (63:37) 
    function create_if_block_1(ctx) {
    	let shipstable;
    	let current;

    	shipstable = new Ships_table({
    			props: { heightOffset: /*heightOffset*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(shipstable.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(shipstable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const shipstable_changes = {};
    			if (dirty & /*heightOffset*/ 4) shipstable_changes.heightOffset = /*heightOffset*/ ctx[2];
    			shipstable.$set(shipstable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shipstable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shipstable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(shipstable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(63:37) ",
    		ctx
    	});

    	return block;
    }

    // (61:3) {#if displayMode === 'grid'}
    function create_if_block(ctx) {
    	let shipsgrid;
    	let current;
    	shipsgrid = new Ships_grid({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(shipsgrid.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(shipsgrid, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shipsgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shipsgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(shipsgrid, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(61:3) {#if displayMode === 'grid'}",
    		ctx
    	});

    	return block;
    }

    // (47:1) <Modal show={$modalStatus}   unstyled={true}   classBg="modal-bg"   classWindowWrap="modal-window-wrap"   classWindow="modal-window"   classContent="modal-content"   classCloseButton="modal-close-button"   closeButton={ModalCloseButton} >
    function create_default_slot(ctx) {
    	let headerbar;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	headerbar = new Header_bar({
    			props: {
    				showModeSwitch: /*showModeSwitch*/ ctx[1],
    				displayMode: /*displayMode*/ ctx[0],
    				switchDisplayMode: /*switchDisplayMode*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block, create_if_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*displayMode*/ ctx[0] === 'grid') return 0;
    		if (/*displayMode*/ ctx[0] === 'table') return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			create_component(headerbar.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(headerbar, target, anchor);
    			insert_dev(target, t, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const headerbar_changes = {};
    			if (dirty & /*showModeSwitch*/ 2) headerbar_changes.showModeSwitch = /*showModeSwitch*/ ctx[1];
    			if (dirty & /*displayMode*/ 1) headerbar_changes.displayMode = /*displayMode*/ ctx[0];
    			headerbar.$set(headerbar_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headerbar.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headerbar.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(headerbar, detaching);
    			if (detaching) detach_dev(t);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(47:1) <Modal show={$modalStatus}   unstyled={true}   classBg=\\\"modal-bg\\\"   classWindowWrap=\\\"modal-window-wrap\\\"   classWindow=\\\"modal-window\\\"   classContent=\\\"modal-content\\\"   classCloseButton=\\\"modal-close-button\\\"   closeButton={ModalCloseButton} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let modal;
    	let t;
    	let lightbox;
    	let current;

    	modal = new Modal({
    			props: {
    				show: /*$modalStatus*/ ctx[3],
    				unstyled: true,
    				classBg: "modal-bg",
    				classWindowWrap: "modal-window-wrap",
    				classWindow: "modal-window",
    				classContent: "modal-content",
    				classCloseButton: "modal-close-button",
    				closeButton: Modal_close_button,
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	lightbox = new Lightbox({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(modal.$$.fragment);
    			t = space();
    			create_component(lightbox.$$.fragment);
    			attr_dev(main, "class", "svelte-app-main svelte-1ixvpnf");
    			add_location(main, file, 45, 0, 1470);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(modal, main, null);
    			append_dev(main, t);
    			mount_component(lightbox, main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const modal_changes = {};
    			if (dirty & /*$modalStatus*/ 8) modal_changes.show = /*$modalStatus*/ ctx[3];

    			if (dirty & /*$$scope, displayMode, heightOffset, showModeSwitch*/ 135) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			transition_in(lightbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			transition_out(lightbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(modal);
    			destroy_component(lightbox);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $modalStatus;
    	validate_store(modalStatus, 'modalStatus');
    	component_subscribe($$self, modalStatus, $$value => $$invalidate(3, $modalStatus = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const { MIN_WIDTH } = RESPONSIVE;
    	let displayMode = getDocWidth() < MIN_WIDTH ? 'grid' : 'table';
    	let showModeSwitch = false;
    	let heightOffset = 0;

    	const updateDisplayMode = () => {
    		$$invalidate(0, displayMode = getDocWidth() < MIN_WIDTH ? 'grid' : displayMode);
    		$$invalidate(1, showModeSwitch = getDocWidth() < MIN_WIDTH ? false : true);
    	};

    	onMount(() => {
    		window.addEventListener('resizeend', updateDisplayMode);
    		updateDisplayMode();
    		fetchNFTs();
    		const root = document.getElementById('star-atlas-dashboard');
    		$$invalidate(2, heightOffset = Number(root.getAttribute('data-height-offset') || 0));
    	});

    	const switchDisplayMode = mode => () => {
    		if (mode) {
    			$$invalidate(0, displayMode = getDocWidth() < MIN_WIDTH ? 'grid' : mode);
    		} else {
    			$$invalidate(0, displayMode = displayMode === 'grid'
    			? getDocWidth() < MIN_WIDTH ? 'grid' : 'table'
    			: 'grid');
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Modal,
    		Lightbox,
    		RESPONSIVE,
    		getDocWidth,
    		modalStatus,
    		fetchNFTs,
    		HeaderBar: Header_bar,
    		ModalCloseButton: Modal_close_button,
    		ShipsGrid: Ships_grid,
    		ShipsTable: Ships_table,
    		MIN_WIDTH,
    		displayMode,
    		showModeSwitch,
    		heightOffset,
    		updateDisplayMode,
    		switchDisplayMode,
    		$modalStatus
    	});

    	$$self.$inject_state = $$props => {
    		if ('displayMode' in $$props) $$invalidate(0, displayMode = $$props.displayMode);
    		if ('showModeSwitch' in $$props) $$invalidate(1, showModeSwitch = $$props.showModeSwitch);
    		if ('heightOffset' in $$props) $$invalidate(2, heightOffset = $$props.heightOffset);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [displayMode, showModeSwitch, heightOffset, $modalStatus, switchDisplayMode];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.getElementById('star-atlas-dashboard')
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
